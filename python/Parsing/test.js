(function() {
    var __webpack_modules__ = {
        81442: function(e, t, r) {
            var s = {
                "./lang.en.json": [73526, 73526],
                "./lang.ka.json": [90861, 90861],
                "./lang.kk.json": [20939, 20939],
                "./lang.ru.json": [17728]
            };
            function n(e) {
                if (!r.o(s, e))
                    return Promise.resolve().then((function() {
                        var t = new Error("Cannot find module '" + e + "'");
                        throw t.code = "MODULE_NOT_FOUND",
                        t
                    }
                    ));
                var t = s[e]
                  , n = t[0];
                return Promise.all(t.slice(1).map(r.e)).then((function() {
                    return r.t(n, 19)
                }
                ))
            }
            n.keys = function() {
                return Object.keys(s)
            }
            ,
            n.id = 81442,
            e.exports = n
        },
        62894: function() {
            "use strict";
            const e = {};
            let t, r;
            function s(e) {
                const t = [].slice.call(arguments, 1);
                return e.replace(/{(\d+)}/g, (function(e, r) {
                    return void 0 !== t[r] ? t[r] : e
                }
                ))
            }
            function n(t) {
                return {
                    value: e[t] || t,
                    notfound: !e[t]
                }
            }
            function a(e) {
                return "[object Object]" === Object.prototype.toString.call(e)
            }
            t = r = function(e) {
                return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2
            }
            ,
            $.localize = function() {
                if (1 === arguments.length)
                    return a(arguments[0]) ? void ("function" == typeof (t = arguments[0].pluralRule) && 1 == t.length && (r = t)) : n(arguments[0]).value;
                var t;
                if (2 == arguments.length && a(arguments[1]))
                    Object.assign(e, arguments[1]);
                else if (arguments.length > 1 && arguments[0] && arguments[0].indexOf(!1)) {
                    const e = [].slice.call(arguments, 1);
                    return e.unshift(n(arguments[0]).value),
                    s.apply(this, e)
                }
            }
            ,
            $.pluralize = function() {
                if (arguments.length < 2)
                    return arguments[0];
                const e = new Array(arguments.length - 1);
                for (let t = 0; t < arguments.length - 1; t++)
                    e[t] = arguments[t + 1];
                const a = n(e.join(","))
                  , o = a.value.split(",")
                  , i = a.notfound ? t(arguments[0]) : r(arguments[0])
                  , l = o[i < o.length ? i : o.length - 1];
                return l.indexOf("{0}") > -1 ? s(l, arguments[0]) : l
            }
        },
        82816: function() {
            "use strict";
            DOMTokenList.prototype.addMany = function(e) {
                if (null == e || !Array.isArray(e))
                    throw new Error("DOMTokenList.prototype.addMany accepts only array");
                e.forEach((e => this.add(e)))
            }
            ,
            DOMTokenList.prototype.removeMany = function(e) {
                if (null == e || !Array.isArray(e))
                    throw new Error("DOMTokenList.prototype.removeMany accepts only array");
                e.forEach((e => this.remove(e)))
            }
        },
        62818: function() {
            "use strict";
            HTMLElement.prototype.hide = function() {
                this.style.display = "none"
            }
            ,
            HTMLElement.prototype.show = function() {
                this.style.display = "block"
            }
            ,
            HTMLElement.prototype.width = function() {
                return 0 == this.clientWidth ? getComputedStyle(this).width.replace("px", "") : this.clientWidth
            }
            ,
            HTMLElement.prototype.wrap = function(e) {
                let t = (new DOMParser).parseFromString(e, "text/html").body.firstElementChild;
                for (this.parentNode.insertBefore(t, this); null != t.firstElementChild; )
                    t = t.firstElementChild;
                t.appendChild(this)
            }
            ,
            HTMLElement.prototype.parents = function(e) {
                for (var t = [], r = this, s = void 0 !== e; null !== (r = r.parentElement); )
                    r.nodeType === Node.ELEMENT_NODE && (s && !r.matches(e) || t.push(r));
                return t
            }
            ,
            HTMLElement.prototype.isHidden = function() {
                return 0 === this.offsetWidth && 0 === this.offsetHeight || "none" === window.getComputedStyle(this).display
            }
            ,
            HTMLElement.prototype.isVisible = function() {
                return !this.isHidden()
            }
        },
        84366: function() {
            "use strict";
            URLSearchParams.prototype.toDictionary = function() {
                const e = {};
                return this.forEach(( (t, r) => e[r] = t)),
                e
            }
            ,
            URLSearchParams.prototype.hasOwnProperty("size") || Object.defineProperty(URLSearchParams.prototype, "size", {
                get: function() {
                    let e = 0;
                    for (let t of this.keys())
                        e++;
                    return e
                }
            })
        },
        200: function() {
            "use strict";
            Array.prototype.getIntesection = function(e) {
                return Array.isArray(e) ? this.filter((t => e.includes(t))) : (console.error("Argument must be an array"),
                [])
            }
            ,
            Array.prototype.last || (Array.prototype.last = function() {
                return this[this.length - 1]
            }
            ),
            Array.prototype.first || (Array.prototype.first = function() {
                return this[0]
            }
            ),
            Array.prototype.max = function() {
                return Math.max.apply(null, this)
            }
            ,
            Array.prototype.min = function() {
                return Math.min.apply(null, this)
            }
            ,
            Array.prototype.findWhere = function(e) {
                return this.find((t => Object.keys(e).every((r => t[r] === e[r]))))
            }
            ,
            Array.prototype.distinct = function() {
                return this.filter((function(e, t, r) {
                    return r.indexOf(e) === t
                }
                ))
            }
            ,
            Array.prototype.toHashSet = function(e) {
                if (null != e && "function" != typeof e)
                    throw new TypeError("toHashSet method require callback function or null");
                return this.reduce(( (t, r) => {
                    var s;
                    return t.add(null != (s = null == e ? void 0 : e(r)) ? s : r),
                    t
                }
                ), new Set)
            }
            ,
            Array.prototype.toMap = function(e, t) {
                if (null != e && "function" != typeof e)
                    throw new TypeError("toMap method require callback function or null");
                if (null != t && "function" != typeof t)
                    throw new TypeError("toMap method require callback function or null");
                return this.reduce(( (r, s) => (r.set(null == e ? s : e(s), null == t ? s : t(s)),
                r)), new Map)
            }
            ,
            Array.prototype.sum = function(e) {
                let t = 0;
                for (let r = 0, s = this.length; r < s; r++)
                    t += e ? this[r][e] : this[r];
                return t
            }
            ,
            Array.prototype.sumBy = function(e) {
                let t = 0;
                for (let r = 0, s = this.length; r < s; r++)
                    t += e(this[r]);
                return t
            }
            ,
            Array.prototype.groupBy = function(e) {
                const t = new Map;
                return this.forEach((r => {
                    const s = e(r)
                      , n = t.get(s);
                    n ? n.push(r) : t.set(s, [r])
                }
                )),
                t
            }
            ,
            Array.prototype.selectMany = function(e) {
                return this.length ? this.map((t => e(t))).reduce(( (e, t) => e.concat(t))) : []
            }
            ,
            Array.prototype.toChunk = function(e) {
                const t = Math.ceil(this.length / e)
                  , r = new Array(t);
                for (let s = 0; s < t; s++) {
                    const t = e * s;
                    r[s] = this.slice(t, t + e)
                }
                return r
            }
            ,
            Array.prototype.merge = function(e, {lookup: t=e => e, hasConflict: r= (e, t) => !1}={}) {
                if (!e || 0 == e.length)
                    return !1;
                const s = new Map;
                for (const e of this || []) {
                    const r = JSON.stringify(t(e));
                    s.set(r, e)
                }
                let n = !1;
                for (const a of e) {
                    const e = JSON.stringify(t(a));
                    if (s.has(e)) {
                        const t = s.get(e);
                        r(a, t) && (Object.assign(t, a),
                        n = !0)
                    } else
                        this.push(a),
                        n = !0
                }
                return n
            }
            ,
            Array.prototype.diff = function(e, {lookup: t=e => e, hasConflict: r= (e, t) => !1}={}) {
                const s = [];
                if (!e || 0 == e.length)
                    return s;
                const n = new Map;
                for (const e of this || []) {
                    const r = JSON.stringify(t(e));
                    n.set(r, e)
                }
                for (const a of e) {
                    const e = JSON.stringify(t(a));
                    if (n.has(e)) {
                        r(a, n.get(e)) && s.push(a)
                    } else
                        s.push(a)
                }
                return s
            }
            ,
            Array.prototype.remove = function(e) {
                let t = this.indexOf(e);
                t > -1 && this.splice(t, 1)
            }
        },
        24441: function() {
            "use strict";
            Date.prototype.format = function(e, t) {
                var r = function() {
                    var e = /d{1,4}|M{1,5}|yy(?:yy)?|([HhmsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g
                      , t = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g
                      , s = /[^-+\dA-Z]/g
                      , n = function(e, t) {
                        for (e = String(e),
                        t = t || 2; e.length < t; )
                            e = "0" + e;
                        return e
                    };
                    return function(a, o, i) {
                        var l = r;
                        if (1 != arguments.length || "[object String]" != Object.prototype.toString.call(a) || /\d/.test(a) || (o = a,
                        a = void 0),
                        a = a ? new Date(a) : new Date,
                        isNaN(a))
                            throw SyntaxError("invalid date");
                        "UTC:" == (o = String(l.masks[o] || o || l.masks.default)).slice(0, 4) && (o = o.slice(4),
                        i = !0);
                        var c = i ? "getUTC" : "get"
                          , u = a[c + "Date"]()
                          , d = a[c + "Day"]()
                          , p = a[c + "Month"]()
                          , h = a[c + "FullYear"]()
                          , m = a[c + "Hours"]()
                          , g = a[c + "Minutes"]()
                          , y = a[c + "Seconds"]()
                          , b = a[c + "Milliseconds"]()
                          , f = i ? 0 : a.getTimezoneOffset()
                          , v = {
                            d: u,
                            dd: n(u),
                            ddd: l.i18n.dayNames[d],
                            dddd: l.i18n.dayNames[d + 7],
                            M: p + 1,
                            MM: n(p + 1),
                            MMM: l.i18n.monthShortNames[p],
                            MMMM: l.i18n.monthNames[p + 12],
                            MMMMM: l.i18n.monthNames[p + 24],
                            yy: String(h).slice(2),
                            yyyy: h,
                            h: m % 12 || 12,
                            hh: n(m % 12 || 12),
                            H: m,
                            HH: n(m),
                            m: g,
                            mm: n(g),
                            s: y,
                            ss: n(y),
                            l: n(b, 3),
                            L: n(b > 99 ? Math.round(b / 10) : b),
                            t: m < 12 ? "a" : "p",
                            tt: m < 12 ? "am" : "pm",
                            T: m < 12 ? "A" : "P",
                            TT: m < 12 ? "AM" : "PM",
                            Z: i ? "UTC" : (String(a).match(t) || [""]).pop().replace(s, ""),
                            o: (f > 0 ? "-" : "+") + n(100 * Math.floor(Math.abs(f) / 60) + Math.abs(f) % 60, 4),
                            S: ["th", "st", "nd", "rd"][u % 10 > 3 ? 0 : (u % 100 - u % 10 != 10) * u % 10]
                        };
                        return o.replace(e, (function(e) {
                            return e in v ? v[e] : e.slice(1, e.length - 1)
                        }
                        ))
                    }
                }();
                return r.masks = {
                    default: "ddd mmm dd yyyy HH:MM:ss",
                    shortDate: "m/d/yy",
                    mediumDate: "mmm d, yyyy",
                    longDate: "mmmm d, yyyy",
                    fullDate: "dddd, mmmm d, yyyy",
                    shortTime: "h:MM TT",
                    mediumTime: "h:MM:ss TT",
                    longTime: "h:MM:ss TT Z",
                    isoDate: "yyyy-mm-dd",
                    isoTime: "HH:MM:ss",
                    isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
                    isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
                },
                r.i18n = {
                    dayNames: ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота"],
                    monthNames: ["Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек", "января", "февраля", "марта", "апреля", "мая", "июня", "июля", "августа", "сентября", "октября", "ноября", "декабря"],
                    monthShortNames: ["янв", "февр", "марта", "апр", "мая", "июня", "июля", "авг", "сент", "окт", "нояб", "дек"]
                },
                $.localize.dfr && (r.i18n.dayNames = $.localize.dfr.abbreviatedDayNames.concat($.localize.dfr.dayNames),
                $.localize.dfr.abbreviatedMonthNames[1] = "февр",
                $.localize.dfr.abbreviatedMonthNames[2] = "марта",
                $.localize.dfr.abbreviatedMonthNames[4] = "мая",
                $.localize.dfr.abbreviatedMonthNames[5] = "июня",
                $.localize.dfr.abbreviatedMonthNames[6] = "июля",
                $.localize.dfr.abbreviatedMonthNames[8] = "сент",
                $.localize.dfr.abbreviatedMonthNames[10] = "нояб",
                r.i18n.monthNames = $.localize.dfr.abbreviatedMonthNames.concat($.localize.dfr.monthGenitiveNames).concat($.localize.dfr.monthNames.map((e => e.charAt(0).toUpperCase() + e.slice(1))))),
                r(this, e, t)
            }
            ,
            Date.prototype.daysBetween = function(e) {
                var t = new Date(this.getFullYear(),this.getMonth(),this.getDate())
                  , r = (new Date(e.getFullYear(),e.getMonth(),e.getDate()).getTime() - t.getTime()) / 864e5;
                return Math.floor(r)
            }
            ,
            Date.prototype.dateEqual = function(e) {
                return this.getDate() === e.getDate() && this.getMonth() === e.getMonth() && this.getFullYear() === e.getFullYear()
            }
            ,
            Date.prototype.is1stJan = function() {
                return 1 === this.getDate() && 0 === this.getMonth()
            }
            ,
            Date.prototype.getUtcTime = function() {
                return this.getTime() - 6e4 * this.getTimezoneOffset()
            }
            ,
            Date.utcNow = function() {
                return (new Date).getUtcTime()
            }
            ,
            Date.prototype.addDays = function(e) {
                let t = new Date(this.valueOf());
                return t.setDate(t.getDate() + e),
                t
            }
            ,
            Date.prototype.addMinutes = function(e) {
                let t = new Date(this.valueOf());
                return t.setMinutes(t.getMinutes() + e),
                t
            }
            ,
            Date.prototype.addHours = function(e) {
                const t = new Date(this.valueOf());
                return isNaN(e) || t.setHours(t.getHours() + +e),
                t
            }
            ,
            Date.prototype.addMinutes = function(e) {
                let t = new Date(this.valueOf());
                return t.setMinutes(t.getMinutes() + e),
                t
            }
        },
        94301: function() {
            "use strict";
            Event.prototype.stopPropagation = function(e) {
                return function() {
                    this.isPropagationStopped = !0,
                    e.call(this)
                }
            }(Event.prototype.stopPropagation)
        },
        98307: function() {
            "use strict";
            var e = (e, t) => (t = Symbol[e]) ? t : Symbol.for("Symbol." + e)
              , t = function(e, t) {
                this[0] = e,
                this[1] = t
            }
              , r = r => {
                var s, n = r[e("asyncIterator")], a = !1, o = {};
                return null == n ? (n = r[e("iterator")](),
                s = e => o[e] = t => n[e](t)) : (n = n.call(r),
                s = e => o[e] = r => {
                    if (a) {
                        if (a = !1,
                        "throw" === e)
                            throw r;
                        return r
                    }
                    return a = !0,
                    {
                        done: !1,
                        value: new t(new Promise((t => {
                            var s = n[e](r);
                            s instanceof Object || (e => {
                                throw TypeError(e)
                            }
                            )("Object expected"),
                            t(s)
                        }
                        )),1)
                    }
                }
                ),
                o[e("iterator")] = () => o,
                s("next"),
                "throw"in n ? s("throw") : o.throw = e => {
                    throw e
                }
                ,
                "return"in n && s("return"),
                o
            }
            ;
            Map.prototype.every = function(e) {
                if ("function" != typeof e)
                    throw new TypeError("Callback is not a function");
                let t = !0;
                return this.forEach(( (r, s, n) => {
                    t &= e(r, s, n)
                }
                )),
                1 == t
            }
            ,
            Map.prototype.some = function(e) {
                if (!(e instanceof Function))
                    throw new TypeError("Callback is not a function");
                let t = !1;
                return this.forEach(( (r, s, n) => {
                    t || (t = e(r, s, n))
                }
                )),
                t
            }
            ,
            Map.prototype.reduce = function(e, t) {
                if ("function" != typeof e)
                    throw new TypeError("Map reduce argument 1 must be a function");
                let r = t
                  , s = 0;
                return this.forEach(( (n, a, o) => {
                    s++,
                    r = 1 != s || null != t ? e(r, n, a, o) : n
                }
                )),
                r
            }
            ,
            Map.prototype.map = function(e) {
                if ("function" != typeof e)
                    throw new TypeError("Callback is not a function");
                const t = new Map;
                return this.forEach(( (r, s, n) => {
                    t.set(s, e(r, s, n))
                }
                )),
                t
            }
            ,
            Map.prototype.toArray = function(e) {
                if ("function" != typeof e && null != e)
                    throw new TypeError("Callback if not a function");
                const t = [];
                return this.forEach(( (r, s, n) => t.push(null == e ? r : e(r, s, n)))),
                t
            }
            ,
            Map.prototype.find = function(e) {
                if ("function" != typeof e)
                    throw new TypeError("Callback is not a function");
                let t = null;
                return this.forEach(( (r, s, n) => {
                    t || e(r, s, n) && (t = r)
                }
                )),
                t
            }
            ,
            Map.prototype.sort = function(e) {
                let t = new Map;
                this[Symbol.iterator] = function*() {
                    yield*r([...this.entries()].sort(e))
                }
                ;
                for (let[e,r] of this)
                    t.set(e, r);
                return t
            }
        },
        98892: function() {
            "use strict";
            Number.prototype.formatMoney = function(e, t, r) {
                var s = this
                  , n = (e = isNaN(e = Math.abs(e)) ? 2 : e,
                t = null == t ? "." : t,
                r = null == r ? "," : r,
                s < 0 ? "-" : "")
                  , a = parseInt(s = Math.abs(+s || 0).toFixed(e)) + ""
                  , o = (o = a.length) > 3 ? o % 3 : 0;
                return n + (o ? a.substr(0, o) + r : "") + a.substr(o).replace(/(\d{3})(?=\d)/g, "$1" + r) + (e ? t + Math.abs(s - a).toFixed(e).slice(2) : "")
            }
            ,
            Number.prototype.countDecimals = function() {
                return Math.floor(this.valueOf()) === this.valueOf() ? 0 : this.toString().split(".")[1].length || 0
            }
            ,
            Number.prototype.toFixedNumber = function(e, t) {
                var r = Math.pow(t || 10, e);
                return Math.round(this * r) / r
            }
            ,
            Number.tryParseInt = function(e) {
                const t = parseInt(e);
                return isNaN(t) ? null : t
            }
            ,
            Number.prototype.isInt = function() {
                return this % 1 == 0
            }
            ,
            Number.prototype.floatToFixed = function(e) {
                return this.isInt() ? this : this.toFixed(e)
            }
        },
        18861: function() {
            "use strict";
            Set.prototype.toArray = function(e) {
                if (null != e && "function" != typeof e)
                    throw new TypeError("Callback at Set.prototype.toArray must be null or function");
                const t = [];
                return this.forEach((r => t.push(null == e ? r : e(r)))),
                t
            }
            ,
            Set.prototype.map = function(e) {
                if ("function" != typeof e)
                    throw new TypeError("Callback at Set.prototype.map must be function");
                const t = new Set;
                return this.forEach((r => t.add(e(r)))),
                t
            }
            ,
            Set.prototype.filter = function(e) {
                if ("function" != typeof e)
                    throw new TypeError("Callback at Set.prototype.map must be function");
                const t = new Set;
                return this.forEach((r => {
                    e(r) && t.add(r)
                }
                )),
                t
            }
        },
        84580: function() {
            "use strict";
            if ("localStorage"in window || null !== window.localStorage) {
                const e = Storage.prototype.setItem;
                Storage.prototype.setItem = function(t, r) {
                    try {
                        e.apply(this, arguments)
                    } catch (t) {
                        if (-1 === t.message.indexOf("quota"))
                            throw wb.spa.logError(t),
                            t;
                        let r, s, n = {
                            len: 0
                        }, a = 0;
                        for (s in localStorage)
                            localStorage.hasOwnProperty(s) && (r = 2 * (localStorage[s].length + s.length),
                            a += r,
                            n.len < r && (n = {
                                len: r,
                                key: s
                            }));
                        if (n.key)
                            if (n.len > 307200) {
                                this.removeItem(n.key);
                                const r = `localstorage delkey:${n.key}, len:${n.len / 1024} KB, key:${arguments[0]}, exp:${t.message}`;
                                console.log(r),
                                wb.spa.logError(new Error(r)),
                                e.apply(this, arguments)
                            } else {
                                const e = `localstorage exception key:${arguments[0]}, exp:${t.message}, storageKeys:${localStorage.length}, storageLen:${a / 1024} KB`;
                                console.log(e),
                                wb.spa.logError(new Error(e))
                            }
                    }
                }
                ,
                Storage.prototype.trySetItem = function(e, t) {
                    try {
                        this.setItem(e, t)
                    } catch (e) {}
                }
                ,
                Storage.prototype.clearStartsWith = function(e, t) {
                    if (e)
                        try {
                            Object.entries(this).filter((r => 0 === r[0].indexOf(e) && r[0] !== t)).forEach((e => {
                                this.removeItem(e[0])
                            }
                            ))
                        } catch (e) {}
                }
                ,
                Storage.prototype.putObject = function(e, t, {tryCatch: r}={}) {
                    if (r)
                        try {
                            this.setItem(e, JSON.stringify(t))
                        } catch (e) {}
                    else
                        this.setItem(e, JSON.stringify(t))
                }
                ,
                Storage.prototype.getObject = function(e) {
                    var t = this.getItem(e);
                    try {
                        return t && JSON.parse(t)
                    } catch (t) {
                        this.removeItem(e)
                    }
                    return null
                }
                ,
                Storage.prototype.hasItem = function(e) {
                    return null != this.getItem(e)
                }
            }
        },
        99836: function() {
            "use strict";
            String.prototype.capitalizeIf = function(e) {
                return e ? this.charAt(0).toUpperCase() + this.slice(1) : this
            }
            ,
            String.prototype.trimRight = function() {
                return this.replace(/\s+$/g, "")
            }
            ,
            String.prototype.trimLeft = function() {
                return this.replace(/^\s+/g, "")
            }
            ,
            String.prototype.trim = function() {
                return this.trimRight().trimLeft()
            }
            ,
            String.prototype.trimMiddle = function() {
                return this.trim().replace(/\s\s+/g, " ")
            }
            ,
            String.prototype.cleanTrashBetweenTd = function() {
                return this.replace(new RegExp(">[ \t\r\n\v\f]*<","g"), "><")
            }
            ,
            String.format = function() {
                for (var e = arguments[0], t = 0; t < arguments.length - 1; t++) {
                    var r = new RegExp("\\{" + t + "\\}","gm");
                    e = e.replace(r, arguments[t + 1])
                }
                return e
            }
            ,
            String.prototype.formatPhone = function(e) {
                let t = this.split("")
                  , r = "";
                for (let s = 0; s < e.length; s++)
                    r += "#" === e[s] ? t.splice(0, 1) : e[s];
                return r
            }
            ,
            String.prototype.capitalize = function() {
                return this.charAt(0).toUpperCase() + this.slice(1)
            }
            ,
            String.prototype.endsWith = function(e) {
                return -1 !== this.indexOf(e, this.length - e.length)
            }
            ,
            String.prototype.toSafeString = function() {
                return encodeURIComponent(this.replace(/<\/?[^>]+>/gi, "").trim())
            }
            ,
            String.prototype.hashCode = function() {
                let e, t, r = 0;
                if (0 === this.length)
                    return r;
                for (e = 0; e < this.length; e++)
                    t = this.charCodeAt(e),
                    r = (r << 5) - r + t,
                    r |= 0;
                return r
            }
        },
        81868: function(e, t, r) {
            "use strict";
            r(99836),
            r(200),
            r(98307),
            r(18861),
            r(62818),
            r(82816),
            r(24441),
            r(98892),
            r(84580),
            r(94301),
            r(84366);
            NodeList.prototype.toArray = function() {
                return Array.prototype.slice.call(this)
            }
            ,
            HTMLCollection.prototype.forEach = function(e) {
                Array.prototype.slice.call(this).forEach(( (t, r, s) => e(t, r, s)))
            }
            ,
            window.requestIdleCallback || (window.requestIdleCallback = function(e) {
                setTimeout(e, 1)
            }
            );
            r(64169);
            var s = r(73539);
            var n = class {
                init() {
                    const e = {}
                      , t = document.querySelector(".j-lk-menu-top")
                      , r = [{
                        type: "top",
                        selector: document.querySelector(".j-lk-menu-top")
                    }];
                    return this.alternateRoutes = new Map,
                    r.forEach((t => t.selector.querySelectorAll("a").forEach((t => {
                        var r;
                        let s;
                        try {
                            s = new URL(t.href).pathname
                        } catch (e) {
                            return
                        }
                        const n = "true" == t.dataset.main
                          , a = "true" == t.dataset.sub
                          , o = t.parentElement;
                        e.hasOwnProperty(s) || (e[s] = {
                            links: [],
                            elements: []
                        });
                        const i = t.closest(n ? "li" : "ul");
                        e[s].elements.push(i),
                        e[s].links.push({
                            el: o,
                            isMainMenu: n,
                            isSubMenu: a,
                            path: s,
                            switch: o.dataset.switch,
                            altSwitch: o.dataset.altSwitch
                        }),
                        null == (r = t.dataset.altRoutes) || r.split(",").forEach((e => {
                            e && this.alternateRoutes.set(e.trim(), s)
                        }
                        )),
                        "6" === i.dataset.attr && (this.walletWrapperEl = i,
                        this.walletEl = t,
                        this.walletEl.innerText = wb.settings.balanceTitle,
                        this.walletWrapperEl.classList.add(wb.settings.walletTypeCode > 0 ? "lk-menu-main__item--wallet" : "lk-menu-main__item--balance"))
                    }
                    )))),
                    this.menuDictionary = e,
                    this.menuDictionaryKeys = Object.keys(this.menuDictionary),
                    this.root = t,
                    this.roots = r.map((e => e.selector)),
                    this.nextAnimationFrame = null,
                    this._initDropDownMenu(),
                    this.toggleVisibilityNodes(),
                    wb.global.subscribe(this.toggleVisibilityNodes.bind(this)),
                    $.observe(wb.settings, "balanceTitle", ( () => {
                        this.walletEl.innerText = wb.settings.balanceTitle,
                        this.walletWrapperEl.classList.add(wb.settings.walletTypeCode > 0 ? "lk-menu-main__item--wallet" : "lk-menu-main__item--balance")
                    }
                    )),
                    this
                }
                setStatic(e) {
                    this.stylesLink = e.stylesLink
                }
                updateMenu(e, t, r) {
                    if (this.toggleVisibility(t, r),
                    "/" != e[0] && (e = "/" + e),
                    null == this.root)
                        return;
                    const s = this.alternateRoutes.get(e);
                    s && (e = s);
                    const n = this.menuDictionary[e];
                    if (null == n)
                        return;
                    const a = n.elements.length > 0 ? n.elements[0].dataset.attr : "";
                    this.menuDictionaryKeys.forEach((t => {
                        const r = this.menuDictionary[t].elements;
                        r.length > 0 && r.forEach((e => {
                            const t = e.dataset.attr == a;
                            e.classList.toggle("active", t)
                        }
                        )),
                        this.menuDictionary[t].links.forEach((t => {
                            !t.isMainMenu && t.el.classList.toggle("active", t.path == e)
                        }
                        ))
                    }
                    ))
                }
                toggleVisibility(e, t) {
                    if (!e || !e.visible || e.authOnly && void 0 !== t && !t)
                        return this.hide();
                    this.show()
                }
                toggleVisibilityNodes() {
                    this.menuDictionaryKeys.forEach((e => {
                        this.menuDictionary[e].links.forEach((e => {
                            if (e.switch || e.altSwitch) {
                                let t = wb.global.settings.switches[e.switch];
                                if (!t && e.altSwitch && (t = wb.global.settings.switches[e.altSwitch],
                                t))
                                    for (const [t,r] of this.alternateRoutes)
                                        if (r == e.path) {
                                            const r = e.el.querySelector("a");
                                            if (r) {
                                                r.href = t;
                                                break
                                            }
                                        }
                                e.el.classList.toggle("hide", !t)
                            }
                        }
                        ))
                    }
                    ))
                }
                async show() {
                    await this.$helper.loadCssAsync(this.stylesLink),
                    this.roots.forEach((e => e.classList.remove("hide"))),
                    "ru" == wb.settings.currentLocale || wb.global.userSettings.closed.includes("new_fin_oper_loc") || (wb.global.userSettings.closed.push("new_fin_oper_loc"),
                    wb.global.saveUserSettings(),
                    this._showFinOperationsTooltip())
                }
                hide() {
                    this.roots.forEach((e => e.classList.add("hide")))
                }
                _initDropDownMenu() {
                    const e = ["mouseleave", "click"];
                    this.menuDictionaryKeys.forEach((t => {
                        this.menuDictionary[t].links.forEach((t => {
                            t.isMainMenu && t.el.addEventListener("mouseover", ( () => {
                                t.isMainMenu && t.el.classList.add("open")
                            }
                            )),
                            e.forEach((function(e) {
                                t.isMainMenu && t.el.addEventListener(e, (function() {
                                    t.isMainMenu && t.el.classList.remove("open")
                                }
                                ))
                            }
                            ))
                        }
                        ))
                    }
                    )),
                    this._addClickStat()
                }
                _addClickStat() {
                    this.roots.forEach((e => {
                        e.addEventListener("click", (e => {
                            var t, r;
                            const s = null == (t = e.target) ? void 0 : t.closest("a")
                              , n = null == (r = null == s ? void 0 : s.dataset) ? void 0 : r.lkHeaderWba;
                            if (!n)
                                return;
                            const a = `${n}_T`;
                            this.$analitic.sendEvent(a)
                        }
                        ))
                    }
                    ))
                }
                _showFinOperationsTooltip() {
                    const e = "lk-menu-main__item--tooltip-active"
                      , t = document.getElementById("menuTooltipTarget");
                    if (!t)
                        return;
                    const r = t.querySelector(".j-tooltip-close")
                      , s = () => t.classList.remove(e);
                    null == r || r.addEventListener("click", s),
                    setTimeout(s, 6e3),
                    t.classList.add(e)
                }
            }
              , a = Object.defineProperty
              , o = Object.getOwnPropertySymbols
              , i = Object.prototype.hasOwnProperty
              , l = Object.prototype.propertyIsEnumerable
              , c = (e, t, r) => t in e ? a(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }) : e[t] = r;
            const u = new RegExp(["ru-basket-api.wildberries.ru", "basket-api.wildberries.by", "basket-api.wildberries.kz", "basket-api.wildberries.kg", "basket-api.wildberries.am", "basket-api.wildberries.tj", "basket-api.wildberries.uz", "localhost", "wbxoofex.wildberries.ru", "customs.wb.ru", "user-geo-data.wildberries.ru", "shopper-bt.wb.ru", "webappx-proxy.wbx-site-utility.k8s.stage-xc", "webapp-*.wbx-site.k8s.dev-el", "webapp-*.wbx-site.k8s.stage-dm", "webapp-*.wbx-site.k8s.prod-el", "kg.wildberries.ru", "uz.wildberries.ru"].map((e => e.replace(/\./g, "\\.").replace(/\*/g, ".*"))).join("|"))
              , d = new RegExp(["www.wildberries.ru", "www.wildberries.by", "www.wildberries.kz", "www.wildberries.kg", "kz.wildberries.ru", "www.wildberries.am", "www.wildberries.tj", "www.wildberries.uz", "ru-basket-api.wildberries.ru", "basket-api.wildberries.by", "basket-api.wildberries.kz", "basket-api.wildberries.kg", "basket-api.wildberries.am", "basket-api.wildberries.tj", "basket-api.wildberries.uz", "localhost", "webapp-*.wbx-site.k8s.dev-el", "webapp-*.wbx-site.k8s.stage-dm", "webapp-*.wbx-site.k8s.prod-el", "kg.wildberries.ru", "uz.wildberries.ru"].map((e => e.replace(/\./g, "\\.").replace(/\*/g, ".*"))).join("|"));
            var p = new class {
                async fetchJSON(e, t={}, r={}) {
                    var s;
                    let n;
                    try {
                        if (r.timeout) {
                            const e = new AbortController;
                            setTimeout(( () => e.abort()), r.timeout),
                            t.signal = e.signal
                        }
                        let s;
                        switch (n = await this.fetch(e, t),
                        this._wrapTimeout(n, r),
                        n.status) {
                        case 401:
                        case 403:
                            throw new UnauthorizeError({
                                jwtDrop: n.headers.has("X-Jwt-Drop")
                            });
                        case 404:
                            throw new NotFoundError;
                        case 204:
                        case 208:
                            s = null;
                            break;
                        default:
                            if (!n.ok) {
                                const e = new Error(`Fetch failed with status code ${n.status}`);
                                throw e.status = n.status,
                                r.keepRespData && (e.data = await n.json()),
                                e
                            }
                            s = await n.json()
                        }
                        return r.noProcessResponse || null == s ? r.includeResponse ? {
                            response: n,
                            responseData: s,
                            headers: n.headers
                        } : s : new Promise(( (e, t) => {
                            $.processResponse(s, (t => r.includeResponse ? e({
                                response: n,
                                responseData: t,
                                headers: n.headers
                            }) : e(t)), (e => t(new KnownServerError(e))), (t => r.includeResponse ? e({
                                response: n,
                                responseData: t,
                                headers: n.headers
                            }) : e(t)))
                        }
                        ))
                    } catch (a) {
                        let o = a;
                        if ("AbortError" == a.name && r.throwTimeoutError)
                            throw a;
                        const i = !a.isCustomError && a instanceof TypeError && ("Failed to fetch" === a.message || "NetworkError when attempting to fetch resource." === a.message || "Cancelled" === a.message);
                        if (i && (o = new CancelledRequestError(a.message)),
                        (i || "AbortError" == a.name) && r.tryResend)
                            return WbSpaModel.prototype.$services.retryFetchService.saveRequest(e, t, r),
                            Promise.resolve({});
                        if (r.hasOwnProperty("defaultValue"))
                            return r.includeResponse ? {
                                response: n,
                                responseData: r.defaultValue
                            } : r.defaultValue;
                        throw o.isCustomError || "AbortError" !== a.name && console.error(`Unknown server error, msg=${a.message}, requested_url=${e}`),
                        o.isUnauthorize && (o.jwtDrop && WbSpaModel.prototype.$auth.setToken(null),
                        r.redirectUnauth && wb.spa.signIn({
                            query: {
                                returnUrl: window.location.href
                            }
                        }, null != (s = r.replaceState) && s)),
                        o
                    }
                }
                async fetchBasicJSON(e, t={}, r={}) {
                    var s, n, a, o;
                    if (!t.headers && (t.headers = new Headers),
                    r.addUserHeader) {
                        const e = WbSpaModel.prototype.$user.getId();
                        e && t.headers.set("X-Userid", e)
                    }
                    r.noCache && t.headers.set("cache", "no-cache");
                    const i = WbSpaModel.prototype.$auth.jwt;
                    r.addAuthHeader && i && t.headers.set("Authorization", `Bearer ${i}`);
                    const l = null != (s = r.retry) ? s : 1;
                    let c;
                    for (let s = 1; s <= l; s++) {
                        const u = s % 2 == 0 && r.reserve ? r.reserve : e;
                        if (r.timeout)
                            if (AbortSignal.timeout && "function" == typeof AbortSignal.timeout)
                                t.signal = AbortSignal.timeout(r.timeout);
                            else {
                                const e = new AbortController;
                                setTimeout(( () => e.abort()), r.timeout),
                                t.signal = e.signal
                            }
                        try {
                            if (r.addCatalogCaptcha && (null == (n = wb.global) ? void 0 : n.settings.switches.enableCatalogCaptcha) && !i) {
                                const e = null != (a = WbSpaModel.prototype.$services.parseTokenService) ? a : await WbSpaModel.prototype.$getService("parseTokenService")
                                  , r = await e.providers.catalog.getToken();
                                r && t.headers.set("X-Captcha-ID", `Catalog ${r}`)
                            }
                            return await this.fetch(u, t).then((async e => {
                                var t, s, n;
                                if (204 === e.status)
                                    return Promise.resolve(r.return204 ? e : null);
                                if (208 === e.status)
                                    return Promise.resolve(null);
                                if (e.ok)
                                    return c = "text" === r.fetchType ? await e.text() : await e.json(),
                                    "v2" === r.v && c.error ? Promise.reject(new KnownServerError(c.error)) : c;
                                if (r.addCatalogCaptcha && (null == (t = wb.global) ? void 0 : t.settings.switches.enableCatalogCaptcha) && 498 === e.status)
                                    throw null == (s = WbSpaModel.prototype.$services.parseTokenService) || s.providers.catalog.resetToken(),
                                    new Error("Need refresh token");
                                if ("v2" === r.v)
                                    return Promise.reject(new NetworkError);
                                r.logOff || null == (n = wb.spa) || n.logError(new Error(`Failed fetch. status:${e.status}; type:${e.type}`), {
                                    url: u
                                })
                            }
                            ))
                        } catch (e) {
                            if ((e.isCustomError || e.isNetworkError) && "v2" === r.v)
                                return Promise.reject(e);
                            if (("TimeoutError" === e.name || "AbortError" === e.name) && r.throwTimeoutError)
                                throw e;
                            if (e instanceof TypeError && "Cancelled" === e.message)
                                return null;
                            if (r.logOff || null == (o = wb.spa) || o.logError(e, {
                                url: u,
                                attempt: s
                            }),
                            s === l && r.nullOnError)
                                return null;
                            if (s === l && e instanceof TypeError && ("Failed to fetch" === e.message || "NetworkError when attempting to fetch resource." === e.message))
                                throw new NetworkError
                        }
                    }
                    return null
                }
                async fetchText(e, t, r={}) {
                    var s;
                    let n;
                    if (r.timeout) {
                        const e = new AbortController;
                        setTimeout(( () => e.abort()), r.timeout),
                        t.signal = e.signal
                    }
                    try {
                        let s;
                        if (n = await this.fetch(e, t),
                        401 === n.status)
                            throw new UnauthorizeError;
                        return n.ok && (s = await n.text()),
                        this._wrapTimeout(n, r),
                        s
                    } catch (t) {
                        let n = t;
                        throw !t.isCustomError && t instanceof TypeError && ("Failed to fetch" === t.message || "NetworkError when attempting to fetch resource." === t.message || "Cancelled" === t.message) && (n = new CancelledRequestError),
                        n.isCustomError || (console.log(t.message),
                        n = new KnownServerError("Unknown server error, msg=" + t.message + ", requested_url=" + e)),
                        n.isUnauthorize && (n.jwtDrop && WbSpaModel.prototype.$auth.setToken(null),
                        r.redirectUnauth && wb.spa.signIn({
                            query: {
                                returnUrl: window.location.href
                            }
                        }, null != (s = r.replaceState) && s)),
                        n
                    }
                }
                async fetchStaticDataV2(e, t=3e4, r="json") {
                    return await this.fetchStaticV3(wb.helpers.url.urlStaticData, {
                        timeout: t,
                        fetchType: r
                    }, e)
                }
                async fetchStaticV3(e, t={}, ...r) {
                    if ("function" != typeof e)
                        return;
                    const s = Object.assign({
                        timeout: 3e4,
                        nullOnError: !0,
                        retry: 2,
                        reserve: e.apply(void 0, [...r, !0])
                    }, t);
                    return await this.fetchBasicJSON(e.apply(void 0, r), {}, s)
                }
                async fetch(e, t={}) {
                    const r = t
                      , {headers: s={}} = r
                      , n = ( (e, t) => {
                        var r = {};
                        for (var s in e)
                            i.call(e, s) && t.indexOf(s) < 0 && (r[s] = e[s]);
                        if (null != e && o)
                            for (var s of o(e))
                                t.indexOf(s) < 0 && l.call(e, s) && (r[s] = e[s]);
                        return r
                    }
                    )(r, ["headers"])
                      , a = new Headers(s)
                      , p = WbSpaModel.prototype;
                    let h = !1;
                    try {
                        const t = new URL(e.startsWith("//") ? `${document.location.protocol}${e}` : e);
                        (t.hostname === window.location.host && t.port === window.location.port || u.test(t.hostname)) && (d.test(t.hostname) && (a.set("X-Spa-Version", WbSpaModel.appVersion),
                        a.set("X-Requested-With", "XMLHttpRequest"),
                        a.set("DeviceId", p.$services.sessionService.getSession()),
                        p.$adult.isConfirmed && a.set("adultConfirmed", "1")),
                        !a.has("Authorization") && p.$auth.jwt && a.set("Authorization", `Bearer ${p.$auth.jwt}`))
                    } catch (e) {
                        h = !0,
                        a.set("X-Requested-With", "XMLHttpRequest"),
                        a.set("X-Spa-Version", WbSpaModel.appVersion),
                        a.set("DeviceId", p.$services.sessionService.getSession()),
                        !a.has("Authorization") && p.$auth.jwt && a.set("Authorization", `Bearer ${p.$auth.jwt}`),
                        p.$adult.isConfirmed && a.set("adultConfirmed", "1")
                    }
                    return t.body instanceof URLSearchParams && (a.set("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8"),
                    n.body = n.body.toString()),
                    fetch(e, ( (e, t) => {
                        for (var r in t || (t = {}))
                            i.call(t, r) && c(e, r, t[r]);
                        if (o)
                            for (var r of o(t))
                                l.call(t, r) && c(e, r, t[r]);
                        return e
                    }
                    )({
                        credentials: "same-origin",
                        headers: a
                    }, n)).then((e => {
                        var t;
                        if (h && (null == (t = null == wb ? void 0 : wb.helpers) ? void 0 : t.date)) {
                            const t = e.headers.get("Date");
                            wb.helpers.date.serverDate = new Date(t)
                        }
                        return e
                    }
                    ))
                }
                _wrapTimeout(e, t) {
                    return t && e.headers.has("X-Timeout") && (t.modified = {
                        timeout: !0
                    }),
                    t
                }
            }
            ;
            var h = new class {
                async fetch(e, t, r, s) {
                    var n;
                    const a = WbSpaModel.prototype.$auth;
                    let o = a.getToken();
                    const i = null == s ? void 0 : s(null == (n = o.data) ? void 0 : n.shard_key);
                    if (null == t ? void 0 : t.timeout) {
                        const e = new AbortController;
                        setTimeout(( () => e.abort()), t.timeout),
                        t.signal = e.signal
                    }
                    return this._fetch(`${i || ""}${e}`, t, o.token).then((async t => {
                        if (t.ok) {
                            const e = +t.headers.get("content-length");
                            if (e > 16 && e < 256) {
                                const e = await t.clone().json();
                                -1 === (null == e ? void 0 : e.state) && 41 === e.reason && a._slide(!0)
                            }
                            return t
                        }
                        function s(r, s) {
                            return wb.spa.logError({
                                message: r
                            }, {
                                status: s,
                                msg: "wbx_fetch"
                            }),
                            Promise.reject(new Error(`url:${e}, response:${r}, code:${t.status}`))
                        }
                        return 401 === t.status && a._slide(!0),
                        "function" == typeof r ? r(t, s) : t.text().then((e => s(e, t.status)))
                    }
                    ))
                }
                async postJSON(e, t, r) {
                    return this._fetchJSON(e, t, r, "POST")
                }
                async getJSON(e, t) {
                    return this._fetchJSON(e, null, t, "GET")
                }
                _fetch(e, t, r) {
                    return r ? (!t && (t = {}),
                    t.headers = Object.assign({}, t.headers, {
                        Authorization: "Bearer " + r
                    }),
                    WbSpaModel.prototype.$httpClient.fetch(e, t)) : Promise.reject("miss accessToken")
                }
                async _fetchJSON(e, t, r, s) {
                    const n = {
                        method: s
                    };
                    Object.assign(n, r),
                    n.headers = {
                        "X-Service-Name": "site"
                    },
                    t && (n.headers["Content-Type"] = "application/json",
                    n.body = t);
                    const a = await this.fetch(e, n);
                    if (a.ok)
                        return await a.json()
                }
            }
              , m = r(33036);
            const g = "wbx__tokenData"
              , y = "v2"
              , b = `/${y}/auth/slide-v3`
              , f = `/${y}/auth/slide-v3-confirm`
              , v = `/${y}/auth/logoff`;
            var w = new class {
                constructor() {
                    this._pull(),
                    window.addEventListener("storage", (e => {
                        e.key === g && this._pull()
                    }
                    ))
                }
                get AUTH_HOST() {
                    let e = wb.settings.currentDomain;
                    return "kz" === e && (e = "ru"),
                    m.R0 + e
                }
                get isAuth() {
                    return !!this._data.token
                }
                get jwt() {
                    return this._data.token
                }
                get jwtData() {
                    return this._data.data
                }
                get isUserGuid() {
                    var e;
                    return isNaN(null == (e = this.jwtData) ? void 0 : e.user)
                }
                get um() {
                    return this._data.um
                }
                get shard() {
                    var e;
                    return Number(null == (e = this.jwtData) ? void 0 : e.shard_key) || 1
                }
                get sShard() {
                    return $.views.converters.leadZero(this.shard, 2)
                }
                getToken() {
                    if (this.jwt)
                        if (this.isWbxSite)
                            this._slide(!1, !0);
                        else {
                            this._isJwtExpired(this.jwtData) && this._slide()
                        }
                    return this._data
                }
                setToken(e) {
                    try {
                        if (e) {
                            const t = this._tryDecodeJwt(e);
                            if (t) {
                                this._data = {
                                    token: e,
                                    data: t,
                                    um: this._createUm(t)
                                };
                                try {
                                    localStorage.putObject(g, {
                                        token: e
                                    })
                                } catch (e) {}
                                return
                            }
                        }
                        this._data = {
                            token: null,
                            data: {},
                            um: this._createUm()
                        },
                        localStorage.removeItem(g)
                    } catch (e) {} finally {
                        this._jwtUpdateResp = null
                    }
                }
                async signOut(e) {
                    if (!this.isAuth)
                        return;
                    const t = new AbortController;
                    setTimeout(( () => t.abort()), 2e3),
                    await this._fetch(v, {
                        method: "POST",
                        credentials: "include",
                        signal: t.signal,
                        headers: {
                            deviceid: WbSpaModel.prototype.$services.sessionService.getSession(),
                            "wb-apptype": "web",
                            "wb-appversion": WbSpaModel.appVersion
                        }
                    }).catch((e => Promise.resolve({
                        isNetworkError: !0
                    }))),
                    this.signOutOld(e),
                    this.setToken(null)
                }
                async signOutOld(e) {
                    return WbSpaModel.prototype.$httpClient.fetchJSON(`/webapi/security/exit?returnUrl=${encodeURIComponent(e || "")}`, {
                        method: "POST"
                    })
                }
                _pull() {
                    var e;
                    const t = null == (e = localStorage.getObject(g)) ? void 0 : e.token
                      , r = this._tryDecodeJwt(t);
                    this._data = r ? {
                        token: t,
                        data: r,
                        um: this._createUm(r)
                    } : {
                        token: null,
                        data: {},
                        um: this._createUm(r)
                    }
                }
                _isJwtExpired(e) {
                    return Date.now() >= 1e3 * (e.iat + 172800)
                }
                _isJwtShortExpired(e) {
                    return Date.now() >= 1e3 * (e.iat + 120)
                }
                _slide(e, t) {
                    try {
                        return this._slideToken(e, t)
                    } catch (e) {
                        wb.spa.logError(e, {
                            msg: "wbx_auth_slide"
                        })
                    }
                }
                _createUm(e) {
                    let t = null == e ? void 0 : e.user;
                    if (t) {
                        t = `user:${t}`;
                        const e = [];
                        for (let r = 0; r < t.length; r++)
                            e.push(129 ^ t.charCodeAt(r));
                        return {
                            userUid: btoa(String.fromCodePoint(...(new TextEncoder).encode(String.fromCharCode.apply(null, e)))),
                            userId: t
                        }
                    }
                    return {
                        userUid: "",
                        userId: ""
                    }
                }
                _tryDecodeJwt(e) {
                    try {
                        if (!e)
                            return null;
                        const [t,r,s] = e.split(".");
                        if (!(t || r || s))
                            return null;
                        const n = atob(r);
                        return n ? JSON.parse(n) || {} : null
                    } catch (e) {
                        return console.error(e),
                        null
                    }
                }
                get isWbxSite() {
                    return localStorage.hasItem("wbx__exchangeRates")
                }
                slideRefreshCookie() {
                    return WbSpaModel.prototype.$httpClient.fetchBasicJSON("v2/auth/sliderefresh", {
                        method: "POST",
                        credentials: "include"
                    })
                }
                delRefreshCookie() {
                    return WbSpaModel.prototype.$httpClient.fetch("v2/auth/delrefresh", {
                        method: "POST",
                        credentials: "include"
                    }).catch(( () => {}
                    ))
                }
                _fetch(e, t) {
                    return WbSpaModel.prototype.$httpClient.fetch(this.AUTH_HOST + e, t)
                }
                async _slideToken(e, t) {
                    navigator.locks.request("lock-auth-slide", (async r => {
                        var s;
                        if (!this.jwt)
                            return;
                        if (t && this.isWbxSite && this._isJwtShortExpired(this.jwtData)) {
                            const t = await this.slideRefreshCookie().catch(( () => {}
                            ));
                            0 === (null == t ? void 0 : t.ResultState) ? e = !0 : -1 === (null == t ? void 0 : t.ResultState) && localStorage.removeItem("wbx__exchangeRates")
                        }
                        if (e && !this._isJwtShortExpired(this.jwtData))
                            return;
                        if (!e && !this._isJwtExpired(this.jwtData))
                            return;
                        const n = new AbortController;
                        setTimeout(( () => n.abort()), 1e4);
                        const a = WbSpaModel.prototype.$services.sessionService.getSession()
                          , o = await this._fetch(b, {
                            method: "POST",
                            credentials: "include",
                            signal: n.signal,
                            headers: {
                                deviceid: a,
                                "wb-apptype": "web",
                                "wb-appversion": WbSpaModel.appVersion
                            }
                        }).then((e => e.ok ? e.json() : {})).then((e => (e.error && wb.spa.logError(new Error(`[wbx_auth_slide]: res: ${e.result}, error: ${e.error}`)),
                        e))).catch(( () => ({})));
                        if (t && (await this.delRefreshCookie(),
                        localStorage.removeItem("wbx__exchangeRates")),
                        12 !== o.result) {
                            if (0 === o.result && (null == (s = o.payload) ? void 0 : s.sticker) && o.payload.access_token) {
                                const e = JSON.stringify({
                                    sticker: o.payload.sticker
                                })
                                  , t = await this._fetch(f, {
                                    method: "POST",
                                    credentials: "include",
                                    signal: n.signal,
                                    headers: {
                                        deviceid: a,
                                        "wb-apptype": "web",
                                        "wb-appversion": WbSpaModel.appVersion
                                    },
                                    body: e
                                }).then((e => e.ok ? e.json() : {})).then((e => (e.error && wb.spa.logError(new Error(`[wbx_auth_slide_confirm]: res: ${e.result}, error: ${e.error}`)),
                                e))).catch(( () => ({})));
                                12 === t.result ? this.setToken(null) : 0 === t.result && this.setToken(o.payload.access_token)
                            }
                        } else
                            this.setToken(null)
                    }
                    ))
                }
                sendMetrics(e, t) {
                    if (!window._debug)
                        try {
                            WbSpaModel.prototype.$httpClient.fetch(`/webapi/logging/wbxauth/metrics?act=${e}&status=${t}`, {
                                method: "POST"
                            })
                        } catch (e) {}
                }
            }
              , S = r(71595);
            var _ = class {
                constructor() {
                    this.allModules = {},
                    this.modulesDict = {},
                    this.allServices = {},
                    this.servicesDict = {},
                    this.loadingServices = {}
                }
                init() {
                    return window.__spaModuleManager__ = {
                        register: (e, t) => {
                            this._enrichProto(t),
                            this.modulesDict[e] = t
                        }
                        ,
                        getModule: (e, t) => {
                            if (null != this.modulesDict[e] || t)
                                return this.modulesDict[e];
                            throw new Error("Module " + e + " has not been loaded yet")
                        }
                    },
                    window.__spaServiceManager__ = {
                        register: (e, t) => {
                            this._enrichProto(t),
                            this.servicesDict[e] = t
                        }
                        ,
                        getService: (e, t) => {
                            if (null != this.servicesDict[e] || t)
                                return this.servicesDict[e];
                            throw new Error("Service " + e + " has not been loaded yet")
                        }
                    },
                    this
                }
                setModules(e) {
                    this.allModules = e
                }
                setServices(e) {
                    this.allServices = e
                }
                async loadServiceAsync(e) {
                    const {physicalPath: t} = this.allServices[e] || {};
                    if (null == t)
                        throw new Error(e + " service doesnt exist");
                    const r = await this._loadServiceAsync(e, t);
                    this.$services[e] = new r
                }
                async loadServiceAsSingletonAsync(e) {
                    const {physicalPath: t} = this.allServices[e] || {};
                    if (null == t)
                        throw new Error(e + " service doesnt exist");
                    return this.loadingServices[e] || (this.loadingServices[e] = this._loadServiceAsync(e, t).then((t => (this.$services[e] = new t,
                    this.$services[e])))),
                    this.loadingServices[e]
                }
                async loadModuleAsync(e, t=!1) {
                    let {physicalPath: r, dataPath: s, hasTmpl: n, tmpls: a=[], templateId: o, isDynamic: i=!1, httpMethod: l="GET", cssPaths: c, jsPaths: u, apiName: d} = this.allModules[e] || {};
                    if (null == r)
                        throw new Error(e + " module doesnt exist");
                    const p = a.map((e => this._loadTemplateAsync(e)))
                      , h = this._loadTemplateAsync(n ? e : null, o)
                      , m = this._loadDataAsync(e, s, i, l, d)
                      , g = null == c ? [Promise.resolve(null)] : c.map((e => this.$helper.loadCssAsync(e)))
                      , y = null == u ? [Promise.resolve(null)] : u.map((e => this.$helper.loadJsAsync(e)))
                      , [b,f,v] = await Promise.all([this._loadModule(e, r, t), m, h, ...p, ...g, ...y]);
                    return null != b && (b.data = f,
                    b.template = v),
                    b
                }
                async execModule(e="", t="", r=[]) {
                    try {
                        (await this.loadModuleAsync(e))[t](...r)
                    } catch (e) {
                        console.error(e)
                    }
                }
                async _loadModule(e, t, r) {
                    if (null == e || null == t)
                        throw new Error("path and name are required to load module");
                    return await this.$helper.loadJsAsync(t),
                    window.__spaModuleManager__.getModule(e, r)
                }
                async _loadServiceAsync(e, t) {
                    if (null == e || null == t)
                        throw new Error("path and name are required to load service");
                    return await this.$helper.loadJsAsync(t),
                    window.__spaServiceManager__.getService(e)
                }
                async _loadDataAsync(e, t, r, s, n) {
                    return null == t ? null : r || null == this.modulesDict[e] || this.modulesDict[e].isNetworkError ? ("basket" === n && (t = `${this.$services.cartService.publicBasketApiUrl}${t}`),
                    await this.$httpClient.fetchJSON(t, {
                        method: s || "GET",
                        credentials: "include"
                    }, {
                        defaultValue: {
                            isNetworkError: !0
                        }
                    })) : this.modulesDict[e].data
                }
                async _loadTemplateAsync(e, t, r) {
                    return null == e && null == t ? Promise.resolve(null) : t ? $.views.loadWebApiTemplateAsync(t, r) : $.views.loadTemplateAsync(e, r)
                }
                _enrichProto(e) {
                    if (!e.prototype)
                        return;
                    let t = e.prototype
                      , r = null;
                    for (; (r = Object.getPrototypeOf(t)) && r != Object.prototype; )
                        t = r;
                    t != WbSpaModel.prototype && Object.setPrototypeOf(t, WbSpaModel.prototype)
                }
            }
            ;
            var C = class {
                constructor() {
                    this.proceedIfAdultConfirmed = this.proceedIfAdultConfirmed.bind(this)
                }
                get isConfirmed() {
                    if (null == this._isConfirmed) {
                        const e = localStorage.getObject("__ac");
                        e && e.dtExp > Date.utcNow() ? this._isConfirmed = e.state : this._isConfirmed = !1
                    }
                    return this._isConfirmed
                }
                set isConfirmed(e) {
                    this._isConfirmed = e;
                    try {
                        localStorage.putObject("__ac", {
                            dtExp: Date.utcNow() + 36e5,
                            state: e
                        })
                    } catch (e) {}
                    return e
                }
                get adultPopup() {
                    return this._adultPopup ? Promise.resolve(this._adultPopup) : new Promise((e => {
                        WbSpaModel.prototype.$moduleLoader.loadModuleAsync("adultConfirmedPopup").then((t => {
                            this._adultPopup = new t,
                            e(this._adultPopup)
                        }
                        ))
                    }
                    ))
                }
                proceedIfAdultConfirmed(e, t, r, ...s) {
                    this.adultPopup.then((n => {
                        n.closePopup(),
                        !e || this.isConfirmed ? null == t || t.apply(r, s) : n.proceedIfAdultConfirmed(t, r, s).then((e => {
                            $.observable(this).setProperty({
                                isConfirmed: e
                            })
                        }
                        ))
                    }
                    ))
                }
                pushToQueue(e) {
                    this.adultPopup.then((t => t.pushToQueue(e)))
                }
                closePopup() {
                    this.adultPopup.then((e => e.closePopup()))
                }
            }
            ;
            var I = class {
                getVerticalObserver(e, t, r) {
                    return new M(e,t,r)
                }
                getCarouselBannersObserver(e, t, r) {
                    const s = Object.assign({
                        keepObserve: !0,
                        sendOutEvent: !0
                    }, null != r ? r : {});
                    return new M(e,t,s)
                }
                getSimpleObserver(e, t, r) {
                    if (WbSpaModel.prototype.$apiSupport.intersectionObserver) {
                        let s = function() {
                            u.forEach((e => d.unobserve(e))),
                            u = []
                        }
                          , n = function() {
                            null == d || d.disconnect()
                        }
                          , a = function(e) {
                            s(),
                            u = e,
                            u.forEach((e => d.observe(e)))
                        };
                        const o = {
                            threshold: .5
                        }
                          , i = Object.assign(o, null != t ? t : {})
                          , l = {
                            keepObserve: !1
                        }
                          , c = Object.assign(l, null != r ? r : {});
                        let u = [];
                        const d = new IntersectionObserver(( (t, r) => {
                            t.forEach((t => {
                                t.isIntersecting && (e(t.target, u.indexOf(t.target) + 1),
                                c.keepObserve || r.unobserve(t.target))
                            }
                            ))
                        }
                        ),i);
                        return {
                            observe: a,
                            destroy: n
                        }
                    }
                    return {
                        observe: t => t.forEach((r => e(r, t.indexOf(r) + 1))),
                        destroy: () => {}
                    }
                }
            }
            ;
            class M {
                constructor(e, t, r) {
                    this.intersectionObserverEnable = WbSpaModel.prototype.$apiSupport.intersectionObserver,
                    e = null != e ? e : [],
                    this.items = (Array.isArray(e) ? e : [e]).toHashSet(),
                    this.options = null != t ? t : {};
                    this.settings = Object.assign({
                        keepObserve: !1,
                        sendOutEvent: !1
                    }, null != r ? r : {}),
                    this.observer = null,
                    this.elementInViewportEventName = "elementInViewportEvent",
                    this.elementOutOfViewportEventName = "elementOutOfViewportEvent"
                }
                _observe(e) {
                    var t, r;
                    const s = {
                        bubbles: !0
                    };
                    (null == (t = this.settings) ? void 0 : t.eventDetails) && (s.detail = this.settings.eventDetails);
                    let n = new CustomEvent(this.elementInViewportEventName,s)
                      , a = new CustomEvent(this.elementOutOfViewportEventName,s);
                    this.intersectionObserverEnable ? (this.observer = null != (r = this.observer) ? r : new IntersectionObserver(( (e, t) => {
                        e.forEach((e => {
                            e.isIntersecting ? (e.target.dispatchEvent(n),
                            this.settings.keepObserve || (this.items.delete(e.target),
                            t.unobserve(e.target))) : !e.isIntersecting && this.settings.sendOutEvent && e.target.dispatchEvent(a)
                        }
                        ))
                    }
                    ),this.options),
                    e.forEach((e => {
                        e && this.observer.observe(e)
                    }
                    ))) : e.forEach((e => {
                        e.dispatchEvent(n),
                        this.items.delete(e)
                    }
                    ))
                }
                observe() {
                    return this._observe(this.items),
                    this
                }
                update(e) {
                    let t;
                    if (Array.isArray(e))
                        t = e;
                    else if (e instanceof HTMLElement)
                        t = [e];
                    else {
                        if (!("toArray"in e))
                            return;
                        t = e.toArray()
                    }
                    this._observe(t)
                }
                unobserve(e) {
                    e && this.intersectionObserverEnable && this.observer.unobserve(e)
                }
                unobserveAll() {
                    this.items.forEach((e => this.observer.unobserve(e))),
                    this.items.clear()
                }
                destroy() {
                    var e;
                    this.items.clear(),
                    null == (e = this.observer) || e.disconnect()
                }
            }
            let k = null;
            var P = class {
                constructor() {
                    this.productCardPopup = null,
                    this.processing = !1,
                    this.currentData = null,
                    this.targetData = null,
                    this.onPopupShow = this.onPopupShow.bind(this)
                }
                async showSlider(e, t, r) {
                    if (!this.$isDesktop)
                        return void this.$router.moveTo($.views.converters.urlForGood(e.cod1S, !0, e.newTargetUrl, null, !1, e.chrtId));
                    const {observeDisplayMode: s, removeObserver: n} = this._createObservable();
                    wb.displayModeSettings.addObserver(s),
                    e.onHideCallback = n;
                    if (await this._processingPopup(e.cod1S, e.chrtId, e.newTargetUrl, r))
                        try {
                            await k.showSlider(e, t, r)
                        } catch (e) {
                            this._onShowError(n)
                        } finally {
                            this.onPopupShow()
                        }
                }
                async show(e, t, r, s, n) {
                    if (!this.$isDesktop)
                        return s && this.$analitic.updateState(s),
                        void this.$router.moveTo($.views.converters.urlForGood(e, !0, r, null, !1, t));
                    const {observeDisplayMode: a, removeObserver: o} = this._createObservable();
                    wb.displayModeSettings.addObserver(a);
                    if (await this._processingPopup(e, t, r, null))
                        try {
                            await k.show(e, t, r, s, o, n)
                        } catch (e) {
                            this._onShowError(o)
                        } finally {
                            this.onPopupShow()
                        }
                }
                async onPopupShow() {
                    this.processing = !1,
                    this.currentData = null,
                    this.targetData = null
                }
                async _processingPopup(e, t, r, s) {
                    var n;
                    return this.processing ? (e != (null == (n = this.currentData) ? void 0 : n.cod1S) && (this.targetData = {
                        cod1S: e,
                        chrtId: t,
                        newTargetUrl: r,
                        cardIndex: s
                    }),
                    !1) : (this.processing = !0,
                    this.currentData = {
                        cod1S: e,
                        chrtId: t,
                        newTargetUrl: r,
                        cardIndex: s
                    },
                    await this._loadProductCardPopup(),
                    !0)
                }
                async _loadProductCardPopup() {
                    if (this.productCardPopup)
                        return;
                    const e = await this.$moduleLoader.loadModuleAsync("productCardPopup");
                    k = e;
                    window.addEventListener("spaTransition", ( () => {
                        this.processing = !1,
                        this.currentData = null,
                        this.targetData = null
                    }
                    ).bind(this))
                }
                _createObservable() {
                    const e = () => wb.displayModeSettings.removeObserver(t)
                      , t = () => {
                        var t;
                        null == (t = this.productCardPopup) || t.hidePopup(),
                        e()
                    }
                    ;
                    return {
                        observeDisplayMode: t,
                        removeObserver: e
                    }
                }
                _onShowError(e) {
                    navigator.onLine || wb.popup.renderModalError("Internet connection is lost"),
                    null == e || e(),
                    this.processing = !1,
                    this.currentData = null,
                    this.targetData = null
                }
            }
            ;
            var T = new class {
                constructor() {
                    this.eventsDictionary = {}
                }
                addEventListener(e, t, {single: r}={}) {
                    const s = this._validateInput(e, t);
                    if (!s.valid)
                        throw s.error;
                    null == this.eventsDictionary[e] && (this.eventsDictionary[e] = []);
                    const n = this.eventsDictionary[e];
                    r && n.includes(t) || n.push(t)
                }
                removeEventListener(e, t) {
                    var r;
                    const s = this._validateInput(e, t);
                    if (!s.valid)
                        throw s.error;
                    const n = this.eventsDictionary[e];
                    this.eventsDictionary[e] = null != (r = null == n ? void 0 : n.filter((e => e !== t))) ? r : []
                }
                dispatchEvent(e) {
                    if (!(e instanceof Event))
                        throw new TypeError("DispatchEvent can be called only with Event instance");
                    if ("" == e.type)
                        throw new TypeError("Event doesnt have sufficient type");
                    const t = this.eventsDictionary[e.type];
                    null == t || t.forEach((t => {
                        e.isPropagationStopped || queueMicrotask(( () => {
                            t(e)
                        }
                        ))
                    }
                    ))
                }
                _validateInput(e, t) {
                    return "string" != typeof e || "" == e ? {
                        valid: !1,
                        error: new TypeError("Event type must be a valid string value")
                    } : t instanceof Function ? {
                        valid: !0
                    } : {
                        valid: !1,
                        error: new TypeError("Callback must be a function")
                    }
                }
            }
            ;
            var A = new class {
                constructor() {
                    this.items = [],
                    this.requestUrl = ""
                }
                init(e, t, r) {
                    this.requestUrl = t,
                    this.items = e.map((e => {
                        var t;
                        try {
                            return document.querySelector(`${e.tagName}${Object.keys(null != (t = e.attributesDictionary) ? t : {}).map((t => `[${t}='${e.attributesDictionary[t].replace(/[\n\r]/g, "").replace(/["']/g, "\\$&")}']`)).join("")}`)
                        } catch (e) {
                            return console.error(e.message),
                            null
                        }
                    }
                    )),
                    this.defaultTitle = r
                }
                async update(e, t=null) {
                    return this._loadMetaTags(null != t ? t : this.requestUrl, e).then((e => {
                        if (this.delete(),
                        (null != e ? e : []).length > 0)
                            return this._renderMetatags(e),
                            e;
                        this._renderDefaultTitle()
                    }
                    )).catch(( () => {}
                    ))
                }
                render(e) {
                    this.delete(),
                    (null != e ? e : []).length > 0 ? this._renderMetatags(e) : this._renderDefaultTitle()
                }
                async loadMetaTags(e, t) {
                    if (e.metaTags)
                        return this.render(e.metaTags);
                    const r = await this.update(window.location.pathname, WbSpaModel.prototype.$router.currentRoute.metaTagsUrl);
                    if (!r)
                        return;
                    const s = r.find((e => "H1" === e.tagName));
                    if (s && window.requestAnimationFrame(( () => $.observable(e).setProperty({
                        title: s.hTMLContent
                    }))),
                    t) {
                        const t = r.find((e => "bottomText" === e.tagName));
                        t && window.requestAnimationFrame(( () => $.observable(e).setProperty({
                            bottomText: t.hTMLContent
                        })))
                    }
                }
                delete() {
                    this.items.forEach((e => null == e ? void 0 : e.remove())),
                    this.items.length = 0
                }
                _loadMetaTags(e, t) {
                    if (!e)
                        return Promise.resolve();
                    const r = new URLSearchParams(this.$router.queryParams);
                    let s;
                    return r.append("targetUrl", encodeURIComponent(("/" === t[0] ? "" : "/") + t)),
                    e.indexOf("{*category}") > -1 && (e = e.replace("{*category}", this.$router.routeParameters.category)),
                    e.indexOf("{brandBasePath}") > -1 && "/" === (e = e.replace("{brandBasePath}", this.$router.routeParameters.brandBasePath))[e.length - 1] && (e = e.slice(0, -1)),
                    e.indexOf("{promoBasePath}") > -1 && "/" === (e = e.replace("{promoBasePath}", this.$router.routeParameters.promoBasePath))[e.length - 1] && (e = e.slice(0, -1)),
                    s = e,
                    this.$httpClient.fetchJSON(s + "?" + r).then((e => Promise.resolve(null == e ? void 0 : e.metaTags))).catch((r => (r.isCancelled || "" === r.message || (console.error(r.message),
                    console.error(`Error loading meta tags for path ${t} by requesting ${e}`)),
                    Promise.resolve())))
                }
                _renderMetatags(e) {
                    const t = document.createDocumentFragment();
                    e.forEach((e => {
                        var r;
                        if ("H1" === e.tagName)
                            return;
                        if ("bottomText" === e.tagName)
                            return;
                        const s = document.createElement(e.tagName);
                        Object.keys(null != (r = e.attributesDictionary) ? r : {}).forEach((t => s.setAttribute(t, e.attributesDictionary[t]))),
                        (e.hTMLContent || e.htmlContent) && (s.innerHTML = e.hTMLContent || e.htmlContent),
                        this.items.push(s),
                        t.appendChild(s)
                    }
                    )),
                    document.head.appendChild(t)
                }
                _renderDefaultTitle() {
                    const e = document.createElement("title");
                    e.innerHTML = this.defaultTitle,
                    this.items.push(e),
                    document.head.appendChild(e)
                }
            }
              , D = {
                updateVerificationToken(e) {
                    const t = document.querySelector("input[name=__RequestVerificationToken]");
                    t && (t.value = e)
                }
            }
              , E = Object.defineProperty
              , B = Object.getOwnPropertySymbols
              , O = Object.prototype.hasOwnProperty
              , x = Object.prototype.propertyIsEnumerable
              , L = (e, t, r) => t in e ? E(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }) : e[t] = r
              , F = (e, t) => {
                for (var r in t || (t = {}))
                    O.call(t, r) && L(e, r, t[r]);
                if (B)
                    for (var r of B(t))
                        x.call(t, r) && L(e, r, t[r]);
                return e
            }
            ;
            const W = {
                short: 9e5,
                halfHour: 18e5,
                normal: 36e5
            };
            Object.freeze(W);
            class j {
                static createStorageHelperItem(e, t, r) {
                    return new N(e,t,r)
                }
                static get cacheActivityType() {
                    return W
                }
                static supportIndexedDb() {
                    return null != window.indexedDB
                }
                static metadataTableName(e) {
                    return e + "_metadata"
                }
                static openDb(e, t={}) {
                    return new Promise(( (r, s) => {
                        var n;
                        const a = indexedDB.open(e, null != (n = null == t ? void 0 : t.version) ? n : 1);
                        a.onupgradeneeded = e => {
                            var r;
                            null == (r = t.onupgradeneeded) || r.call(t, e.target.result)
                        }
                        ,
                        a.onsuccess = e => {
                            r(e.target.result)
                        }
                        ,
                        a.onerror = t => {
                            s(new Error(`[StorageHelper]: Database cannot be opened db_name=${e} error=${a.error}`))
                        }
                    }
                    ))
                }
                static setItem(e, t, r) {
                    return new Promise(( (s, n) => {
                        const a = e.transaction([t], "readwrite").objectStore(t).put(r);
                        a.onsuccess = s,
                        a.onerror = e => {
                            console.error(e.message),
                            n("Error while setting item from indexedDb")
                        }
                    }
                    ))
                }
                static addItem(e, t, r, s) {
                    return new Promise(( (n, a) => {
                        const o = e.transaction([t], "readwrite").objectStore(t).add(r);
                        o.onsuccess = e => n(e.target.result),
                        o.onerror = e => {
                            !s && console.error(e.message),
                            a("Error while setting item from indexedDb")
                        }
                    }
                    ))
                }
                static setItems(e, t, r, s) {
                    return new Promise(( (n, a) => {
                        let o = e.transaction([t], "readwrite")
                          , i = o.objectStore(t);
                        i.clear(),
                        s.forEach((e => {
                            e.__expiredAt__ = r,
                            i.add(e)
                        }
                        )),
                        o.oncomplete = n,
                        o.onerror = e => {
                            console.error(e.message),
                            a("Error while setting item from indexedDb")
                        }
                    }
                    ))
                }
                static getAll(e, t) {
                    return new Promise(( (r, s) => {
                        const n = e.transaction([t]).objectStore(t).getAll();
                        n.onsuccess = e => r(e.target.result),
                        n.onerror = () => s("Error while getting item from indexedDb")
                    }
                    ))
                }
                static get(e, t, r) {
                    return new Promise(( (s, n) => {
                        const a = e.transaction([t]).objectStore(t).get(r);
                        a.onsuccess = e => s(e.target.result),
                        a.onerror = () => n("Error while getting item from indexedDb")
                    }
                    ))
                }
                static getItem(e, t, r) {
                    return new Promise(( (s, n) => {
                        const a = e.transaction([t]).objectStore(t).get(r);
                        a.onsuccess = n => {
                            const a = n.target.result;
                            return a && a.__expiredAt__ <= Date.now() ? (j.removeItem(e, t, r),
                            s(null)) : s(n.target.result)
                        }
                        ,
                        a.onerror = () => n("Error while getting item from indexedDb")
                    }
                    ))
                }
                static removeItem(e, t, r) {
                    return new Promise(( (s, n) => {
                        const a = e.transaction([t], "readwrite").objectStore(t).delete(r);
                        a.onsuccess = s,
                        a.onerror = () => n("Error while removing item from indexedDb")
                    }
                    ))
                }
                static updateItem(e, t, r, s) {
                    return new Promise(( (n, a) => {
                        const o = e.transaction([t], "readwrite").objectStore(t).put(r, s);
                        o.onsuccess = n,
                        o.onerror = e => {
                            console.error(e.message),
                            a("Error while updating item in indexedDb")
                        }
                    }
                    ))
                }
                static clear(e, t) {
                    return new Promise(( (r, s) => {
                        const n = e.transaction([t], "readwrite").objectStore(t).clear();
                        n.onsuccess = r,
                        n.onerror = () => s("Error while removing item from indexedDb")
                    }
                    ))
                }
                static removeDb(e) {
                    return new Promise(( (t, r) => {
                        const s = indexedDB.deleteDatabase(e);
                        s.onsuccess = t,
                        s.onerror = () => r("Error while removing database")
                    }
                    ))
                }
                static exec(e, t, r) {
                    if ("function" == typeof r)
                        return new Promise(( (s, n) => {
                            const a = e.transaction([t]).objectStore(t)
                              , o = r(a);
                            o.onsuccess = e => s(e.target.result),
                            o.onerror = () => n("Error while getting item from indexedDb")
                        }
                        ))
                }
                static withCursor(e, t, r, s) {
                    return new Promise(( (n, a) => {
                        let o = e.transaction([t], "readwrite").objectStore(t);
                        r && (o = o.index(r));
                        const i = o.openCursor();
                        i.onsuccess = e => {
                            const t = e.target.result;
                            t ? (s(t.key, t.value, t),
                            t.continue()) : n()
                        }
                        ,
                        i.onerror = () => a("Error while getting item from indexedDb")
                    }
                    ))
                }
                static objectStorePromise(e, t, r) {
                    return new Promise(( (s, n) => {
                        const a = e.objectStore(t)
                          , o = r(a);
                        o.onsuccess = e => s(e.target.result),
                        o.onerror = () => n("Error while work on objectStore from indexedDb")
                    }
                    ))
                }
                static withTransaction(e, t, r) {
                    return new Promise(( (s, n) => {
                        const a = e.transaction(t, "readwrite");
                        r(a).then((e => {}
                        )),
                        a.onsuccess = s(a),
                        a.onerror = () => n("Error while open transaction in indexedDb on :" + t.join(","))
                    }
                    ))
                }
            }
            class N {
                constructor(e, t, r=1) {
                    if (null == e || "" == e)
                        throw new Error("creating database without name is impossible");
                    this.databaseName = e,
                    this.databaseVersion = r,
                    this.onupgradeneeded = t
                }
                updateCacheAsync(e, t, r, s, n) {
                    return n = F(F({}, {
                        saveAllDb: !1,
                        getResultFunc: e => e
                    }), n),
                    j.supportIndexedDb() ? this._getItemFromDb(e, t, r, s, n) : this._getItemFromLocalStorage(e, t, r, s, n)
                }
                _getItemFromDb(e, t, r, s, n) {
                    let a;
                    return j.openDb(this.databaseName, {
                        version: this.databaseVersion,
                        onupgradeneeded: this.onupgradeneeded
                    }).then((r => (a = r,
                    j.getItem(a, e, t)))).then((t => null != t ? Promise.resolve(t) : s().then((t => {
                        null != t && (n.saveAllDb ? j.setItems(a, e, Date.now() + r, t) : j.setItem(a, e, F({
                            __expiredAt__: Date.now() + r
                        }, t)));
                        const s = n.getResultFunc(t);
                        return Promise.resolve(s)
                    }
                    ))))
                }
                _getItemFromLocalStorage(e, t, r, s, n) {
                    const a = n.saveAllDb ? `${this.databaseName};${this.databaseVersion};${e}` : `${this.databaseName};${this.databaseVersion};${e};${t}`
                      , o = localStorage.getItem(a)
                      , i = o ? JSON.parse(o) : null;
                    if ((null == i ? void 0 : i.__expiredAt__) >= Date.now() && (!n.saveAllDb || !!i.items.length)) {
                        const e = n.getResultFunc(n.saveAllDb ? i.items : i);
                        return Promise.resolve(e)
                    }
                    return s().then((e => {
                        const t = n.saveAllDb ? {
                            items: e
                        } : e;
                        return t.__expiredAt__ = Date.now() + r,
                        localStorage.setItem(a, JSON.stringify(t)),
                        Promise.resolve(n.getResultFunc(e))
                    }
                    ))
                }
            }
            var R = j
              , U = r(10003);
            var H = class {
                constructor() {
                    this.$eventBus.addEventListener("CurrencyChanged", this._onChangeCurrency.bind(this))
                }
                async initPreferredLocation() {
                    await this.updateLocation();
                    document.querySelectorAll(".j-geocity-link").forEach((e => {
                        e.addEventListener("click", this.doOnGeoBtnClick.bind(this))
                    }
                    ))
                }
                async updateLocation() {
                    this.location = await this.$user.getLocationData(),
                    this.setCityName(this.location.address)
                }
                setCityName(e) {
                    const t = document.querySelectorAll(".j-geocity-link")
                      , r = decodeURI(e);
                    t.forEach((e => {
                        e.textContent !== r && (e.textContent = r)
                    }
                    ))
                }
                doOnGeoBtnClick(e) {
                    const t = e.currentTarget;
                    e.preventDefault(),
                    t.classList.contains("_click") || (t.classList.add("_click"),
                    this.openDeliveryPointsPopup().then((e => t.classList.remove("_click"))))
                }
                findCurrentAddress(e, t=!1) {
                    return this.location ? null == e ? void 0 : e.find((e => e.lat == this.location.latitude && e.lon == this.location.longitude && (e.address == this.location.address || !t))) : null
                }
                async openDeliveryPointsPopup(e) {
                    const t = await this.$moduleLoader.loadModuleAsync("deliveryPointsChoosePopup");
                    this.dpPopup || (this.dpPopup = new t),
                    await this.dpPopup.init({
                        source: "geo",
                        selectAddress: (e, t, r, s) => {
                            const n = r || this.$services.userAddressService.get(t, e);
                            this._submitGeo(n, s)
                        }
                        ,
                        updateSelectedAddresses: t => {
                            const r = this.findCurrentAddress(t.courier.list, !0)
                              , s = this.findCurrentAddress(t.self.list);
                            t.courier.selected = null == r ? void 0 : r.addressId,
                            t.self.selected = null == s ? void 0 : s.addressId,
                            t.preferred = "courier" === e || "self" === e ? e : r ? "courier" : "self",
                            wb.settings.b2bMode && (t.preferred = "self",
                            t.source = "basketB2B",
                            t.courier.selected = void 0)
                        }
                        ,
                        beforeSelectDw: (e, t) => {
                            if ("self" == $.view(e.target).ctxPrm("selectedDeliveryWay"))
                                return;
                            if (this.dpPopup.deliveryWays.length < 2)
                                return;
                            "self" === $.view(e.target).data.code && this.$moduleLoader.loadModuleAsync("basketProductModel").then((t => {
                                var r;
                                const s = (null == (r = this.$services.cartService.get(!0).basketItems) ? void 0 : r.map((e => new t(e))).filter((e => e.onlyCourier))) || [];
                                s.length > 0 && (e.preventDefault(),
                                this.$moduleLoader.loadModuleAsync("productCourierOnlyPopup").then((e => {
                                    var t;
                                    e.show(e.template, s, null == (t = this.dpPopup.selectedAddresses) ? void 0 : t.preferred, this.openDeliveryPointsPopup.bind(this))
                                }
                                )),
                                this.dpPopup.close())
                            }
                            ))
                        }
                    }),
                    this.dpPopup.show()
                }
                _onChangeCurrency() {
                    var e;
                    "SpaBasketEntrypoint" !== (null == (e = this.$router.currentRoute) ? void 0 : e.name) && this.$services.cartService.localBasket.enrichProductsIfNeedAsync({
                        force: !0
                    })
                }
                _submitGeo(e, t) {
                    var r;
                    let s, n = this.map;
                    if (((null == e ? void 0 : e.id) || (null == e ? void 0 : e.addressId)) && (s = e),
                    s || (s = (null == n ? void 0 : n.selectedPointId) ? ("courier" === n.deliveryType ? n.courierList : n.visiblePoints).find((e => e.id === n.selectedPointId)) : n.selectedPoint),
                    !s)
                        return;
                    const a = s.id || s.addressId || (null == n ? void 0 : n.selectedPointId);
                    this.saveLastAddressAsync(a, s.deliveryType, e.address, t, null != (r = s.officeId) ? r : s.addressId),
                    this.$user.setGeo(s).then(( () => {
                        this.$eventBus.dispatchEvent(new CustomEvent("ExternalSelectAddress",{
                            detail: {
                                selectedAddressId: a,
                                dWay: s.deliveryType
                            }
                        }))
                    }
                    )),
                    this.dpPopup.close()
                }
                async saveLastAddressAsync(e, t, r, s, n) {
                    this.$services.cartService.localBasket.setAddress(e, t, r, s),
                    this.$auth.isAuth && this.$httpClient.fetchJSON(this.$services.cartService.publicBasketApiUrl + "/spa/address/select", {
                        credentials: "include",
                        method: "POST",
                        body: this.$helper.objectSerializer({
                            addressId: e,
                            deliveryWay: t
                        })
                    }),
                    this.$analitic.setCurrentAddress(t, n),
                    this.$analitic.sendAddressSelection({
                        source: "Header",
                        deliveryType: t,
                        addressId: e,
                        address: r,
                        isChanged: s
                    })
                }
            }
            ;
            var q = class {
                constructor() {
                    this.nativeLazyImage = "loading"in HTMLImageElement.prototype,
                    this.intersectionObserver = "IntersectionObserver"in window,
                    this.webpImage = !1,
                    this._checkWebpImageSupport()
                }
                async _checkWebpImageSupport() {
                    if (0 === document.createElement("canvas").toDataURL("image/webp").indexOf("data:image/webp"))
                        this.webpImage = !0;
                    else
                        try {
                            const e = new Image;
                            e.onload = function() {
                                e.width > 0 && e.height > 0 && (this.webpImage = !0)
                            }
                            .bind(this),
                            e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"
                        } catch (e) {}
                }
            }
            ;
            class V {
                static get() {
                    const e = localStorage.getObject(V.storageKey()) || {
                        url: [],
                        query: [],
                        nm: []
                    };
                    return e.nm = e.nm.map((e => e.nmId)),
                    e
                }
                static getRecentWithTimestamp() {
                    return localStorage.getObject(V.storageKey()) || {
                        url: [],
                        query: [],
                        nm: []
                    }
                }
                static addProduct(e) {
                    ("number" == typeof e || "string" == typeof e && !isNaN(Number(e))) && V.putInStorage("nm", e, 100)
                }
                static putInStorage(e, t, r) {
                    let s = V.getRecentWithTimestamp()
                      , n = {
                        time: parseInt(Date.now() / 1e3),
                        nmId: t
                    }
                      , a = s[e];
                    const o = a.indexOf(n);
                    0 !== o && (o > 0 && a.splice(o, 1),
                    a.unshift(n),
                    a.length > r && (a.length = r),
                    s[e] = a,
                    V.clearPrevStorage(),
                    localStorage.putObject(V.storageKey(), s))
                }
                static storageKey() {
                    return `recentViewsV2-${WbSpaModel.prototype.$user.getUid()}`
                }
                static clearPrevStorage() {
                    const e = `recentViews-${WbSpaModel.prototype.$user.getUid()}`;
                    localStorage.removeItem(e)
                }
            }
            var z = V;
            const G = "promotion-creatives";
            let Q, J, K, X, Y;
            const Z = class e {
                static getById(e) {
                    return Q && Q[e]
                }
                static isThermometerNeeded(e) {
                    return K && K.has(e)
                }
                static isRedPriceNeeded(e) {
                    return Y && Y.has(e)
                }
                static getFilter() {
                    return X
                }
                static getMainActionId() {
                    return 188852
                }
                static getHomeCarouselData() {
                    return {
                        caruselUrl: "/promotions/uhtydazha",
                        carouselName: "За яркими ценами!",
                        carouselBg: "#ED1AD8"
                    }
                }
                static async _startUpdate() {
                    try {
                        await navigator.locks.request(`lock-${G}`, (async t => {
                            var r;
                            const s = await e.prototype.$httpClient.fetchStaticV3(wb.helpers.url.urlStaticData, {
                                noCache: !0,
                                fetchType: "text"
                            }, `${G}.json.hash`);
                            if (s && s !== (null == (r = localStorage.getObject(G)) ? void 0 : r.hash)) {
                                const t = await e.prototype.$httpClient.fetchStaticV3(wb.helpers.url.urlStaticData, {
                                    noCache: !0
                                }, `${G}.json`);
                                t.hash = s,
                                this.initPromoCreatives(t),
                                localStorage.putObject(G, t),
                                localStorage.removeItem("promotions"),
                                localStorage.removeItem("promotions-hash")
                            }
                        }
                        ))
                    } catch (e) {}
                }
                static initPromoCreatives(e) {
                    var t, r, s;
                    e && (Q = {},
                    null == (t = e.panels) || t.forEach((e => Q[e.id] = e)),
                    K = new Set(null != (r = e.thermometer) ? r : []),
                    Y = new Set(null != (s = e.redPrices) ? s : []),
                    e.filter && (null == X ? void 0 : X.id) !== e.filter.id && (document.documentElement.style.setProperty("--custom-promo-filter-color", e.filter.color),
                    document.documentElement.style.setProperty("--custom-promo-filter-background", e.filter.background),
                    document.documentElement.style.setProperty("--custom-promo-filter-switch-color", e.filter.switch),
                    document.documentElement.style.setProperty("--custom-promo-filter-switch-background", e.filter.switchBackground)),
                    X = e.filter)
                }
            }
            ;
            Z.initPromoCreatives(localStorage.getObject(G)),
            Z._startUpdate(),
            J = setInterval(Z._startUpdate.bind(Z), 18e4);
            var ee = Z
              , te = (r(30311),
            r(34832))
              , re = r.n(te);
            const se = navigator.connection || navigator.mozConnection || navigator.webkitConnection
              , ne = Object.freeze({
                c246x328: "c246x328",
                c516x688: "c246x328",
                big: "c516x688"
            })
              , ae = {
                volHostV2: function(e) {
                    const t = ~~(e / 1e5);
                    let r;
                    switch (!0) {
                    case t >= 0 && t <= 143:
                        r = "01";
                        break;
                    case t <= 287:
                        r = "02";
                        break;
                    case t <= 431:
                        r = "03";
                        break;
                    case t <= 719:
                        r = "04";
                        break;
                    case t <= 1007:
                        r = "05";
                        break;
                    case t <= 1061:
                        r = "06";
                        break;
                    case t <= 1115:
                        r = "07";
                        break;
                    case t <= 1169:
                        r = "08";
                        break;
                    case t <= 1313:
                        r = "09";
                        break;
                    case t <= 1601:
                        r = "10";
                        break;
                    case t <= 1655:
                        r = "11";
                        break;
                    case t <= 1919:
                        r = "12";
                        break;
                    case t <= 2045:
                        r = "13";
                        break;
                    case t <= 2189:
                        r = "14";
                        break;
                    case t <= 2405:
                        r = "15";
                        break;
                    case t <= 2621:
                        r = "16";
                        break;
                    case t <= 2837:
                        r = "17";
                        break;
                    case t <= 3053:
                        r = "18";
                        break;
                    case t <= 3269:
                        r = "19";
                        break;
                    case t <= 3485:
                        r = "20";
                        break;
                    default:
                        r = "21"
                    }
                    return `basket-${r}.wbbasket.ru/vol${t}`
                },
                volFeedbackPhotoHost: function(e) {
                    const t = ~~(e / 1e5);
                    let r;
                    switch (!0) {
                    case t >= 0 && t <= 431:
                        r = "01";
                        break;
                    case t <= 863:
                        r = "02";
                        break;
                    case t <= 1199:
                        r = "03";
                        break;
                    case t <= 1535:
                        r = "04";
                        break;
                    case t <= 1919:
                        r = "05";
                        break;
                    case t <= 2303:
                        r = "06";
                        break;
                    case t <= 2688:
                        r = "07";
                        break;
                    default:
                        r = "08"
                    }
                    return `feedback${r}.wbbasket.ru/vol${t}`
                },
                volVideoHost: function(e) {
                    const t = e % 144;
                    let r;
                    switch (!0) {
                    case t >= 0 && t <= 11:
                        r = "01";
                        break;
                    case t <= 23:
                        r = "02";
                        break;
                    case t <= 35:
                        r = "03";
                        break;
                    case t <= 47:
                        r = "04";
                        break;
                    case t <= 59:
                        r = "05";
                        break;
                    case t <= 71:
                        r = "06";
                        break;
                    case t <= 83:
                        r = "07";
                        break;
                    case t <= 95:
                        r = "08";
                        break;
                    case t <= 107:
                        r = "09";
                        break;
                    case t <= 119:
                        r = "10";
                        break;
                    case t <= 131:
                        r = "11";
                        break;
                    case t <= 143:
                        r = "12";
                        break;
                    default:
                        r = "13"
                    }
                    return `videonme-basket-${r}.wbbasket.ru/vol${t}`
                },
                volStaticHost: function(e) {
                    const t = e;
                    let r;
                    switch (!0) {
                    case t >= 0 && t <= 4:
                        r = "01";
                        break;
                    case t >= 20 && t <= 35:
                        r = "02";
                        break;
                    case t >= 40 && t <= 54:
                        r = "03";
                        break;
                    case t >= 70 && t <= 113:
                        r = "04";
                        break;
                    case t >= 114 && t <= 125:
                        r = "05";
                        break;
                    case t >= 126 && t <= 137:
                        r = "06";
                        break;
                    case t >= 138 && t <= 149:
                        r = "07";
                        break;
                    default:
                        r = "08"
                    }
                    return `static-basket-${r}.wbbasket.ru/vol${t}`
                },
                volFeedbackVideoHost: function(e) {
                    return `videofeedback${("00" + e).slice(-2)}.wbbasket.ru`
                },
                constructHostV2: function(e, t="nm", r=!1) {
                    const s = parseInt(e, 10)
                      , n = "video" === t ? ~~(s / 1e4) : ~~(s / 1e3);
                    let a;
                    return "nm" === t ? a = ae.volHostV2(s, r) : "feedbackPhoto" === t ? a = ae.volFeedbackPhotoHost(s, r) : "video" === t && (a = ae.volVideoHost(s, r)),
                    `https://${a}/part${n}/${s}`
                }
            };
            wb.helpers = {
                deepClone: e => JSON.parse(JSON.stringify(e)),
                getHashCode: e => {
                    let t, r, s = 0;
                    if (0 === e.length)
                        return s;
                    for (t = 0; t < e.length; t++)
                        r = e.charCodeAt(t),
                        s = (s << 5) - s + r,
                        s |= 0;
                    return s
                }
                ,
                generateGuid: e => {
                    const t = URL.createObjectURL(new Blob).split("/").pop();
                    return e ? t : t.replace(/-/g, "")
                }
                ,
                hasBit(e, t) {
                    return !!(t & 1 << e)
                },
                date: {
                    leftBefore: function(e) {
                        const t = wb.helpers.date.serverDate ? new Date(wb.helpers.date.serverDate) : new Date
                          , r = e.getTime() - t.getTime()
                          , s = Math.floor(r / 1e3 % 60)
                          , n = Math.floor(r / 6e4 % 60)
                          , a = Math.floor(r / 36e5);
                        return String.format("{0}:{1}:{2}", $.views.converters.leadZero(a, 2), $.views.converters.leadZero(n, 2), $.views.converters.leadZero(s, 2))
                    },
                    diff: (e, t=new Date) => {
                        const r = {
                            days: 0,
                            months: 0,
                            years: 0
                        };
                        if (e == t)
                            return r;
                        if (e > t)
                            return wb.helpers.date.diff(t, e);
                        if (r.years = t.getFullYear() - e.getFullYear(),
                        r.months = t.getMonth() - e.getMonth(),
                        r.days = t.getDate() - e.getDate(),
                        r.days < 0) {
                            const t = new Date(e.getFullYear(),e.getMonth() + 1,0);
                            r.months--,
                            r.days += t.getDate()
                        }
                        return r.months < 0 && (r.years--,
                        r.months += 12),
                        r
                    }
                    ,
                    formatEstimated: (e, t, r) => {
                        const {timeFrom: s, timeTo: n} = r || {}
                          , a = new Date;
                        a.setHours(0, 0, 0, 0);
                        const o = new Date(e);
                        t || (t = new Date(e)),
                        t.setDate(t.getDate());
                        if (t - a < 0)
                            return "Задерживается";
                        if (s && n) {
                            const e = $.views.converters.formatTimeStr(s);
                            return `${$.views.converters.dayNameFromDate(o, !0)} c ${e} до&nbsp;${n}`
                        }
                        return o.getMonth() !== t.getMonth() ? `${o.format("d MMMM")}-${t.format("d MMMM")}` : o.getDate() !== t.getDate() ? `${o.getDate()}-${t.format("d MMMM")}` : `${o.format("d MMMM")}`
                    }
                    ,
                    paymentFedbackTimerStr: (e, t) => {
                        const r = e.setDate(e.getDate() + 5) - t
                          , s = Math.floor(r / 1e3 % 60)
                          , n = Math.floor(r / 6e4 % 60)
                          , a = Math.floor(r / 36e5);
                        return r > 0 && a < 24 ? String.format("{0}:{1}:{2}", $.views.converters.leadZero(a, 2), $.views.converters.leadZero(n, 2), $.views.converters.leadZero(s, 2)) : ""
                    }
                },
                getParamsFromUrlQuery: function(e) {
                    if (!e)
                        return {};
                    0 === e.indexOf("?") && (e = e.substring(1));
                    const t = e.split("&")
                      , r = {};
                    for (let e = 0, s = t.length; e < s; e++) {
                        const s = t[e].split("=");
                        r[s[0]] = s[1]
                    }
                    return r
                },
                appendToParamsFromQuery: function(e, t) {
                    if (!t)
                        return;
                    0 === t.indexOf("?") && (t = t.substring(1));
                    const r = t.split("&");
                    for (let t = 0, s = r.length; t < s; t++) {
                        const s = r[t].split("=");
                        e.set(s[0], s[1])
                    }
                },
                getCardImgName: function(e) {
                    if (1 === e.idx) {
                        return function(e, t) {
                            if (!t)
                                return !1;
                            const r = parseInt((2048 & t ? "1" : "0") + (1024 & t ? "1" : "0"), 2);
                            if (0 === r)
                                return !1;
                            const s = wb.cookieHelper.getCookie("_wbauid");
                            if (!s)
                                return !1;
                            const n = e + s + "ABTest=Be$t"
                              , a = re()(n)
                              , o = JSBI.BigInt("0x" + a.slice(-16))
                              , i = JSBI.remainder(o, JSBI.BigInt(r + 1))
                              , l = JSBI.toNumber(i);
                            return 0 != l && `ab_${l}`
                        }(e.nmId, e.viewFlags) || e.idx
                    }
                    return e.idx
                },
                url: {
                    imageUrl: function(e, t, r, s, n, a) {
                        var o, i;
                        s && !WbSpaModel.prototype.$isDesktop && (t = s);
                        const l = parseInt(e, 10);
                        if ((null == se ? void 0 : se.effectiveType) && "4g" !== (null == se ? void 0 : se.effectiveType) && "3g" !== (null == se ? void 0 : se.effectiveType) && ne[t] && (null == (i = null == (o = wb.global.settings) ? void 0 : o.switches) ? void 0 : i.enableProductImageDowngrade) && (t = ne[t]),
                        isNaN(l) || 0 === l)
                            return $.views.converters.urlSiteStatic(`i/product/notfound/${t}.jpg`);
                        return `${ae.constructHostV2(l, "nm", a)}/images/${t}/${wb.helpers.getCardImgName({
                            nmId: e,
                            viewFlags: n,
                            idx: null != r ? r : 1
                        })}.webp`
                    },
                    urlForJsTmpl: function(e, t=!1) {
                        return window._debug || window._isFeature ? `/t/jst/${e}` : wb.helpers.url.urlSiteStatic(`t/jst/${e}`, t)
                    },
                    urlProductStatic: function(e, t=!1) {
                        return `${ae.constructHostV2(e, "nm", t)}/info/ru/card.json`
                    },
                    urlPriceHistoryStatic: function(e, t=!1) {
                        return `${ae.constructHostV2(e, "nm", t)}/info/price-history.json`
                    },
                    urlSellerStatic: function(e, t=!1) {
                        return `${ae.constructHostV2(e, "nm", t)}/info/sellers.json`
                    },
                    urlMulticardStatic: function(e, t=!1) {
                        return `${ae.constructHostV2(e, "nm", t)}/multicart/${e}.json`
                    },
                    urlCertificateStatic: function(e, t=!1) {
                        return `${ae.constructHostV2(e, "nm", t)}/info/certificate.json`
                    },
                    urlStaticData: function(e, t=!1) {
                        return wb.helpers.url.urlStaticBasket(`data/${e}`, 0, t)
                    },
                    urlSiteStatic: function(e, t=!1) {
                        return wb.helpers.url.urlStaticBasket(`${wb.settings.siteStaticPath}${e}`, 2, t)
                    },
                    urlStaticBasket: function(e, t, r=!1) {
                        if (e.startsWith("//"))
                            return e;
                        return `https://${ae.volStaticHost(t, r)}/${e}`
                    },
                    urlFeedbackPhoto: function(e, t="ms", r=!1) {
                        const s = parseInt(e, 10);
                        return `${ae.constructHostV2(s, "feedbackPhoto", r)}/photos/${t}.${$.views.converters.toWebp("jpg")}`
                    },
                    urlVideoProduct: function(e, t="mp4", r="360p", s=!1) {
                        const n = parseInt(e, 10);
                        return `${ae.constructHostV2(n, "video", s)}/${t}/${r}/${"mp4" === t ? "1.mp4" : "index.m3u8"}`
                    },
                    urlRichContent: function(e, t=!1) {
                        return `${ae.constructHostV2(e, "nm", t)}/info/ru/rich_v1.json`
                    },
                    urlImageTags: function(e, t, r=!1) {
                        const s = ae.constructHostV2(e, "nm", r);
                        return t ? `${s}/info/tags/${t}.json` : `${s}/info/tags/picMap.json`
                    },
                    urlFeedbackVideo: function(e, t="preview.webp", r=!1) {
                        const s = e.id
                          , [n,a] = null == s ? void 0 : s.split("/");
                        return `https://${ae.volFeedbackVideoHost(n, r)}/${a}/${t}`
                    },
                    urlPdfInstruction: function(e) {
                        return `https://content-0${e.shard}.wbbasket.ru/${e.uuid}/${e.type_id}.pdf`
                    }
                },
                replaceDeliveryFilterVal: function(e) {
                    return e.replace(/&fdlvr=(\d+)/, ( (e, t) => {
                        const r = 23 - new Date(Date.now()).getHours() - 1;
                        let s = null;
                        switch (parseInt(t)) {
                        case 4:
                            s = r > 4 ? 4 : r;
                            break;
                        case 12:
                            s = r;
                            break;
                        case 24:
                            s = 24 + r;
                            break;
                        case 48:
                            s = 48 + r;
                            break;
                        case 72:
                            s = 72 + r;
                            break;
                        case 120:
                            s = 120 + r
                        }
                        return null != s ? `&fdlvr=${s}` : ""
                    }
                    ))
                },
                path: {
                    fileName: e => (null == e ? void 0 : e.substring(e.lastIndexOf("/") + 1)) || "",
                    extension: e => (null == e ? void 0 : e.slice(1 + (Math.max(e.lastIndexOf("."), 0) || e.length))) || ""
                },
                iOS: function() {
                    return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend"in document
                },
                huawei: function() {
                    const e = navigator.userAgent || navigator.vendor || window.opera;
                    return /huawei/i.test(e)
                },
                formatVideoDuration: function(e) {
                    const t = Math.floor(e / 60)
                      , r = e % 60;
                    return `${t < 10 ? `0${t}` : t}:${r < 10 ? `0${r}` : r}`
                },
                setImgFunc: function(e, t) {
                    if ("function" == typeof t)
                        switch (e) {
                        case "mediabasket_route_map":
                            ae.volHostV2 = t;
                            break;
                        case "feedback_route_map":
                            ae.volFeedbackPhotoHost = t;
                            break;
                        case "videonme_route_map":
                            ae.volVideoHost = t;
                            break;
                        case "staticbasket_route_map":
                            ae.volStaticHost = t
                        }
                },
                downloadFile(e, t) {
                    const r = URL.createObjectURL(e)
                      , s = document.createElement("a");
                    s.setAttribute("target", "_blank"),
                    s.href = r,
                    t && (s.download = t),
                    document.body.appendChild(s),
                    s.click(),
                    document.body.removeChild(s)
                },
                async downloadOrShareFile(e, t, r, s, n) {
                    const a = new File([e],t,{
                        type: r
                    })
                      , o = [a];
                    try {
                        if ("m" === wb.settings.displayMode && navigator.canShare({
                            files: o
                        }))
                            return await navigator.share({
                                files: o
                            }),
                            void (null == n || n())
                    } catch (e) {
                        wb.spa.logError(e, s)
                    }
                    wb.helpers.downloadFile(a)
                }
            };
            var oe = Object.freeze({
                delete: 0,
                add: 1
            });
            var ie = class {
                constructor(e, t=!1) {
                    this.items = e.sort(( (e, t) => {
                        var r, s;
                        return null != (s = t.timestamp) ? s : 0 - (null != (r = e.timestamp) ? r : 0)
                    }
                    )),
                    this.isEmptyCache = t,
                    this._favoritesGoodsMap = null
                }
                get count() {
                    return this.items.length
                }
                get favoritesGoodsMap() {
                    return null != this._favoritesGoodsMap || (this._favoritesGoodsMap = this.items.reduce(( (e, t) => (e.set(t.characteristicId, t),
                    e)), new Map)),
                    this._favoritesGoodsMap
                }
            }
            ;
            const le = "user_favorite_goods_{0}_v{1}";
            var ce = class {
                constructor(e) {
                    this.uid = null,
                    this.cacheModel = null,
                    this._storageHelper = e,
                    this._bindEvents()
                }
                get cacheKey() {
                    return String.format(le, this.uid, 1)
                }
                get lastSyncCacheKey() {
                    return String.format("favorite_last_sync_dt_{0}_v{1}", this.uid, 1)
                }
                get tabsSyncCacheKey() {
                    return String.format("favorite_tabs_sync_v{0}", 1)
                }
                setKey(e) {
                    this.uid = e,
                    this._checkOldCache(),
                    this.cacheModel = null
                }
                async getLastSyncDt() {
                    var e;
                    if (null == this.uid)
                        return -1;
                    try {
                        const t = await this._openIDb()
                          , r = await this._storageHelper.getItem(t, this.lastSyncCacheKey, "sync_dt");
                        return null != (e = null == r ? void 0 : r.lastSyncDt) ? e : -1
                    } catch (e) {
                        return this.getLastSyncDtFromLocalStorage()
                    }
                }
                getLastSyncDtFromLocalStorage() {
                    var e;
                    if (null == this.uid)
                        return -1;
                    const t = null != (e = localStorage.getItem(this.lastSyncCacheKey)) ? e : -1;
                    return parseInt(localStorage.hasItem(this.cacheKey) ? t : -1)
                }
                async setLastSyncDt(e) {
                    if (!(await this.getLastSyncDt() >= e || null == this.uid))
                        try {
                            const t = await this._openIDb();
                            await this._storageHelper.setItem(t, this.lastSyncCacheKey, {
                                name: "sync_dt",
                                lastSyncDt: e
                            })
                        } catch (t) {
                            localStorage.setItem(this.lastSyncCacheKey, e)
                        }
                }
                async clearLastSyncDt() {
                    try {
                        const e = await this._openIDb();
                        await this._storageHelper.removeItem(e, this.lastSyncCacheKey, "sync_dt")
                    } catch (e) {
                        localStorage.removeItem(this.lastSyncCacheKey)
                    }
                }
                async getFavoriteGoods(e=!1) {
                    if (null == this.uid && (this.cacheModel = new ie([],!0)),
                    !this.cacheModel) {
                        let e = await this._fetchFromIDb();
                        null == e && (e = localStorage.getObject(this.cacheKey)),
                        this.cacheModel = null == e ? new ie([],!0) : new ie(e)
                    }
                    return e ? this.cacheModel : new ie(this.cacheModel.items.filter((e => !e.needSync || e.needSync && e.syncType !== oe.delete)),this.cacheModel.isEmptyCache)
                }
                async getFavoriteGoodsFromLocalStorage(e=null) {
                    var t;
                    null == this.uid && (this.cacheModel = new ie([],!0));
                    const r = null != (t = null != e ? e : await this._fetchFromIDb()) ? t : localStorage.getObject(this.cacheKey)
                      , s = null == r ? new ie([],!0) : new ie(r);
                    return new ie(s.items.filter((e => !e.needSync || e.needSync && e.syncType != oe.delete)),s.isEmptyCache)
                }
                async setFavoriteGoods(e) {
                    if (null == this.uid)
                        return;
                    this.cacheModel = null == e ? new ie([],!0) : new ie(e);
                    !await this._saveToIDb(e) && localStorage.putObject(this.cacheKey, e),
                    localStorage.setItem(this.tabsSyncCacheKey, `${Date.now()}`)
                }
                contains(e) {
                    if (null == this.cacheModel)
                        return !1;
                    const t = this.cacheModel.favoritesGoodsMap.get(e);
                    return null != t && !(t.needSync && t.syncType === oe.delete)
                }
                _checkOldCache() {
                    for (let e = 1; e < 1; e++)
                        localStorage.removeItem(String.format(le, this.uid, e))
                }
                _bindEvents() {
                    window.addEventListener("storage", (e => {
                        null != e.key && e.key !== this.tabsSyncCacheKey || (this.cacheModel = null,
                        this.getFavoriteGoods())
                    }
                    ))
                }
                async _fetchFromIDb() {
                    try {
                        const e = await this._openIDb()
                          , t = await this._storageHelper.getAll(e, this.cacheKey);
                        return null != t ? t : []
                    } catch (e) {
                        return console.log(`[FAVS_STORAGE]: fetching from idb failed, reason=${e.message}`),
                        null
                    }
                }
                async _saveToIDb(e) {
                    try {
                        const t = await this._openIDb()
                          , r = t.transaction([this.cacheKey], "readwrite").objectStore(this.cacheKey);
                        r.clear();
                        for (let t of e)
                            r.put(t);
                        return !0
                    } catch (e) {
                        return console.log(`[FAVS_STORAGE]: saving to idb failed, reason=${e.message}`),
                        !1
                    }
                }
                async _openIDb() {
                    try {
                        return await this._storageHelper.openDb("wb_" + this.cacheKey, {
                            onupgradeneeded: e => {
                                if (!e.objectStoreNames.contains(this.cacheKey)) {
                                    e.createObjectStore(this.cacheKey, {
                                        keyPath: "characteristicId"
                                    }).createIndex("timestamp", "timestamp", {
                                        unique: !1
                                    })
                                }
                                e.objectStoreNames.contains(this.lastSyncCacheKey) || e.createObjectStore(this.lastSyncCacheKey, {
                                    keyPath: "name"
                                })
                            }
                            ,
                            version: 1
                        })
                    } catch (e) {
                        return null
                    }
                }
            }
            ;
            var ue = class {
                static convertToFavoriteGoods(e={}, t={}) {
                    var r, s, n, a, o, i, l, c;
                    const u = null == (r = e.sizes) ? void 0 : r.find((e => e.optionId === t.characteristicId))
                      , d = null != (s = null == u ? void 0 : u.price) ? s : e.price
                      , p = d && null != (a = null == (n = null == u ? void 0 : u.stocks) ? void 0 : n.some((e => e.qty > 0))) && a
                      , h = 20624 === e.brandId || 30624 === e.siteBrandId
                      , m = p ? d.priceToShow / 100 : 0
                      , g = {
                        nmId: e.id,
                        cod1S: e.id,
                        brandName: e.brand,
                        characteristicId: t.characteristicId,
                        meta: t.meta,
                        id: t.characteristicId,
                        goodsName: e.name,
                        colorName: null == (i = null == (o = e.colors) ? void 0 : o[0]) ? void 0 : i.name,
                        onStock: p ? 1 : 0,
                        star: e.rating,
                        price: p ? d.basic / 100 : 0,
                        priceWithSale: m,
                        priceWithCouponAndDiscount: m,
                        sale: p ? d.sale : 0,
                        totalSale: p ? d.sale : 0,
                        salePrice: m,
                        targetUrl: null != (l = t.targetUrl) ? l : "",
                        sizeName: null != (c = null == u ? void 0 : u.origName) ? c : "",
                        stocks: null == u ? void 0 : u.stocks,
                        timestamp: t.timestamp,
                        deliveryHours: p && e.time1 + e.time2,
                        source: t.source,
                        subjectId: e.subjectId,
                        subjectParentId: e.subjectParentId,
                        reviewRating: e.reviewRating,
                        feedbacks: e.feedbacks || e.commentsCount,
                        supplierId: e.supplierId,
                        supplier: e.supplier,
                        newlyArrived: p && (1 & t.source) > 0,
                        _rawCatalogModel: e,
                        viewFlags: e.viewFlags,
                        shouldShowOriginalMark: !h && !!(8 & e.viewFlags),
                        paymentDiscountAmount: wb.settings.b2bMode ? 0 : wb.priceHelper.calcWalletDiscount(m, e.currency, null == u ? void 0 : u.saleConditions),
                        premiumSale: e.premiumSale,
                        showRedPrice: wb.xnm.isRedPrice(e.panelPromoId),
                        get isDeleted() {
                            return !(this.goodsName || this.brandName || this.colorName || this.sizeName)
                        },
                        get showDiscount() {
                            return (this.price > 0 || this.priceWithCouponAndDiscount > 0) && this.price != this.priceWithCouponAndDiscount
                        }
                    };
                    return wb.settings.b2bMode && (g.isVatRefundable = wb.xnm.isVatRefundable(e.viewFlags),
                    g.vatPercent = wb.xnm.getVatPercent(e.viewFlags)),
                    g
                }
                static convertFromAddModelToCacheItem(e, t) {
                    var r, s, n;
                    const a = wb.analitics.analiticsInfoToListName(e)
                      , o = {
                        characteristicId: e.characteristicId,
                        cod1S: e.cod1S,
                        id: e.characteristicId,
                        source: t,
                        targetUrl: `${null != (r = e.targetUrl) ? r : ""}|${null != (s = e.iid) ? s : 1}|${a}|${e.logs}`,
                        timestamp: Math.ceil(Date.now() / 1e3),
                        meta: e.meta
                    };
                    return (null == (n = o.meta) ? void 0 : n.shade) && delete o.meta.shade,
                    o
                }
                static convertFromCacheItemToUserStorageItem(e) {
                    return {
                        product_option_id: e.characteristicId,
                        product_id: e.cod1S,
                        target_url: e.targetUrl,
                        added_timestamp: e.timestamp,
                        meta: e.meta,
                        fav_type: 3 == e.source || 1 == e.source ? 1 : 2
                    }
                }
                static convertFromUserStorageItemToCacheItem(e) {
                    return {
                        characteristicId: e.product_option_id,
                        cod1S: e.product_id,
                        targetUrl: e.target_url,
                        timestamp: e.added_timestamp,
                        count: 1,
                        source: e.fav_type,
                        meta: e.meta
                    }
                }
            }
              , de = Object.freeze({
                waitlist: 1,
                poned: 2,
                both: 3
            });
            class pe {
                constructor(e, t, r, s, n) {
                    this.chrt_id = +t,
                    this.cod_1s = r,
                    this.client_ts = s || Date.now() / 1e3 | 0,
                    this.op_type = e || 1,
                    this.type = n || 2
                }
                static fromCache(e) {
                    if (0 === e.syncType)
                        return pe.toDelete(e.characteristicId);
                    const t = new pe(1,e.characteristicId,e.cod1S,e.timestamp,e.source);
                    return t.client_ts > 1e12 && (t.client_ts = t.client_ts / 1e3 | 0),
                    t.target_url = e.targetUrl,
                    e.meta && (t.meta_json = JSON.stringify(e.meta)),
                    t
                }
                static toDelete(e) {
                    return new pe(3,e)
                }
                static convertFromSharedModelToCacheItem(e) {
                    const t = {
                        characteristicId: e.chrt_id,
                        cod1S: e.cod_1s,
                        targetUrl: e.target_url,
                        timestamp: e.client_ts,
                        source: e.type
                    };
                    try {
                        t.meta = e.meta_json ? JSON.parse(e.meta_json) : null
                    } catch (e) {}
                    return t
                }
            }
            var he = pe;
            const me = m.D4;
            var ge = class {
                constructor(e) {
                    this._cacheHelper = e,
                    this.debounceSync = this.$helper.debounce(this.sync.bind(this), 3e3)
                }
                async _getOperationAsync() {
                    return (await this._cacheHelper.getFavoriteGoods(!0)).items.filter((e => e.needSync)).map((e => he.fromCache(e)))
                }
                async _getAllAsync() {
                    return (await this._cacheHelper.getFavoriteGoods()).items.map((e => he.fromCache(e)))
                }
                async sync(e) {
                    var t;
                    if (this.$auth.isAuth) {
                        this._syncProcess = null != (t = this._syncProcess) ? t : this._sync(e);
                        try {
                            return await this._syncProcess
                        } catch (e) {} finally {
                            this._syncProcess = null
                        }
                    }
                }
                async _sync(e) {
                    return await navigator.locks.request("lock-fav-sync", (async t => {
                        const r = await this._cacheHelper.getLastSyncDt()
                          , s = await this._getOperationAsync()
                          , n = this.$services.sessionService.getSession();
                        try {
                            const t = await this._doSync({
                                ts: r,
                                sessionId: n,
                                operations: s,
                                timeout: e
                            });
                            if (this._sendMetrics(t.state),
                            0 === t.state && t.change_ts > 0)
                                return await this._updateProductsAsync(s, t);
                            if (1 === t.state) {
                                const e = await this._getAllAsync()
                                  , t = await this._doSync({
                                    ts: r,
                                    sessionId: n,
                                    operations: e,
                                    rememberMe: !0
                                });
                                if (0 === t.state && t.change_ts > 0)
                                    return await this._updateProductsAsync(e, t)
                            } else
                                t && wb.spa.logError(new Error(`[WB_FAVS_SYNC]: sync state:${t.state}`), {
                                    result: t,
                                    ts: r,
                                    deviceId: n,
                                    opLen: s.length,
                                    hasJwt: this.$auth.isAuth
                                })
                        } catch (e) {
                            const t = !e.isCustomError && e instanceof TypeError && ("Failed to fetch" === e.message || "NetworkError when attempting to fetch resource." === e.message || "Cancelled" === e.message);
                            this._sendMetrics(t ? "network" : "error"),
                            wb.spa.logError(new Error(`[WB_FAVS_SYNC]: ${e.message}`), {
                                ts: r,
                                deviceId: n,
                                opLen: s.length,
                                hasJwt: this.$auth.isAuth
                            })
                        }
                        return !1
                    }
                    ))
                }
                async _updateProductsAsync(e, t) {
                    return await this._cacheHelper.setFavoriteGoods(await this.mergeUpdatedAndCacheItems(e, t.result_set)),
                    await this._cacheHelper.setLastSyncDt(t.change_ts),
                    !0
                }
                async mergeUpdatedAndCacheItems(e, t) {
                    var r;
                    const s = (null == (r = (await this._cacheHelper.getFavoriteGoods(!0)).items) ? void 0 : r.toMap((e => e.characteristicId), (e => e))) || new Map;
                    return null == e || e.forEach((e => {
                        if (3 === e.op_type)
                            s.delete(e.chrt_id);
                        else {
                            const t = s.get(e.chrt_id);
                            t && (delete t.needSync,
                            delete t.syncType)
                        }
                    }
                    )),
                    null == t || t.forEach((e => {
                        const t = s.get(e.chrt_id);
                        if (null == t ? void 0 : t.needSync) {
                            if (!e.is_deleted)
                                return;
                            if (1 === t.op_type)
                                return
                        }
                        e.is_deleted ? s.delete(e.chrt_id) : s.set(e.chrt_id, he.convertFromSharedModelToCacheItem(e))
                    }
                    )),
                    s.toArray().sort(( (e, t) => t.timestamp - e.timestamp))
                }
                _doSync({ts: e, sessionId: t, operations: r, rememberMe: s=!1, timeout: n=null}) {
                    return this.$wbxHttpClient.fetch(`${me}/sync?ts=${e}&device_id=${t}${s ? "&remember_me=true" : ""}`, {
                        method: "POST",
                        body: JSON.stringify(r),
                        headers: {
                            "Content-Type": "application/json",
                            "Wb-AppType": "site"
                        },
                        timeout: n || 1e4
                    }).then((async e => e.ok ? e.json() : {})).then((e => (e.result_set && (e.result_set = e.result_set[0] || []),
                    e)))
                }
                _sendMetrics(e) {
                    if (!window._debug)
                        try {
                            fetch(`/webapi/logging/favs/metrics?status=${e}`, {
                                method: "POST"
                            })
                        } catch (e) {}
                }
            }
              , ye = Object.defineProperty
              , be = Object.getOwnPropertySymbols
              , fe = Object.prototype.hasOwnProperty
              , ve = Object.prototype.propertyIsEnumerable
              , we = (e, t, r) => t in e ? ye(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }) : e[t] = r;
            const Se = "favs/favs_v1_synced"
              , _e = "favs/favs_v3_synced"
              , Ce = "favs/site_items"
              , Ie = "_favs_synced_v3";
            var Me = class {
                constructor() {
                    this._cacheHelper = new ce(this.$storageHelper),
                    this._enrichedFavoriteItems = new Map,
                    this._timer = null,
                    this.isSynced = !1,
                    this._hasBeenLoadedOnce = !1,
                    this._bindEvents()
                }
                init() {
                    Object.setPrototypeOf(ge.prototype, WbSpaModel.prototype),
                    this.dumpFav = new ge(this._cacheHelper)
                }
                setKey(e, t) {
                    this._stopSyncronizing(),
                    e && (this._cacheHelper.setKey(t),
                    localStorage.clearStartsWith(Ie, this._favV3Key),
                    this._startSyncronizing())
                }
                async syncFromServerAsync() {
                    if (this.isSynced || this._initialSyncInProgress)
                        return;
                    this._initialSyncInProgress = !0;
                    const e = await this._loadRawGoodsFromDumpAsync();
                    return this._initialSyncInProgress = !1,
                    e
                }
                async getWlArrivedCatalogModelAsync() {
                    window._debug && console.time("buildWlArrivedCatalogModel");
                    try {
                        const [e,t] = await Promise.all([this._loadFavoriteGoodsAsync(), this.$moduleLoader.loadModuleAsync("favoriteGoodsModel")])
                          , r = new t(e);
                        return r.setOnlyWlArrived(!0).setSorting(1).setGoods(Number.MAX_SAFE_INTEGER).complete(),
                        {
                            goods: r.favoriteGoods
                        }
                    } catch (e) {
                        return console.error(e),
                        {
                            goods: [],
                            isEmptyCache: !0
                        }
                    } finally {
                        window._debug && console.timeEnd("buildWlArrivedCatalogModel")
                    }
                }
                async getSimplifiedModelAsync() {
                    window._debug && console.time("buildFavSimpleModel");
                    try {
                        const [e,t] = await Promise.all([this._loadFavoriteGoodsAsync(), this.$moduleLoader.loadModuleAsync("favoriteGoodsModel")]);
                        return new t(e).setSorting(7).setGoods(16).toSimpleModel()
                    } catch (e) {
                        return console.error(e),
                        {
                            goods: [],
                            totalCount: 0,
                            availableCount: 0,
                            isEmptyCache: !0
                        }
                    } finally {
                        window._debug && console.timeEnd("buildFavSimpleModel")
                    }
                }
                async getFavsDataAsync(e="") {
                    var t, r, s, n;
                    window._debug && console.time("buildFavModel");
                    const a = new URLSearchParams(e)
                      , o = (parseInt(null != (t = a.get("page")) ? t : 1),
                    null != (r = a.get("sort")) ? r : "newlydown")
                      , i = null != (s = a.get("search")) ? s : ""
                      , l = "true" == (null != (n = a.get("wlArrived")) ? n : a.get("wlarrived"));
                    try {
                        const [e,t,r,{FavorireGoodsSorterModel: s}] = await Promise.all([this._loadFavoriteGoodsAsync(), this.$moduleLoader.loadModuleAsync("favoriteGoodsModel"), this.$moduleLoader.loadModuleAsync("pagerHelper"), this.$moduleLoader.loadModuleAsync("sorterModel")])
                          , n = new t(e,new s(o,window.location.href));
                        return n.setOnlyWlArrived(l).setSearch(i).setSorting().setGoods().complete(),
                        n
                    } catch (e) {
                        return console.error(e),
                        {
                            isEmptyCache: !0
                        }
                    } finally {
                        window._debug && console.timeEnd("buildFavModel")
                    }
                }
                async addToFavs(e, t=!1, r) {
                    if (!this.$auth.isAuth)
                        throw new UnauthorizeError;
                    return this.sendToWishlistStat(e, r),
                    t ? this._addToPoned(e) : this._addToWl(e)
                }
                async sendToWishlistStat(e, t) {
                    var r, s, n, a, o, i, l, c, u, d;
                    if (window.wba)
                        try {
                            const p = t && t.sizes || e && e.sizes || [];
                            let h = {
                                stores: null == (r = p.find((t => t.ch == e.characteristicId))) ? void 0 : r.stocks,
                                salePrice: t ? t.salePrice : e.salePrice
                            };
                            if (!h.stores) {
                                h = (await wb.xnm.getInfoForWbaStat([{
                                    nmId: e.cod1S,
                                    size: e.characteristicId
                                }])).get(e.cod1S)
                            }
                            const m = this.$analitic.getAnaliticsInfoFromTargetUrl(e.targetUrl)
                              , g = () => this.$analitic.analiticsInfoToListName(e.l ? e : m)
                              , y = () => this.$analitic.getTailObjectFromAnalyticsInfo(e.l ? e : m)
                              , b = this.$analitic.getStoreProp(null == h ? void 0 : h.stores, "dtype")
                              , f = this.$analitic.getDeliveryTypeForStat(b)
                              , v = this.$analitic.getStoreProp(null == h ? void 0 : h.stores, "wh");
                            if (["CSD", "CAD", "WLC", "WLA"].includes(e.l)) {
                                const t = WbSpaModel.prototype.$analitic.getTermsFromTailObject(e.l);
                                e.t = t.category,
                                e.t1 = t.id_category,
                                e.t2 = t.discount_name
                            }
                            const w = {
                                id: e.cod1S,
                                chrt: e.characteristicId,
                                quantity: e.quantity,
                                price: null == h ? void 0 : h.salePrice,
                                affiliation: null != (s = null == t ? void 0 : t.supplierId) ? s : e.supplierId,
                                deliveryType: f,
                                inListIndex: e.iid || 1,
                                listName: g(),
                                name: null != (n = null == t ? void 0 : t.name) ? n : e.goodsName,
                                brand: null != (a = null == t ? void 0 : t.brand) ? a : e.brandName,
                                rating: null != (o = null == t ? void 0 : t.reviewRating) ? o : e.reviewRating,
                                storeId: null != (i = null == e ? void 0 : e.storeId) ? i : v,
                                feedbacksCount: null != (l = null == t ? void 0 : t.feedbacks) ? l : e.feedbacks,
                                subjectId: null != (c = null == t ? void 0 : t.subjectId) ? c : e.subjectId,
                                subjectParentId: null != (u = null == t ? void 0 : t.subjectParentId) ? u : e.subjectParentId,
                                logs: null != (d = null == t ? void 0 : t.logs) ? d : e.logs,
                                tailObject: y(),
                                is_available: (null == t ? void 0 : t.soldOut) || e.soldOut ? 0 : 1
                            };
                            this.$analitic.sendWbaEcomStat("add_to_wishlist", [w])
                        } catch (e) {
                            console.error(e)
                        }
                }
                deleteFromFavs(e, t) {
                    return this._removeFromPoned(t)
                }
                isAddedToFavs(e) {
                    return this.syncFromServerAsync(),
                    this._cacheHelper.contains(e)
                }
                async deleteManyFromFavsAsync(e) {
                    const t = await this._cacheHelper.getFavoriteGoods(!0);
                    e.forEach((e => {
                        const r = t.favoritesGoodsMap.get(e.characteristicId);
                        r && (r.needSync = !0,
                        r.syncType = oe.delete)
                    }
                    )),
                    await this._cacheHelper.setFavoriteGoods(t.favoritesGoodsMap.toArray()),
                    this._canUseV3() && this.dumpFav.debounceSync(),
                    WbSpaModel.prototype.$moduleLoader.execModule("bottomNotificationPanel", "showNotification", [0, wb.i18n.t("favorites.productWasRemovedFromFavorites")])
                }
                async moveManyToBasketAsync(e) {
                    const t = this.$services.cartService.addManyItems(e);
                    return t.isSuccess && WbSpaModel.prototype.$moduleLoader.execModule("bottomNotificationPanel", "showNotification", [0, wb.i18n.t("favorites.productAddedToBasket")]),
                    t
                }
                _bindEvents() {
                    this.$eventBus.addEventListener("GeoUpdated", ( () => this._enrichedFavoriteItems.clear()))
                }
                async _loadFavoriteGoodsAsync() {
                    try {
                        const e = await this._loadRawGoodsFromDumpAsync(4e3);
                        if (!e)
                            return {
                                isEmptyCache: !0,
                                items: []
                            };
                        if (e.isEmptyCache)
                            return {
                                isEmptyCache: !0,
                                items: []
                            };
                        const t = e.items;
                        return t.length < 1 ? {
                            isEmptyCache: !1,
                            items: []
                        } : this._enrichGoodsAsync(t)
                    } catch (e) {
                        return console.error(e),
                        this._loadFromCache()
                    }
                }
                async _loadRawGoodsAsync() {
                    return this._cacheHelper.getFavoriteGoodsFromLocalStorage()
                }
                async _enrichGoodsAsync(e) {
                    const t = e.reduce(( (e, t) => (!this._enrichedFavoriteItems.has(t.characteristicId) && e.set(t.characteristicId, t),
                    e)), new Map);
                    let r = {};
                    return t.size > 0 && (r = await wb.xnm.getCatalogCards(t.toArray((e => e.cod1S)), !1, !0, !0)),
                    {
                        isEmptyCache: !1,
                        items: e.reduce(( (e, t) => {
                            var s;
                            const n = r[t.cod1S]
                              , a = this._enrichedFavoriteItems.get(t.characteristicId);
                            if (n || a) {
                                const r = null != (s = a && ( (e, t) => {
                                    for (var r in t || (t = {}))
                                        fe.call(t, r) && we(e, r, t[r]);
                                    if (be)
                                        for (var r of be(t))
                                            ve.call(t, r) && we(e, r, t[r]);
                                    return e
                                }
                                )({}, a)) ? s : ue.convertToFavoriteGoods(n, t);
                                e.push(r),
                                !a && this._enrichedFavoriteItems.set(r.characteristicId, r)
                            }
                            return e
                        }
                        ), [])
                    }
                }
                _addToPoned(e) {
                    return this._addThroughCache(e, de.poned)
                }
                async _removeFromPoned(e) {
                    const t = (await this._cacheHelper.getFavoriteGoods(!0)).items
                      , r = t.find((t => t.characteristicId === e));
                    r && (r.needSync = !0,
                    r.syncType = oe.delete),
                    await this._cacheHelper.setFavoriteGoods(t),
                    this._canUseV3() && this.dumpFav.debounceSync()
                }
                _addToWl(e) {
                    return this._addThroughCache(e, de.waitlist)
                }
                async _addThroughCache(e, t) {
                    if (!e.isFromCache) {
                        if ((await this._cacheHelper.getFavoriteGoods()).count >= 2e3)
                            throw new KnownServerError(String.format(this.$localziation.ponedMaxStorage, 2e3))
                    }
                    const r = (await this._cacheHelper.getFavoriteGoods(!0)).items;
                    let s = r.find((t => t.characteristicId == e.characteristicId));
                    s ? s.timestamp = Math.ceil(Date.now() / 1e3) : (s = ue.convertFromAddModelToCacheItem(e, t),
                    r.push(s)),
                    s.needSync = !0,
                    s.syncType = oe.add,
                    await this._cacheHelper.setFavoriteGoods(r),
                    this._canUseV3() && this.dumpFav.debounceSync()
                }
                async mergeActualAndCacheItems(e, t, r) {
                    const s = e.reduce(( (e, t) => (e.set(t.characteristicId, t),
                    e)), new Map)
                      , n = (await this._cacheHelper.getFavoriteGoods(!0)).items;
                    t > r && n.forEach((e => {
                        1e3 * e.timestamp > r && e.syncType != oe.delete && (e.needSync = !0,
                        e.syncType = oe.add)
                    }
                    ));
                    return n.filter((e => e.needSync)).forEach((e => {
                        (e.syncType == oe.delete && s.has(e.characteristicId) || e.syncType == oe.add && !s.has(e.characteristicId)) && s.set(e.characteristicId, e)
                    }
                    )),
                    s.toArray()
                }
                _startSyncronizing() {
                    this._canUseV3() || (this._timer = setInterval((async () => {
                        var e;
                        if (this._syncronizigInProcess || !this.isSynced)
                            return;
                        const t = await this._cacheHelper.getLastSyncDt();
                        let r = await this._getDumpFilesInfoAsync();
                        if (null === r || r.needsMigration)
                            return;
                        if (r.migratedV3)
                            return this._stopSyncronizing();
                        const s = (await this._cacheHelper.getFavoriteGoods(!0)).items;
                        let n = 0
                          , a = !1;
                        if (!(0 === s.filter((e => e.needSync)).length && r.dumpTs <= t)) {
                            this._syncronizigInProcess = !0;
                            try {
                                let o = [];
                                if (r.dumpTs <= t)
                                    o = s.filter((e => !e.needSync || e.needSync && e.syncType !== oe.delete));
                                else {
                                    const e = await this.$services.apiUserStorage.getData([{
                                        path: r.dumpFiles[0].path
                                    }]);
                                    if (!Array.isArray(e) || 0 === e.length)
                                        throw new Error(`failed to fetch data at path ${r.dumpFiles[0].path}`);
                                    let n = null;
                                    try {
                                        n = JSON.parse(this.$helper.base64.decode(e[0].file))
                                    } catch (e) {
                                        wb.spa.logError(e, `[FAVS_SYNC]: latest file is corrupted, file=${r.dumpFiles[0].path}`, !0)
                                    }
                                    if (Array.isArray(n)) {
                                        let e = n.map((e => ue.convertFromUserStorageItemToCacheItem(e)));
                                        o = await this.mergeActualAndCacheItems(e, t, r.dumpTs),
                                        a = this._itemsAreMatched(e, o)
                                    } else
                                        o = s.filter((e => !e.needSync || e.needSync && e.syncType !== oe.delete))
                                }
                                if (a)
                                    n = r.dumpTs;
                                else {
                                    const t = this.$helper.base64.encode(JSON.stringify(o.map((e => ue.convertFromCacheItemToUserStorageItem(e)))))
                                      , s = [{
                                        path: Ce,
                                        file: t
                                    }]
                                      , a = await this.$services.apiUserStorage.setData(s);
                                    if (!a.success)
                                        throw new Error(`failed to set data reason=${null == (e = a.error) ? void 0 : e.message}`);
                                    {
                                        n = r.dumpTs;
                                        const e = await this._getDumpFilesInfoAsync();
                                        (null == e ? void 0 : e.dumpTs) > 0 && (n = e.dumpTs)
                                    }
                                }
                                await this._cacheHelper.setFavoriteGoods(o.map((e => (e.needSync = !1,
                                e))))
                            } catch (e) {
                                wb.spa.logError(e, "[FAVS_SYNC]: sync failed", !0)
                            } finally {
                                this._syncronizigInProcess = !1,
                                await this._cacheHelper.setLastSyncDt(n > 0 ? n : t)
                            }
                        }
                    }
                    ), 3e4))
                }
                _itemsAreMatched(e, t) {
                    return e.map((e => e.characteristicId)).sort(( (e, t) => e - t)).join(",") === t.map((e => e.characteristicId)).sort(( (e, t) => e - t)).join(",")
                }
                _stopSyncronizing() {
                    clearInterval(this._timer)
                }
                _updateSyncStatus(e) {
                    $.observable(this).setProperty({
                        isSynced: e
                    }),
                    WbSpaModel.prototype.$eventBus.dispatchEvent(new CustomEvent("favouritesSynced"))
                }
                _getTimeout(e) {
                    const t = new AbortController;
                    return setTimeout(( () => t.abort()), e),
                    t.signal
                }
                async _getDumpFilesInfoAsync() {
                    try {
                        let e = await this.$services.apiUserStorage.getList("favs", {
                            signal: this._getTimeout(5e3)
                        });
                        if (null == e)
                            return null;
                        const t = {};
                        return t.dumpFiles = e.filter((e => [Ce, "favs/ios_items", "favs/android_items"].indexOf(e.path) > -1)),
                        t.dumpFiles.sort(( (e, t) => t.modify_time - e.modify_time)),
                        t.needsMigration = !e.find((e => e.path === Se || "favs/favs_v2_synced" === e.path)),
                        t.migratedV3 = !!e.find((e => e.path === _e)),
                        t.migratedV3 && localStorage.setItem(this._favV3Key, "1"),
                        t.dumpFiles.forEach((e => {
                            e.modify_time = 1e3 * e.modify_time
                        }
                        )),
                        t.dumpTs = t.dumpFiles.length > 0 ? t.dumpFiles[0].modify_time : 0,
                        t
                    } catch (e) {
                        return null
                    }
                }
                async _migrateFromOldStorageAsync() {
                    const e = await this._loadRawGoodsAsync();
                    if (!e.isEmptyCache) {
                        const t = e.items.map((e => ue.convertFromCacheItemToUserStorageItem(e)))
                          , r = [{
                            path: Ce,
                            file: this.$helper.base64.encode(JSON.stringify(t))
                        }, {
                            path: Se,
                            file: "W10="
                        }];
                        wb.spa.logError(new Error(`[FAVS_SYNC]: sync completed items_synced=${t.length}`)),
                        await this.$services.apiUserStorage.setData(r)
                    }
                }
                async _loadRawGoodsFromDumpAsync(e) {
                    return this._canUseV3() ? await this._loadRawGoodsFromFavsServiceAsync(e) : (await this._loadRawGoodsFromUserStorageAsync(),
                    this._canUseV3() && await this._loadRawGoodsFromFavsServiceAsync(e)),
                    await this._cacheHelper.getFavoriteGoods()
                }
                async _loadRawGoodsFromFavsServiceAsync(e) {
                    await this.dumpFav.sync(e),
                    this._migrateV3FromUserStorageAsync(),
                    this._updateSyncStatus(!0)
                }
                async _migrateV3FromUserStorageAsync() {
                    if (localStorage.hasItem(this._favV3Key))
                        return;
                    const e = await this._getDumpFilesInfoAsync();
                    if (null !== e && !e.migratedV3)
                        if (e.dumpTs > 0) {
                            const t = e.dumpFiles.find((e => e.path === Ce));
                            let r = null;
                            const s = await this.$services.apiUserStorage.getData([{
                                path: t.path
                            }]);
                            if (!Array.isArray(s) || 0 === s.length)
                                throw new Error(`failed to fetch data at path ${t.path}`);
                            try {
                                r = JSON.parse(this.$helper.base64.decode(s[0].file))
                            } catch (e) {
                                throw wb.spa.logError(e, `[FAVS_MIGR]: latest file is corrupted, file=${t.path}`, !0),
                                e
                            }
                            if (!r || !Array.isArray(r))
                                throw "[FAVS_MIGR]: all dump files are corrupted";
                            if (!r.length)
                                return void this._setMigratedV3();
                            const n = r.map((e => ue.convertFromUserStorageItemToCacheItem(e)))
                              , a = (await this._cacheHelper.getFavoriteGoods(!0)).favoritesGoodsMap;
                            n.forEach((e => {
                                a.get(e.characteristicId) || (e.needSync = !0,
                                e.syncType = oe.add,
                                a.set(e.characteristicId, e))
                            }
                            )),
                            await this._cacheHelper.setFavoriteGoods(a.toArray().sort(( (e, t) => t.timestamp - e.timestamp))),
                            await this.dumpFav.sync() && this._setMigratedV3()
                        } else
                            this._setMigratedV3()
                }
                _setMigratedV3() {
                    localStorage.setItem(this._favV3Key, "1"),
                    this.$services.apiUserStorage.setData([{
                        path: _e,
                        file: "W10="
                    }])
                }
                async _loadRawGoodsFromUserStorageAsync() {
                    var e;
                    const t = await this._cacheHelper.getLastSyncDt();
                    let r, s = !1, n = null;
                    try {
                        const e = await this._getDumpFilesInfoAsync();
                        if ((null == e ? void 0 : e.needsMigration) && this._migrateFromOldStorageAsync(),
                        null == e ? void 0 : e.migratedV3)
                            return;
                        if (null != e) {
                            if (t === e.dumpTs || 0 === e.dumpTs)
                                return;
                            let a = 0
                              , o = null;
                            for (; a < e.dumpFiles.length && !(a > 0 && e.dumpFiles[a].modify_time < t); ) {
                                const t = await this.$services.apiUserStorage.getData([{
                                    path: e.dumpFiles[a].path
                                }]);
                                if (!Array.isArray(t) || 0 === t.length)
                                    throw new Error(`failed to fetch data at path ${e.dumpFiles[a].path}`);
                                try {
                                    o = JSON.parse(this.$helper.base64.decode(t[0].file));
                                    break
                                } catch (t) {
                                    wb.spa.logError(t, `[FAVS_SYNC]: latest file is corrupted, file=${e.dumpFiles[a].path}`, !0),
                                    a++,
                                    n = -1
                                }
                            }
                            if (!Array.isArray(o))
                                throw "[FAVS_SYNC]: all dump files are corrupted";
                            r = {
                                favsList: o.map((e => ue.convertFromUserStorageItemToCacheItem(e)))
                            },
                            n = -1 === n ? n : e.dumpTs,
                            s = !0
                        }
                    } catch (e) {
                        if (e.isUnauthorize)
                            return null
                    } finally {
                        !this._cacheHelper.cacheModel && await this._cacheHelper.getFavoriteGoods(),
                        this._updateSyncStatus(!0)
                    }
                    if (!s)
                        return;
                    n = null != n ? n : t;
                    const a = null != (e = null == r ? void 0 : r.favsList) ? e : [];
                    await this._cacheHelper.setFavoriteGoods(await this.mergeActualAndCacheItems(a, t, n)),
                    await this._cacheHelper.setLastSyncDt(n)
                }
                get _favV3Key() {
                    return `${Ie}_${WbSpaModel.prototype.$auth.um.userUid}`
                }
                _canUseV3() {
                    return !0
                }
                resetCache() {
                    this._enrichedFavoriteItems.clear()
                }
            }
              , ke = r(92254);
            var Pe = class {
                constructor() {
                    this.timer = null,
                    this.lastUpdate = -1 / 0,
                    this.userData = (0,
                    ke.O)({}),
                    this.balanceInfo = {},
                    this.loadRequesterPromise = null
                }
                setKey(e, t) {
                    e && (this.USER_INFO_CACHE_KEY_FORMATTED = String.format("user-info-{0}", t))
                }
                getMaskedInfo() {
                    return this._getLocalUserInfo()
                }
                _getLocalUserInfo() {
                    var e;
                    return null != (e = this._masketInfo) ? e : localStorage.getObject(this.USER_INFO_CACHE_KEY_FORMATTED)
                }
                clear() {
                    this.lastUpdate = -1 / 0
                }
                clearLocalUserInfo() {
                    this.USER_INFO_CACHE_KEY_FORMATTED && localStorage.removeItem(this.USER_INFO_CACHE_KEY_FORMATTED)
                }
                async getUserDataAsync(e=!1, t=!1, r=!1) {
                    var s;
                    if (t && this.userData.isAuthenticated && !this.userData.isAuthenticated)
                        return wb.spa.signIn({
                            query: {
                                returnUrl: window.location.href
                            }
                        });
                    this.basicDataTask = null != (s = this.basicDataTask) ? s : this._loadBasicDataInternal(r);
                    const n = this.basicDataTask
                      , [a] = await Promise.all([n]);
                    if (this.basicDataTask = null,
                    t && !this.userData.isAuthenticated)
                        return wb.spa.signIn({
                            query: {
                                returnUrl: window.location.href
                            }
                        });
                    if (a.maskedInfo) {
                        a.maskedInfo.isEmp = a.isEmployeeSynced,
                        this._masketInfo = a.maskedInfo;
                        try {
                            localStorage.putObject(this.USER_INFO_CACHE_KEY_FORMATTED, a.maskedInfo)
                        } catch (e) {}
                    }
                    return {
                        userInfo: a,
                        userExtraInfo: {
                            dataLoaded: !0,
                            discountInfo: {
                                purchase: a.purchaseAmount,
                                personalDiscount: a.personalDiscount,
                                purchasePercent: a.purchasePercent
                            }
                        }
                    }
                }
                async checkAccountsBinding(e, t) {
                    var r, s, n, a, o, i, l, c;
                    if (!this.$auth.isAuth)
                        return !1;
                    const u = await this.$services.userData.getUserDataAsync(!1, !1, t);
                    let d = !1
                      , p = !1
                      , h = !1;
                    for (let t of null == (r = null == u ? void 0 : u.userInfo) ? void 0 : r.contacts)
                        "esiaID" == (null == t ? void 0 : t.contact_type) && e.esiaSignIn && (d = !0),
                        "sberID" == (null == t ? void 0 : t.contact_type) && e.sberIdSignIn && (p = !0),
                        "oneID" == (null == t ? void 0 : t.contact_type) && (h = !0);
                    const m = null == (a = null == (n = null == (s = null == u ? void 0 : u.userInfo) ? void 0 : s.phone) ? void 0 : n.toString()) ? void 0 : a.startsWith("79")
                      , g = null == (l = null == (i = null == (o = null == u ? void 0 : u.userInfo) ? void 0 : o.phone) ? void 0 : i.toString()) ? void 0 : l.startsWith("998")
                      , y = WbSpaModel.prototype.$user.getLocale()
                      , b = wb.settings.currentLocale;
                    let f = !1
                      , v = !1
                      , w = !1;
                    return (m && (null == e ? void 0 : e.esiaSignIn) || d) && (f = !0),
                    (m && (null == e ? void 0 : e.sberIdSignIn) || p) && (v = !0),
                    ((g || "uz" == y || "uz" == b) && ((null == e ? void 0 : e.oneIdSignIn) || (null == e ? void 0 : e.enableOneidForEmployees) && (null == (c = null == u ? void 0 : u.userInfo) ? void 0 : c.isActiveEmployee)) || h) && (w = !0),
                    {
                        showBoundAccountsBlock: !!(f || v || w),
                        activeBindings: {
                            isEsiaBound: d,
                            isSberidBound: p,
                            isOneidBound: h
                        }
                    }
                }
                removeInn() {
                    $.observable(this.userData).setProperty({
                        inn: ""
                    })
                }
                async updateFioAsync(e, t, r) {
                    return (await this._loadRequetser()).updateFioAsync(e, t, r, this.userData)
                }
                async updateSexAsync(e) {
                    return (await this._loadRequetser()).updateSexAsync(e, this.userData)
                }
                async updateBirthdayAsync(e) {
                    return (await this._loadRequetser()).updateBirthdayAsync(e, this.userData)
                }
                async updateEmailAsync(e) {
                    return (await this._loadRequetser()).updateEmailAsync(e, this.userData)
                }
                async updatePhoneMobileAsync(e, t, r) {
                    return (await this._loadRequetser()).updatePhoneMobileAsync(e, t, r, this.userData)
                }
                async updateInnAsync(e) {
                    return (await this._loadRequetser()).updateInnAsync(e, this.userData)
                }
                async updateImageAsync(e) {
                    return (await this._loadRequetser()).updateImageAsync(e, this.userData)
                }
                async removeUserPhotoAsync() {
                    return (await this._loadRequetser()).removeUserPhotoAsync(this.userData)
                }
                async updateSettingsAsync(e, t) {
                    return (await this._loadRequetser()).updateUserSettingsAsync(e, t, this.userData)
                }
                async _loadBasicDataInternal(e) {
                    if (Date.now() - this.lastUpdate < 6e5 && !e)
                        return this.userData;
                    const t = await this._loadRequetser();
                    return this.lastUpdate = Date.now(),
                    t.loadBasicInfo(this.userData, this._getLocalUserInfo())
                }
                async _loadRequetser() {
                    return this.loadRequesterPromise || (this.loadRequesterPromise = this.$moduleLoader.loadModuleAsync("userInfoRequester")),
                    this.loadRequesterPromise
                }
                async migrateProfileFromGlobal() {
                    if (localStorage.hasItem("wbx_to_wb_profile_synced"))
                        return;
                    if (!!(await this.$services.apiUserStorage.getList("profile")).find((e => "profile/info_synced" === e.path)))
                        return;
                    const e = `${this.$services.cartService.publicBasketApiUrl}/lk/account/addresses/migratefromglobal`;
                    try {
                        await this.$httpClient.fetchJSON(e, {
                            method: "POST"
                        }),
                        localStorage.setItem("wbx_to_wb_profile_synced", 1)
                    } catch (e) {
                        wb.spa.logError("[WBX_PROFILE_MIGR]: failed to migrate profile", e)
                    }
                }
            }
              , Te = Object.defineProperty
              , $e = Object.getOwnPropertySymbols
              , Ae = Object.prototype.hasOwnProperty
              , De = Object.prototype.propertyIsEnumerable
              , Ee = (e, t, r) => t in e ? Te(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }) : e[t] = r
              , Be = (e, t, r) => Ee(e, "symbol" != typeof t ? t + "" : t, r);
            const Oe = "_hasUnreadEvents"
              , xe = "/webapi/newsfeed/events";
            class Le extends ke.c {
                constructor() {
                    super(),
                    Be(this, "eventsCount", 0),
                    Be(this, "loading", !0)
                }
            }
            var Fe = class {
                constructor() {
                    this.getMoreUrl = "/webapi/lk/newsfeed/events/spa/loadmore",
                    this.eventsModel = new Le,
                    window.addEventListener("storage", (e => {
                        e.key === Oe && this._fireHasEvent(Number(e.newValue))
                    }
                    ))
                }
                get baseUrl() {
                    return m.YM
                }
                canSendToBell() {
                    var e, t, r;
                    const s = Number(null == (r = null == (t = null == (e = wb.global) ? void 0 : e.settings) ? void 0 : t.variables) ? void 0 : r.bellPercentage);
                    return s > 0 && this.$auth.jwtData.user % 100 < s
                }
                getBellNotifications() {
                    return this.bellFetch("api/v3/notice/get?app_type=web", {
                        method: "POST"
                    })
                }
                getNotifications(e=0) {
                    return this.$httpClient.fetchJSON(this.getMoreUrl, {
                        method: "POST",
                        body: new URLSearchParams({
                            page: e
                        })
                    })
                }
                delete(e) {
                    if (null == e ? void 0 : e.length)
                        return this.bellFetch("api/notice/delete", {
                            method: "POST",
                            body: JSON.stringify({
                                notice_ids: e
                            })
                        })
                }
                preview() {
                    return this.fetch("api/v3/notice/preview", {
                        method: "GET"
                    })
                }
                read(e) {
                    if (null == e ? void 0 : e.length)
                        return this.fetch("api/notice/read", {
                            method: "POST",
                            body: JSON.stringify({
                                notice_ids: e
                            })
                        })
                }
                _fireHasEvent(e) {
                    e && this.$eventBus.dispatchEvent(new CustomEvent("HasUnreadEvents",{
                        detail: {
                            count: e
                        }
                    }))
                }
                async checkNotificationCountAsync() {
                    var e, t;
                    if (this._clearTimer(),
                    !this.$auth.isAuth)
                        return this.eventsModel;
                    let r, s = !1;
                    try {
                        if (this.canSendToBell())
                            r = await this.bellFetch("api/v3/notice/unread?app_type=web", {
                                method: "GET"
                            }),
                            $.observable(this.eventsModel).setProperty({
                                eventsCount: (null == (e = null == r ? void 0 : r.payload) ? void 0 : e.count) || 0
                            }),
                            this.eventsModel.eventsCount = (null == (t = null == r ? void 0 : r.payload) ? void 0 : t.count) || 0;
                        else {
                            const e = await this.$httpClient.fetchJSON(`${xe}/count`, {
                                method: "POST"
                            });
                            $.observable(this.eventsModel).setProperty({
                                eventsCount: e
                            }),
                            this.eventsModel.eventsCount = e
                        }
                        if (this.eventsModel.eventsCount > 0) {
                            this._fireHasEvent(this.eventsModel.eventsCount);
                            try {
                                localStorage.setItem(Oe, this.eventsModel.eventsCount)
                            } catch (e) {}
                        }
                        s = !0
                    } catch (e) {
                        console.error(e),
                        $.observable(this.eventsModel).setProperty({
                            isNetworkError: !0
                        }),
                        this.eventsModel.isNetworkError = !0
                    } finally {
                        return $.observable(this.eventsModel).setProperty({
                            loading: !1
                        }),
                        this.eventsModel.loading = !1,
                        this._startTimer(s),
                        this.eventsModel
                    }
                }
                async markNotificationRead(e) {
                    if (!(null == e ? void 0 : e.length))
                        return;
                    this._clearTimer();
                    let t, r = !1;
                    try {
                        this.canSendToBell() ? await this.bellFetch("api/notice/read", {
                            method: "POST",
                            body: JSON.stringify({
                                notice_ids: e
                            })
                        }) : await this.$httpClient.fetchJSON(`${xe}/mark`, {
                            method: "POST",
                            body: new URLSearchParams({
                                readIds: e.join(";")
                            })
                        }),
                        $.observable(this.eventsModel).setProperty({
                            eventsCount: Math.max(this.eventsModel.eventsCount - e.length, 0)
                        }),
                        this.eventsModel.eventsCount = Math.max(this.eventsModel.eventsCount - e.length, 0),
                        r = !0
                    } catch (e) {
                        t = e,
                        $.observable(this.eventsModel).setProperty({
                            isNetworkError: !0
                        }),
                        this.eventsModel.isNetworkError = !0
                    } finally {
                        this._startTimer(r)
                    }
                    return {
                        isSuccess: r,
                        error: t
                    }
                }
                _clearTimer() {
                    clearTimeout(this.timer)
                }
                _startTimer(e) {
                    this.timer = setTimeout(( () => this.checkNotificationCountAsync()), 9e4)
                }
                bellFetch(e, t={}) {
                    const r = t
                      , {headers: s={}} = r
                      , n = ( (e, t) => {
                        var r = {};
                        for (var s in e)
                            Ae.call(e, s) && t.indexOf(s) < 0 && (r[s] = e[s]);
                        if (null != e && $e)
                            for (var s of $e(e))
                                t.indexOf(s) < 0 && De.call(e, s) && (r[s] = e[s]);
                        return r
                    }
                    )(r, ["headers"])
                      , a = new Headers(s);
                    return a.set("X-Request-ID", wb.helpers.generateGuid()),
                    this.$wbxHttpClient.fetch(`${m.YM}/shard-proxy/${e}`, ( (e, t) => {
                        for (var r in t || (t = {}))
                            Ae.call(t, r) && Ee(e, r, t[r]);
                        if ($e)
                            for (var r of $e(t))
                                De.call(t, r) && Ee(e, r, t[r]);
                        return e
                    }
                    )({
                        headers: a
                    }, n)).then((async e => 204 === e.status ? Promise.resolve(null) : e.ok ? e.json() : void 0))
                }
            }
              , We = Object.defineProperty
              , je = Object.getOwnPropertySymbols
              , Ne = Object.prototype.hasOwnProperty
              , Re = Object.prototype.propertyIsEnumerable
              , Ue = (e, t, r) => t in e ? We(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }) : e[t] = r;
            class He {
                constructor() {
                    this.maxQuantity = 10,
                    this.canBeOrdered = !0,
                    this.includeInOrder = !0
                }
                static fromWbBasketProduct(e) {
                    var t;
                    const r = new He
                      , s = +e.quantity;
                    r.characteristicId = r.id = +e.chrt_id,
                    r.quantity = s > 0 ? s : 1,
                    r.cod1S = e.cod_1s;
                    try {
                        r.meta = e.meta_json ? JSON.parse(e.meta_json) : null
                    } catch (e) {}
                    return r.targetUrl = null == (t = e.target_url) ? void 0 : t.replace(/\x00/g, ""),
                    r.isDeleted = e.is_deleted,
                    r.timestamp = e.client_ts,
                    r._fromSync = !0,
                    r.viewFlags = e.viewFlags,
                    r
                }
                static fromCardModel(e, t, r) {
                    var s, n, a, o, i, l, c, u;
                    const d = new He
                      , p = +e.quantity
                      , h = WbSpaModel.prototype.$analitic.analiticsInfoToListName(( (e, t) => {
                        for (var r in t || (t = {}))
                            Ne.call(t, r) && Ue(e, r, t[r]);
                        if (je)
                            for (var r of je(t))
                                Re.call(t, r) && Ue(e, r, t[r]);
                        return e
                    }
                    )({
                        l: "AAA",
                        lw: "IT"
                    }, e))
                      , m = null == (s = e.meta) ? void 0 : s.analitic
                      , g = (null == m ? void 0 : m.logs) || e.logs || (null == (a = null == (n = e.targetInfo) ? void 0 : n.analiticsInfo) ? void 0 : a.logs) || "";
                    m && g && (m.logs = g),
                    e.meta || (e.meta = {}),
                    e.meta.analitic = m;
                    const y = WbSpaModel.prototype.$user.getUserGradeFromCache();
                    if (d.characteristicId = d.id = +e.characteristicId,
                    d.quantity = p > 0 ? p : 1,
                    d.maxQuantity = (null == t ? void 0 : t.totalQuantity) || 10,
                    d.cod1S = e.cod1S,
                    d.targetUrl = `EX|${e.iid || "1"}|${h}|${g}`,
                    d.priceWithCoupon = d.priceWithCouponAndDiscount = d.priceWithCouponAndSpp = d.priceWithSale = d.price = e.priceWithCouponAndDiscount,
                    d.subjectId = e.subjectId,
                    d.subjectParentId = e.subjectParentId,
                    d.supplierId = e.supplierId,
                    d.supplierName = e.supplier,
                    d.reviewRating = e.reviewRating,
                    d.feedbacks = e.feedbacks || e.commentsCount,
                    d.meta = e.meta,
                    d.timestamp = Date.now() / 1e3 | 0,
                    d.viewFlags = (null == t ? void 0 : t.viewFlags) || e.viewFlags,
                    t) {
                        if (d.brandName = t.brand,
                        d.goodsName = t.name,
                        d.colorName = t.colorName || t.color,
                        d.promos = t.promotions,
                        d.isUnrefusable = t.isUnrefusable,
                        d.isPrepaid = t.isPrepaid,
                        d.isUnreturnable = t.isUnreturnable,
                        d.isVerificationReturn = t.isVerificationReturn,
                        d.logisticsCost = t.logisticsCost,
                        d.payloadV2 = t.payloadV2,
                        d.whDtype = null != (o = t.whDtype) ? o : t.dtype,
                        d.catalogReturnCost = null != (l = t.returnCost) ? l : null == (i = t.catalogPrice) ? void 0 : i.return,
                        d.saleConditions = t.saleConditions,
                        t.panelPromoId && (d.panelPromoId = t.panelPromoId),
                        t.feedbacks && (d.feedbacks = t.feedbacks),
                        t.reviewRating && (d.reviewRating = t.reviewRating),
                        t.deliveryHours && (d.deliveryHours = t.deliveryHours),
                        t.catalogPrice ? (d.price = d.priceWithCoupon = t.catalogPrice.basic / 100,
                        d.salePrice = d.priceWithSale = d.priceWithCouponAndDiscount = d.priceWithCouponAndSpp = t.catalogPrice.total / 100,
                        d.sale = t.catalogPrice.sale) : (d.priceWithSale = t.salePrice,
                        d.sale = t.sale),
                        WbSpaModel.prototype.$useCatalogReturnCost() && (d.returnCost = Math.round(d.catalogReturnCost / 100),
                        4 == (null == y ? void 0 : y.version))) {
                            const e = 16 & d.whDtype || 32 & d.whDtype ? 1 : y.return_fee;
                            d.returnCost = Math.min(d.priceWithCouponAndDiscount, d.returnCost * e)
                        }
                        const e = null == (c = t.sizes) ? void 0 : c.find((e => e.ch === d.id));
                        if (e && (d.sizeName = e.nm,
                        d.stocks = e.stocks,
                        e.deliveryHours && (d.deliveryHours = e.deliveryHours),
                        d.payloadV2 = e.payloadV2,
                        d.whDtype = null != (u = e.whDtype) ? u : e.dtype,
                        e.returnCost && (d.catalogReturnCost = e.returnCost),
                        e.logisticsCost && (d.logisticsCost = e.logisticsCost),
                        e.saleConditions && (d.saleConditions = e.saleConditions),
                        e.catalogPrice ? (d.price = d.priceWithCoupon = e.catalogPrice.basic / 100,
                        d.salePrice = d.priceWithSale = d.priceWithCouponAndDiscount = e.catalogPrice.total / 100,
                        d.sale = e.catalogPrice.sale) : e.salePrice && e.salePrice != d.priceWithCouponAndDiscount && (d.priceWithCoupon = d.priceWithCouponAndDiscount = d.priceWithCouponAndSpp = d.priceWithSale = d.price = e.salePrice),
                        e.saleConditions && wb.xnm.expandSaleConditions(d, e),
                        WbSpaModel.prototype.$useCatalogReturnCost() && e.returnCost && (d.returnCost = Math.round(d.catalogReturnCost / 100),
                        4 == (null == y ? void 0 : y.version)))) {
                            const e = 16 & d.whDtype || 32 & d.whDtype ? 1 : y.return_fee;
                            d.returnCost = Math.min(d.priceWithCouponAndDiscount, d.returnCost * e)
                        }
                    }
                    return r && (d.stocks = r),
                    d.stocks && (d.maxQuantity = d.stocks.sumBy((e => e.qty))),
                    d.canBeOrdered = d.maxQuantity > 0,
                    d
                }
                static fromBasketInputExtended(e) {
                    const t = He.fromCardModel(e, null, e.stocks);
                    return t.price = e.price,
                    t.colorName = e.colorName,
                    t.goodsName = e.goodsName,
                    t.sizeName = e.sizeName,
                    t.viewFlags = e.viewFlags,
                    t
                }
                static enrichCatalogGood(e, t={}) {
                    var r, s, n, a, o, i, l;
                    if (!e)
                        return;
                    const c = null == (r = t.sizes) ? void 0 : r.find((t => t.optionId === e.characteristicId))
                      , u = null != (n = null == (s = null == c ? void 0 : c.stocks) ? void 0 : s.some((e => e.qty > 0))) && n
                      , d = null != (a = null == c ? void 0 : c.price) ? a : t.price;
                    if (e.brandName = t.brand,
                    e.goodsName = t.name,
                    e.colorName = null == (i = null == (o = t.colors) ? void 0 : o[0]) ? void 0 : i.name,
                    e.canBeOrdered = u,
                    e.price = u ? d.basic / 100 : 0,
                    e.priceWithSale = u ? d.total / 100 : 0,
                    e.priceWithCoupon = u ? d.basic / 100 : 0,
                    e.priceWithCouponAndDiscount = d.total / 100,
                    e.sale = u ? d.sale : 0,
                    e.totalSale = u ? d.sale : 0,
                    e.salePrice = u ? d.total / 100 : 0,
                    e.sizeName = null != (l = null == c ? void 0 : c.origName) ? l : "",
                    e.stocks = null == c ? void 0 : c.stocks,
                    e.stocks && (e.maxQuantity = e.stocks.sumBy((e => e.qty))),
                    e.subjectId = t.subjectId,
                    e.subjectParentId = t.subjectParentId,
                    e.supplierId = t.supplierId,
                    e.supplierName = t.supplier,
                    e.volume = t.volume,
                    e.reviewRating = t.reviewRating,
                    e.feedbacks = t.feedbacks || t.commentsCount,
                    e.promos = t.promotions,
                    e.isUnrefusable = t.isUnrefusable,
                    e.isPrepaid = t.isPrepaid,
                    e.isUnreturnable = t.isUnreturnable,
                    e.isVerificationReturn = t.isVerificationReturn,
                    e.priceWithCouponAndSpp = e.priceWithCouponAndDiscount,
                    e.catalogReturnCost = d.return,
                    WbSpaModel.prototype.$useCatalogReturnCost()) {
                        e.returnCost = Math.round(d.return / 100);
                        const t = WbSpaModel.prototype.$user.getUserGradeFromCache();
                        if (4 == (null == t ? void 0 : t.version)) {
                            const r = 16 & e.whDtype || 32 & e.whDtype ? 1 : t.return_fee;
                            e.returnCost = Math.min(e.priceWithCouponAndDiscount, e.returnCost * r)
                        }
                    }
                    return e.logisticsCost = d.logistics || 0,
                    e.priceBasic = d.basic,
                    e.priceTotal = d.total,
                    e.whDtype = null == c ? void 0 : c.dtype,
                    e.payloadV2 = null == c ? void 0 : c.payload,
                    e.saleConditions = null == c ? void 0 : c.saleConditions,
                    e.viewFlags = t.viewFlags,
                    t.panelPromoId && (e.panelPromoId = t.panelPromoId),
                    e
                }
                static enrichStaticGood(e, t={}) {
                    if (e)
                        return e.goodsName = t.n || e.goodsName || "Название не указано",
                        e.colorName = t.c || e.colorName,
                        e
                }
            }
            var qe = He;
            var Ve = class {
                constructor(e, t) {
                    this.settings = {},
                    this.paymentTypes = [e ? {
                        userGrade: 0,
                        bankCards: [{
                            id: "_newcardid",
                            name: "Привязать карту",
                            createNew: !0,
                            system: "bindnew"
                        }],
                        isOnline: !0,
                        isCreditCard: !0,
                        codeLower: "crd",
                        name: "Оплата картой",
                        id: "63",
                        available: !0
                    } : {
                        isOnline: !0,
                        isCreditCard: !0,
                        codeLower: "crd",
                        name: "Оплата картой",
                        id: "63",
                        available: !0
                    }],
                    this.deliveryWay = "self",
                    this.basketItems = null != t ? t : []
                }
                static calc(e) {
                    e.basketItems.forEach((e => {
                        e.stocks && (e.maxQuantity = e.stocks.sumBy((e => e.qty))),
                        e.maxQuantity > 0 && e.maxQuantity < e.quantity ? e.partQuantity = e.maxQuantity : e.partQuantity = null,
                        e._qnt = e.partQuantity || e.quantity,
                        wb.global.settings.switches.dontIncludeSoldItemsInOrder && !e.maxQuantity && (e.includeInOrder = !1)
                    }
                    ));
                    const t = e.basketItems.filter((e => e.maxQuantity > 0));
                    return 1 === t.length && (t[0].includeInOrder = !0),
                    e.totalQuantity = e.basketItems.sumBy((e => e._qnt)),
                    e
                }
            }
            ;
            const ze = 256;
            class Ge {
                constructor(e, t, r, s, n) {
                    this.chrt_id = +t;
                    const a = +r;
                    this.quantity = a > 0 ? a : 1,
                    this.cod_1s = s,
                    this.client_ts = n || Date.now() / 1e3 | 0,
                    this.op_type = e || 1
                }
                static fromLocalBasket(e, t) {
                    const r = new Ge(t,e.characteristicId,e.quantity,e.cod1S,e.timestamp);
                    return r.client_ts > 1e12 && (r.client_ts = r.client_ts / 1e3 | 0),
                    r.target_url = e.targetUrl,
                    e.meta && (r.meta_json = JSON.stringify(e.meta)),
                    r
                }
                static toUpdate(e) {
                    return Ge.fromLocalBasket(e, 2)
                }
                static toDelete(e) {
                    return new Ge(3,e)
                }
            }
            var Qe = Ge;
            const Je = "wb___basketStorage"
              , Ke = {
                ts: 0,
                c_ts: 0,
                operations: new Map
            };
            var Xe = class {
                constructor(e) {
                    window.addEventListener("storage", (e => {
                        e.key === this._basketKey && this._pull()
                    }
                    )),
                    WbSpaModel.prototype.$eventBus.addEventListener("onUserAuth", this._pull.bind(this)),
                    this.getLocalItems = e,
                    this._data = Ke
                }
                checkBug() {
                    this._data.ts > 10 && WbSpaModel.prototype.$auth.um.userUid && !localStorage.hasItem(`wb_basket_${WbSpaModel.prototype.$auth.um.userUid}`) && (wb.spa.logError(new Error(`[WB_BASKET_STORAGE]: key wb_basket_${WbSpaModel.prototype.$auth.um.userUid} notfound`), {
                        ts: this.ts,
                        opLen: this._data.operations.size,
                        hasKey: localStorage.hasItem(this._basketKey)
                    }),
                    this._data.ts = 10)
                }
                get _basketKey() {
                    return `${Je}_${WbSpaModel.prototype.$auth.um.userUid}`
                }
                get clientTs() {
                    return this._data.c_ts
                }
                get ts() {
                    return this._data.ts
                }
                hasOperations() {
                    return !!this._data.operations.size
                }
                getOperations() {
                    return this.ts || (this._data.operations.clear(),
                    this.getLocalItems().forEach((e => {
                        this._data.operations.set(e.chrt_id, e)
                    }
                    ))),
                    this._data.operations.toArray()
                }
                setTs(e) {
                    e && (this._data.ts = e,
                    this._push())
                }
                setClientTs(e) {
                    this._data.c_ts = e,
                    this._push()
                }
                _mergeOp(e, t) {
                    return (null == e ? void 0 : e.chrt_id) === t.chrt_id && (1 === e.op_type && 2 === t.op_type && (t.op_type = 1),
                    2 === e.op_type && 2 === t.op_type && (t.meta = t.meta || e.meta,
                    t.quantity = t.quantity || e.quantity)),
                    t
                }
                normalize(e, t) {
                    e.forEach((e => {
                        const t = this._data.operations.get(e.chrt_id);
                        t.quantity === e.quantity && t.client_ts === e.client_ts && t.op_type === e.op_type && this._data.operations.delete(e.chrt_id)
                    }
                    ));
                    let r = [];
                    return (null == t ? void 0 : t.length) > 0 && (t.forEach((e => {
                        const t = this._data.operations.get(e.chrt_id);
                        if (t) {
                            if (!e.is_deleted)
                                return;
                            if (1 === t.op_type)
                                return;
                            this._data.operations.delete(e.chrt_id)
                        }
                        r.push(e)
                    }
                    )),
                    this._push()),
                    r
                }
                update(e) {
                    if ((null == e ? void 0 : e.length) > 0) {
                        for (let t = 0; t < e.length; t++) {
                            const r = e[t].chrt_id;
                            this._data.operations.set(r, this._mergeOp(this._data.operations.get(r), e[t]))
                        }
                        this._push()
                    }
                }
                clear() {
                    localStorage.removeItem(Je)
                }
                _pull() {
                    const e = localStorage.getObject(this._basketKey) || localStorage.getObject(Je);
                    e && (e.operations = Array.isArray(e.operations) ? new Map(e.operations.map((e => [e.chrt_id, e]))) : Ke.operations),
                    this._data = null != e ? e : Ke
                }
                _push() {
                    try {
                        const e = this._data.operations.toArray();
                        localStorage.putObject(this._basketKey, {
                            ts: this._data.ts,
                            c_ts: this._data.c_ts,
                            operations: e
                        }),
                        localStorage.hasItem(Je) && localStorage.putObject(Je, {
                            ts: this._data.ts,
                            c_ts: this._data.c_ts,
                            operations: e
                        })
                    } catch (e) {}
                }
            }
            ;
            const Ye = m.F3;
            var Ze = class {
                constructor(e) {
                    this.localBasket = e,
                    this.storage = new Xe(( () => this.localBasket.getItems().map((e => Qe.fromLocalBasket(e))))),
                    this.debounceSync = this.$helper.debounce(this._sync.bind(this), 3e3),
                    this.debounceShortSync = this.$helper.debounce(this._sync.bind(this), 1e3),
                    setTimeout(( () => this._backupBasketAsync()), 11e3)
                }
                unAuth() {
                    this.storage.clear()
                }
                onBeforeSignOut() {
                    this.storage.hasOperations() && this._sync()
                }
                addItem(e) {
                    e && (this.storage.update([Qe.fromLocalBasket(e)]),
                    this.debounceShortSync())
                }
                addManyItems(e) {
                    e.length && (this.storage.update(e.map((e => Qe.fromLocalBasket(e)))),
                    this.debounceShortSync())
                }
                clearItems(e) {
                    e.length && (this.storage.update(e.map((e => Qe.toDelete(e)))),
                    this.debounceShortSync())
                }
                updateItem(e) {
                    if (!e)
                        return;
                    const t = this.localBasket.getItems().find((t => t.characteristicId === e));
                    t && this.storage.update([Qe.toUpdate(t)]),
                    this.debounceSync()
                }
                refresh(e, t) {
                    var r, s, n, a;
                    if ("remove" === t) {
                        const t = null != (a = null != (n = null == (r = e.chrtIds) ? void 0 : r[0]) ? n : null == (s = e.items) ? void 0 : s[0].chrtId) ? a : e.chrtId;
                        t > 0 && this.storage.update([Qe.toDelete(t)])
                    } else
                        "recalc" === t && this.updateItem(e.chrtId);
                    this.debounceSync()
                }
                async sync(e, t) {
                    return await this._sync(e, t)
                }
                async _sync(e, t) {
                    return await navigator.locks.request("lock-basket-sync", (async r => {
                        this.storage.checkBug();
                        const s = this.storage.getOperations();
                        if (t && !s.length && this.storage.clientTs > (Date.now() / 1e3 | 0))
                            return !1;
                        const n = this.$services.sessionService.getSession();
                        try {
                            const t = await this._doSync({
                                sessionId: n,
                                operations: s,
                                signal: e
                            });
                            if (this._sendMetrics(t.state),
                            0 === t.state && t.change_ts > 0)
                                return this._updateProducts(t, s);
                            if (1 === t.state) {
                                const e = this.localBasket.getItems().map((e => Qe.fromLocalBasket(e)))
                                  , t = await this._doSync({
                                    sessionId: n,
                                    operations: e,
                                    rememberMe: !0
                                });
                                if (0 === t.state && t.change_ts > 0)
                                    return this._updateProducts(t, s)
                            } else
                                t && wb.spa.logError(new Error(`[WB_BASKET_SYNC]: sync state:${t.state}`), {
                                    result: t,
                                    ts: this.storage.ts,
                                    deviceId: n,
                                    opLen: s.length,
                                    hasJwt: this.$auth.isAuth
                                })
                        } catch (e) {
                            const t = !e.isCustomError && e instanceof TypeError && ("Failed to fetch" === e.message || "NetworkError when attempting to fetch resource." === e.message || "Cancelled" === e.message);
                            this._sendMetrics(t ? "network" : "error"),
                            wb.spa.logError(new Error(`[WB_BASKET_SYNC]: ${e.message}`), {
                                ts: this.storage.ts,
                                deviceId: n,
                                opLen: s.length,
                                hasJwt: this.$auth.isAuth
                            })
                        }
                        return !1
                    }
                    ))
                }
                _updateProducts(e, t) {
                    const r = this.storage.normalize(t, e.result_set);
                    return this.localBasket.updateWbProducts(r),
                    this.storage.setTs(e.change_ts),
                    this.storage.setClientTs(235 + (Date.now() / 1e3 | 0)),
                    e.change_ts > 0
                }
                _doSync({sessionId: e, operations: t, rememberMe: r=!1, signal: s=null}) {
                    return this.$wbxHttpClient.fetch(`${Ye}/sync?ts=${this.storage.ts}&device_id=${e}${r ? "&remember_me=true" : ""}`, {
                        method: "POST",
                        body: JSON.stringify(t),
                        headers: {
                            "Content-Type": "application/json",
                            "Wb-AppType": "site"
                        },
                        signal: s
                    }).then((async e => e.ok ? e.json() : {})).then((e => (e.result_set && (e.result_set = e.result_set[0] || []),
                    e)))
                }
                _sendMetrics(e) {
                    if (!window._debug)
                        try {
                            this.$httpClient.fetch(`/webapi/logging/wbbasket/metrics?status=${e}`, {
                                method: "POST"
                            })
                        } catch (e) {}
                }
                _backupBasketAsync() {
                    if (this.storage.ts <= 0)
                        return;
                    const e = this.localBasket.getItems().map((e => {
                        let t = Qe.fromLocalBasket(e);
                        return delete t.op_type,
                        t
                    }
                    ))
                      , t = [{
                        path: "/cart/wb_backup",
                        file: this.$helper.base64.encode(JSON.stringify(e))
                    }];
                    this.$services.apiUserStorage.setData(t)
                }
            }
            ;
            var et = class {
                constructor(e) {
                    var t, r, s, n;
                    this.characteristicId = +e.characteristicId;
                    const a = +e.quantity;
                    this.quantity = a > 0 ? a : 1,
                    this.cod1S = e.cod1S,
                    this.customsFeeAmount = e.customCharges,
                    this.targetUrl = null == (t = e.targetUrl) ? void 0 : t.replace(/\x00/g, ""),
                    this.includeInOrder = e.includeInOrder,
                    this.dstOffice = e.dstOffice,
                    this.storeName = e.storeName,
                    this.isLargeItem = e.isLargeItem,
                    this.couponSale = e.couponSale,
                    this.goodsName = e.goodsName,
                    this.colorName = e.colorName,
                    this.sizeName = e.sizeName,
                    this.brandName = e.brandName,
                    this.sale = e.sale,
                    this.salePrice = e.salePrice,
                    this.totalSale = e.totalSale,
                    this.personalDiscount = e.personalDiscount,
                    this.returnCost = e.returnCost,
                    this.premiumSaleAmount = e.premiumSaleAmount ? e.premiumSaleAmount : 0,
                    this.price = e.price,
                    this.priceWithSale = e.priceWithSale,
                    this.priceWithCoupon = e.priceWithCoupon,
                    this.priceWithCouponAndSpp = e.priceWithCouponAndSpp + this.premiumSaleAmount,
                    this.priceWithCouponAndDiscount = e.priceWithCouponAndDiscount + this.premiumSaleAmount,
                    this.paymentSaleAmount = e.paymentSaleAmount,
                    this.subjectId = e.subjectId,
                    this.subjectRoot = e.subjectParentId,
                    this.reviewRating = e.reviewRating,
                    this.commentsCount = e.commentsCount || e.feedbacks,
                    this.payloadV2 = e.payloadV2,
                    this.logisticsCost = e.logisticsCost,
                    this.whDtype = e.whDtype,
                    this.supplierId = e.supplierId,
                    this.supplierName = e.supplierName,
                    this.saleConditions = e.saleConditions,
                    this.catalogReturnCost = e.catalogReturnCost,
                    this.maxQuantity = e.maxQuantity,
                    this.volume = e.volume,
                    this.storeIds = (null == (s = null == (r = e.stocks) ? void 0 : r.filter((e => e.qty > 0))) ? void 0 : s.map((e => e.wh))) || [],
                    this.stocks = null == (n = e.stocks) ? void 0 : n.reduce(( (e, t) => (e[t.wh] = {
                        storeId: t.wh,
                        quantity: t.qty || 0,
                        time1: t.time1,
                        time2: t.time2,
                        priority: t.priority
                    },
                    e)), {}),
                    this.timestamp = e.timestamp,
                    this.shadeModel = e.shadeModel
                }
            }
            ;
            const tt = class {
                constructor(e, t, r) {
                    this._isAuth = e,
                    this.sessionService = t,
                    this.$eventBus = r,
                    this.$eventBus.addEventListener("onUserAuth", this.clearMemory.bind(this))
                }
                get isAuth() {
                    return this._isAuth()
                }
                clearMemory() {
                    this.innerStorage = new Ve(this.isAuth,[])
                }
                migrate() {
                    if (localStorage.hasItem("_basket")) {
                        const e = this._getGuestBasket();
                        return e.basketItems && e.basketItems.reverse(),
                        this.addManyItems(e.basketItems, !0),
                        this._detGuestBasket(),
                        e.basketItems
                    }
                    return []
                }
                addManyItems(e, t) {
                    if (!(null == e ? void 0 : e.length))
                        return {
                            isSuccess: !1,
                            error: "[basket] Неизвестная ошибка"
                        };
                    const r = this._syncFrom();
                    if (!t && r.basketItems.length + e.length > ze)
                        return {
                            isSuccess: !1,
                            error: String.format("Вы не можете добавить в корзину больше {0}", $.views.converters.pluralize(ze, "{0} товар", "{0} товара", "{0} товаров"))
                        };
                    let s = !0;
                    const n = r.basketItems.filter((e => e.maxQuantity > 0)).every((e => e.includeInOrder));
                    for (let t = 0; t < e.length; t++) {
                        const a = r.basketItems.findIndex((r => r.characteristicId === e[t].characteristicId));
                        -1 === a ? (s = !1,
                        e[t].timestamp <= this.lastTs && (e[t].timestamp = this.lastTs + 1),
                        e[t].includeInOrder = n,
                        r.basketItems.unshift(e[t])) : r.basketItems[a].timestamp > 0 && (e[t].timestamp = r.basketItems[a].timestamp,
                        e[t].quantity = r.basketItems[a].quantity)
                    }
                    this._syncTo();
                    return {
                        isExist: s,
                        isSuccess: !0,
                        xnmDictTask: this._enrichProducts(r.basketItems.map((e => e.cod1S)))
                    }
                }
                clearItems(e) {
                    if ((null == e ? void 0 : e.length) > 0) {
                        const t = this._syncFrom();
                        t.basketItems = t.basketItems.filter((function(t) {
                            return -1 === e.indexOf(t.characteristicId)
                        }
                        )),
                        this._syncTo()
                    }
                }
                get lastTs() {
                    var e, t;
                    return null == (t = null == (e = this.innerStorage.basketItems) ? void 0 : e[0]) ? void 0 : t.timestamp
                }
                add(e) {
                    const t = this._syncFrom();
                    if (t.basketItems.length + 1 > ze)
                        return {
                            isSuccess: !1,
                            error: String.format("Вы не можете добавить в корзину больше {0}", $.views.converters.pluralize(ze, "{0} товар", "{0} товара", "{0} товаров"))
                        };
                    const r = t.basketItems.find((t => t.characteristicId === e.characteristicId));
                    r ? r.timestamp > 0 && (e.timestamp = r.timestamp,
                    e.quantity = r.quantity) : (e.timestamp <= this.lastTs && (e.timestamp = this.lastTs + 1),
                    e.includeInOrder = t.basketItems.filter((e => e.maxQuantity > 0)).every((e => e.includeInOrder)),
                    t.basketItems.unshift(e)),
                    this._syncTo();
                    return {
                        isExist: !!r,
                        isSuccess: !0,
                        xnmDictTask: this._enrichProducts(t.basketItems.map((e => e.cod1S)))
                    }
                }
                updateMeta(e, t) {
                    if (!e || !t)
                        return !1;
                    const r = this._syncFrom().basketItems.find((t => t.characteristicId === e));
                    return !!r && (r.meta = WbSpaModel.prototype.$helper.deepMerge(r.meta || {}, t),
                    this._syncTo(),
                    !0)
                }
                refresh(e, t) {
                    var r, s, n, a, o, i, l;
                    const c = this._syncFrom();
                    if ("remove" === t) {
                        const t = (null == (r = e.chrtIds) ? void 0 : r.length) > 0 ? e.chrtIds[0] : e.chrtId;
                        c.basketItems = c.basketItems.filter((function(e) {
                            return e.characteristicId !== t
                        }
                        ))
                    } else if ("recalc" === t && e.quantity > 0) {
                        const t = c.basketItems.find((t => t.characteristicId === e.chrtId));
                        t && (t.quantity = e.quantity)
                    }
                    !e.isBuyItNowMode && e.includeInOrderMap && c.basketItems.forEach((t => {
                        e.includeInOrderMap.has(t.id) && (t.includeInOrder = e.includeInOrderMap.get(t.id))
                    }
                    )),
                    c.deliveryWay = e.deliveryWay;
                    let u = WbSpaModel.prototype.$services.userAddressService.get(e.addressId, e.deliveryWay);
                    u && (null == (s = c.deliveryPoint) ? void 0 : s.addressId) !== u.addressId && (c.deliveryPoint = u,
                    c.deliveryPriceModel = null),
                    e.paymentTypeId && e.paymentTypeId !== (null == (n = c.paymentType) ? void 0 : n.id) && (c.paymentType = c.paymentTypes.find((t => t.id === e.paymentTypeId && t.available))),
                    (null == (a = c.paymentType) ? void 0 : a.isCreditCard) && e.bankCardId && e.bankCardId !== (null == (o = c.paymentType) ? void 0 : o.bankCardId) && (c.paymentType.bankCardId = e.bankCardId,
                    c.paymentType.selectedBankCard = null == (l = null == (i = c.paymentTypes.find((e => e.isCreditCard))) ? void 0 : i.bankCards) ? void 0 : l.find((t => t.id === e.bankCardId))),
                    this._syncTo()
                }
                deleteCards(e) {
                    var t;
                    if (!e)
                        return;
                    const r = null == (t = this._syncFrom().paymentTypes) ? void 0 : t.find((e => e.isCreditCard));
                    r && (r.bankCards = (r.bankCards || []).filter((t => -1 === e.indexOf(t.id)))),
                    this._syncTo()
                }
                setCardDefault(e) {
                    this.getBankCards().forEach((t => {
                        t.default = t.id === e
                    }
                    )),
                    this._syncTo()
                }
                setAddress(e, t) {
                    var r;
                    const s = this._syncFrom();
                    let n = WbSpaModel.prototype.$services.userAddressService.get(e, t);
                    n && (null == (r = s.deliveryPoint) ? void 0 : r.addressId) !== n.addressId && (s.deliveryWay = t,
                    s.deliveryPoint = n,
                    s.deliveryPriceModel = null,
                    this._syncTo())
                }
                getBankCards() {
                    var e, t;
                    return (null == (t = null == (e = this._syncFrom().paymentTypes) ? void 0 : e.find((e => e.isCreditCard))) ? void 0 : t.bankCards) || []
                }
                async getPaymentsForDeliveries(e) {
                    var t;
                    const {payments: r} = await this.$httpClient.fetchJSON(`${this.$services.cartService.publicBasketApiUrl}/payment/list/fordeliveriesv2`, {
                        method: "POST",
                        credentials: "include",
                        body: new URLSearchParams({
                            currency: e
                        })
                    }) || {};
                    return null == (t = null == r ? void 0 : r.find((e => "crd" == e.codeLower))) || t.bankCards.forEach((e => {
                        e.isSbp || (e.icon = e.system)
                    }
                    )),
                    r
                }
                getItems() {
                    return this._syncFrom().basketItems
                }
                enrichItemsLocalInfo(e) {
                    const t = this._syncFrom().basketItems.toMap((e => e.id), (e => e));
                    e.forEach((e => {
                        const r = t.get(e.id);
                        (null == r ? void 0 : r.meta) && (e.meta = null == r ? void 0 : r.meta)
                    }
                    ))
                }
                get count() {
                    const e = this._syncFrom();
                    return this.$eventBus.dispatchEvent(new CustomEvent("LocalBasketUpdateCount",{
                        detail: {
                            count: e.totalQuantity
                        }
                    })),
                    e.totalQuantity
                }
                save(e) {
                    const t = this._syncFrom()
                      , r = JSON.parse(JSON.stringify(e, ( (e, t) => "basketItems" === e ? void 0 : t)));
                    r.basketItems = e.basketItems.reduce(( (e, t) => (e.get(t.id) && e.set(t.id, wb.helpers.deepClone(t)),
                    e)), t.basketItems.toMap((e => e.id), (e => e))).toArray(),
                    this._syncTo(r)
                }
                updateIncludeInOrder(e) {
                    if (!e)
                        return;
                    this._syncFrom().basketItems.forEach((t => {
                        e.has(t.id) && (t.includeInOrder = e.get(t.id))
                    }
                    )),
                    this._syncTo()
                }
                get() {
                    return this._syncFrom()
                }
                getDeliveryPoint() {
                    return this._syncFrom().deliveryPoint
                }
                buyItNow(e) {
                    const t = this._syncFrom()
                      , r = t.basketItems.find((t => t.characteristicId == e));
                    if (r) {
                        const e = new Ve(this.isAuth);
                        return e.isBuyItNowMode = !0,
                        r.includeInOrder = !0,
                        e.basketItems.unshift(r),
                        e.deliveryWay = t.deliveryWay,
                        e.deliveryPoint = t.deliveryPoint,
                        e.paymentTypes = t.paymentTypes,
                        e.paymentType = t.paymentType,
                        e.paymentType && (e.paymentType.bankCardId = t.paymentType.bankCardId,
                        e.paymentType.selectedBankCard = t.paymentType.selectedBankCard),
                        Ve.calc(e),
                        e
                    }
                    return t
                }
                enrichProductsIfNeedAsync({force: e}={}) {
                    const t = this._syncFrom();
                    return t.basketItems.length > 0 && t.basketItems.every((e => !e.hasOwnProperty("priceWithCouponAndDiscount") && !e.hasOwnProperty("price"))) || e ? this._enrichProducts(t.basketItems.map((e => e.cod1S))) : Promise.resolve([])
                }
                get basketKey() {
                    return this.isAuth ? `wb_basket_${this.sessionService.getUserUid()}` : "_basket"
                }
                _getGuestBasket() {
                    const e = localStorage.getObject("_basket");
                    return e || new Ve(!1)
                }
                _detGuestBasket() {
                    localStorage.removeItem("_basket")
                }
                _syncFrom() {
                    var e, t, r;
                    try {
                        const r = this.basketKey
                          , s = localStorage.getObject(r);
                        return s ? (this.innerStorage = s,
                        this.innerStorage ? this.innerStorage.basketItems || (this.innerStorage.basketItems = []) : this.innerStorage = new Ve(this.isAuth,[])) : (null == (t = null == (e = this.innerStorage) ? void 0 : e.basketItems) ? void 0 : t.length) || (this.innerStorage = new Ve(this.isAuth,[])),
                        this.isAuth && (localStorage.clearStartsWith("wb_basket_", r),
                        localStorage.clearStartsWith("wb___basketStorage_", `wb___basketStorage_${this.sessionService.getUserUid()}`)),
                        this.innerStorage
                    } catch (e) {
                        return console.error(e),
                        wb.spa.logError(e, "cartService syncfrom"),
                        null != (r = this.innerStorage) ? r : new Ve(this.isAuth)
                    }
                }
                _syncTo(e) {
                    var t;
                    e && (this.innerStorage = e),
                    Ve.calc(this.innerStorage);
                    try {
                        localStorage.putObject(this.basketKey, this.innerStorage)
                    } catch (e) {}
                    this.$eventBus.dispatchEvent(new CustomEvent("LocalBasketUpdateCount",{
                        detail: {
                            count: null == (t = this.innerStorage) ? void 0 : t.totalQuantity
                        }
                    }))
                }
                async _enrichProducts(e) {
                    if (0 === e.length)
                        return {};
                    const [t,r] = await Promise.all([wb.xnm.getXnmProducts(e, !1), wb.xnm.getProductColorsByNmIdsAsync(e)])
                      , s = this._syncFrom();
                    let n = !1;
                    return s.basketItems.forEach((e => {
                        t[e.cod1S] && (qe.enrichCatalogGood(e, t[e.cod1S]),
                        n = !0),
                        r[e.cod1S] && (qe.enrichStaticGood(e, r[e.cod1S]),
                        n = !0)
                    }
                    )),
                    s.currency = WbSpaModel.prototype.$user.getCurrency(),
                    n && this._syncTo(s),
                    t
                }
                updateWbProducts(e) {
                    const t = this._syncFrom();
                    localStorage.hasItem(this.basketKey) || this._syncTo(),
                    (null == e ? void 0 : e.length) && (t.basketItems = [...t.basketItems, ...e.map((e => qe.fromWbBasketProduct(e)))].reduce(( (e, t) => {
                        const r = e.findIndex((e => e.id === t.id));
                        return -1 !== r || t.isDeleted ? -1 !== r && (e[r].timestamp = Math.max(e[r].timestamp, t.timestamp),
                        e[r].quantity = t.quantity,
                        e[r].targetUrl = t.targetUrl,
                        e[r].isDeleted = t.isDeleted,
                        e[r].meta = t.meta) : (t._fromSync && (t.includeInOrder = e.filter((e => e.maxQuantity > 0)).every((e => e.includeInOrder)),
                        delete t._fromSync),
                        e.push(JSON.parse(JSON.stringify(t)))),
                        e
                    }
                    ), []).filter((e => !e.isDeleted)).sort(( (e, t) => t.timestamp - e.timestamp)),
                    this._syncTo())
                }
            }
              , rt = qe;
            var st, nt = class {
                constructor() {}
                get BasketItemViewModel() {
                    return rt
                }
                get BasketItemSharedModel() {
                    return et
                }
                init() {
                    Object.setPrototypeOf(Ze.prototype, WbSpaModel.prototype),
                    this.getBankCards = this.$helper.lockPromise(this.getBankCards),
                    this.localBasket = new tt(( () => this.$auth.isAuth),this.$services.sessionService,this.$eventBus),
                    this.wbBasket = new Ze(this.localBasket),
                    this.srv = this.wbBasket,
                    this.$eventBus.addEventListener("onUserAuth", this.sync.bind(this)),
                    this.$eventBus.addEventListener("onUserUnAuth", this.wbBasket.unAuth.bind(this.wbBasket)),
                    this.$eventBus.addEventListener("onBeforeSignOut", this.wbBasket.onBeforeSignOut.bind(this.wbBasket)),
                    $.observe(this.$router, "activeContainer", "showPreview", ( (e, t) => {
                        document.body.classList.toggle("body-gray", 2 === e.target.activeContainer && !e.target.showPreview)
                    }
                    )),
                    "hidden"in document && "visibilityState"in document && document.addEventListener("visibilitychange", (e => {
                        "visible" === document.visibilityState && this.sync("interval")
                    }
                    ))
                }
                get publicBasketApiUrl() {
                    return "ru" === (e = wb.settings.currentDomain) || "kz" === e ? m.E$ : m.sk + e;
                    var e
                }
                get deliveryWays() {
                    var e, t;
                    let r = [{
                        id: 2,
                        code: "self",
                        name: "Пункт выдачи",
                        calendars: []
                    }, {
                        id: 1,
                        code: "courier",
                        name: "Курьером",
                        calendars: []
                    }];
                    return !1 === (null == (t = null == (e = wb.global.settings) ? void 0 : e.switches) ? void 0 : t.enableCourierDelivery) && (r = r.filter((e => "courier" !== e.code))),
                    r
                }
                async sync(e) {
                    var t;
                    if (this.$auth.isAuth) {
                        let r = new AbortController;
                        return r._dt = (new Date).getTime() + 6e4,
                        (null == e ? void 0 : e.timeout) ? (this.backgroundController && this.backgroundController._dt < (new Date).getTime() ? (this.backgroundController.abort(),
                        this.backgroundController = null) : this.backgroundController && (r = this.backgroundController),
                        setTimeout(( () => r.abort()), e.timeout)) : this.backgroundController = r,
                        this._syncProcess = null != (t = this._syncProcess) ? t : this.srv.sync(r.signal, "interval" === e),
                        this._syncProcess.catch((e => {}
                        )).finally(( () => {
                            this.$auth.isAuth && (this._migrate(),
                            this.localBasket.enrichProductsIfNeedAsync()),
                            this._syncProcess = null,
                            this.backgroundController = null
                        }
                        ))
                    }
                }
                updateMeta(e, t) {
                    t && this.localBasket.updateMeta(e, t) && this.srv.updateItem(e)
                }
                addItem({model: e, product: t, stores: r}) {
                    const s = rt.fromCardModel(e, t, r)
                      , n = this.localBasket.add(s);
                    return this.$auth.isAuth && n.isSuccess && !n.isExist && this.srv.addItem(s),
                    n
                }
                addManyItems(e, t) {
                    if (!(null == e ? void 0 : e.length))
                        return;
                    const r = e.map((e => rt.prototype.isPrototypeOf(e) ? e : rt.fromBasketInputExtended(e)))
                      , s = this.localBasket.addManyItems(r, t);
                    return this.$auth.isAuth && s.isSuccess && !s.isExist && this.srv.addManyItems(r),
                    s
                }
                refresh({data: e, type: t}) {
                    this.localBasket.refresh(e, t),
                    this.$auth.isAuth && t && this.srv.refresh(e, t)
                }
                clearItems(e) {
                    (null == e ? void 0 : e.length) && (this.localBasket.clearItems(e),
                    this.$auth.isAuth && this.srv.clearItems(e))
                }
                getItems() {
                    return this.localBasket.getItems().map((e => new et(e)))
                }
                async getSelectedBankCard() {
                    var e;
                    let t = this.localBasket.getBankCards();
                    const r = null == (e = (await this.$services.userData.getUserDataAsync()).userInfo.phone) ? void 0 : e.toString().startsWith("79");
                    null == t || t.forEach((e => {
                        e.isSbp || (e.icon = e.system,
                        r || "mir" !== e.icon || (e.icon = "none",
                        e.name = e.nameNotPaySystem))
                    }
                    ));
                    const s = t.find((e => e.default));
                    return s || (t = await this.getBankCards(),
                    null == t || t.forEach((e => {
                        e.isSbp || (e.icon = e.system,
                        r || "mir" !== e.icon || (e.icon = "none",
                        e.name = e.nameNotPaySystem))
                    }
                    )),
                    t.find((e => e.default)))
                }
                async getBankCards(e=6e3, t="", r=!1) {
                    var s, n, a;
                    const o = null == (s = (await this.$services.userData.getUserDataAsync()).userInfo.phone) ? void 0 : s.toString().startsWith("79");
                    try {
                        t || (t = this.$user.getCurrency());
                        const s = await this.$user.getUserGrade(t)
                          , i = await this.$httpClient.fetchJSON(`${this.publicBasketApiUrl}/webapi/lk/bankcards`, {
                            method: "POST",
                            credentials: "include",
                            body: this.$helper.objectSerializer({
                                currency: t,
                                userGradeSigned: s,
                                bypassCache: r
                            }, new URLSearchParams, !0, !0)
                        }, {
                            timeout: e
                        });
                        null == (n = null == i ? void 0 : i.maskedCards) || n.forEach((e => {
                            e.isSbp || (e.icon = e.system,
                            o || "mir" !== e.icon || (e.icon = "none",
                            e.name = e.nameNotPaySystem))
                        }
                        ));
                        const l = null != (a = null == i ? void 0 : i.maskedCards) ? a : [];
                        return this.$eventBus.dispatchEvent(new CustomEvent("BankCardsUpdated",{
                            detail: l
                        })),
                        l
                    } catch (e) {}
                }
                async getPaymentsForDeliveries(e) {
                    var t;
                    const {payments: r} = await this.$httpClient.fetchJSON(`${this.$services.cartService.publicBasketApiUrl}/payment/list/fordeliveriesv2`, {
                        method: "POST",
                        credentials: "include",
                        body: new URLSearchParams({
                            currency: e
                        })
                    }) || {};
                    return null == (t = null == r ? void 0 : r.find((e => e.isCreditCard))) || t.bankCards.forEach((e => {
                        e.isSbp || (e.icon = e.system)
                    }
                    )),
                    r
                }
                get localCount() {
                    return this.localBasket.count
                }
                get currentDeliveryType() {
                    return this.localBasket.getDeliveryPoint()
                }
                save(e) {
                    this.localBasket.save(e)
                }
                get(e) {
                    return this.localBasket.get()
                }
                buyItNow(e) {
                    return e ? this.localBasket.buyItNow(e) : this.localBasket.get()
                }
                _migrate() {
                    const e = this.localBasket.migrate();
                    0 !== e.length && this.srv.addManyItems(e)
                }
            }
            , at = r(97929);
            const ot = "by" === (null == (st = wb.settings) ? void 0 : st.currentLocale) ? "Склад поставщика" : "Склад продавца";
            var it = {
                0: ot,
                507: "Коледино WB",
                686: "Новосибирск WB",
                1193: "Хабаровск WB",
                1733: "Екатеринбург WB",
                2737: "Уткина Заводь WB",
                117442: "Калуга WB",
                117501: "Подольск WB",
                117866: "Тамбов WB",
                117986: "Казань WB",
                120762: "Электросталь WB",
                121709: "Электросталь WB",
                130744: "Краснодар WB",
                159402: "Шушары WB",
                161812: "Санкт-Петербург WB",
                172430: "Барнаул WB",
                204615: "Томск WB",
                204939: "Астана WB",
                205104: "Ульяновск WB",
                205205: "Киров WB",
                205228: "Белая дача WB",
                206236: "Белые Столбы WB",
                206348: "Алексин WB",
                206708: "Новокузнецк WB",
                206844: "Калининград WB",
                206968: "Новосёлки WB",
                208277: "Невинномысск WB",
                208941: "Домодедово WB",
                209513: "Домодедово WB",
                210001: "Новосёлки-2 WB",
                210515: "Вёшки WB",
                208768: ot + " Абакан",
                209649: ot + " Алексин",
                208769: ot + " Алматы",
                212038: ot + " Алматы-2",
                209902: ot + " Артём",
                214110: ot + " Архангельск",
                122495: ot + " Астана",
                204492: ot + " Астрахань",
                204493: ot + " Барнаул",
                206239: ot + " Белая Дача (Москва)",
                213892: ot + " Белгород",
                214112: ot + " Белогорск",
                209112: ot + " Белые Столбы",
                208814: ot + " Бишкек",
                204494: ot + " Брянск",
                204495: ot + " Владикавказ",
                117392: ot + " Владимир",
                152588: ot + " Волгоград",
                204496: ot + " Вологда",
                211895: ot + " Воронеж",
                209111: ot + " Гольяново (Москва)",
                208771: ot + " Гомель (Беларусь)",
                210967: ot + " Домодедово",
                208815: ot + " Екатеринбург",
                211790: ot + " Екатеринбург-2",
                208816: ot + " Ереван",
                208772: ot + " Иваново",
                172073: ot + " Ижевск",
                131643: ot + " Иркутск",
                208817: ot + " Казань",
                208761: ot + " Калининград",
                144046: ot + " Калуга",
                208773: ot + " Киров",
                119261: ot + " Коледино",
                209109: ot + " Комсомольский (Москва)",
                208818: ot + " Краснодар",
                118365: ot + " Красноярск",
                208774: ot + " Крыловская (Краснодар)",
                172075: ot + " Курск",
                209108: ot + " Курьяновская (Москва)",
                208776: ot + " Липецк",
                168826: ot + " Лобня (Москва)",
                121700: ot + " Минск",
                211672: ot + " Минск-2",
                212032: ot + " Вешки",
                211730: ot + " Внуково",
                117673: ot + " Москва",
                122259: ot + " Москва",
                208777: ot + " Мурманск",
                208778: ot + " Набережные Челны",
                209107: ot + " Нахабино (Москва)",
                209601: ot + " Невинномысск",
                118535: ot + " Нижний Новгород",
                213651: ot + " Нижний Тагил",
                208789: ot + " Новокузнецк",
                117419: ot + " Новосибирск",
                209591: ot + " Омск",
                208780: ot + " Оренбург",
                157848: ot + " Пенза",
                209592: ot + " Пермь",
                208781: ot + " Печатники",
                214111: ot + " Псков",
                208782: ot + " Пушкино (Москва)",
                204497: ot + " Пятигорск",
                118019: ot + " Ростов-на-Дону",
                152594: ot + " Рязань",
                146666: ot + " Самара",
                132043: ot + " Санкт-Петербург",
                117414: ot + " Санкт-Петербург (Уткина Заводь)",
                208819: ot + " Санкт-Петербург (Шушары)",
                158929: ot + " Саратов",
                204498: ot + " Серов",
                144154: ot + " Симферополь",
                208783: ot + " Смоленск",
                204212: ot + " Солнцево",
                158448: ot + " Ставрополь",
                208784: ot + " Сургут",
                115651: ot + " Тамбов",
                152610: ot + " Тверь",
                208785: ot + " Темрюк (Краснодарский край)",
                208786: ot + " Томск",
                146725: ot + " Тюмень",
                209950: ot + " Ульяновск",
                152700: ot + " Уфа",
                208820: ot + " Хабаровск",
                210815: ot + " Хоргос",
                204499: ot + " Чебоксары",
                152611: ot + " Челябинск",
                209113: ot + " Черная грязь (Москва)",
                209106: ot + " Чертановский (Москва)",
                208787: ot + " Чита",
                209510: ot + " Электросталь",
                209110: ot + " Южные ворота (Москва)",
                152612: ot + " Ярославль"
            };
            const lt = ["ru", "by", "kg", "kz", "am", "uz", "tj"];
            var ct = class {
                isMp(e) {
                    return this._checkStoreFlag(e, 2)
                }
                isCargoStore(e) {
                    return this._checkStoreFlag(e, 4)
                }
                isDbs(e) {
                    return this._checkStoreFlag(e, 8)
                }
                isForeign(e) {
                    return this._checkStoreFlag(e, 16)
                }
                isWbGo(e) {
                    return this._checkStoreFlag(e, 32)
                }
                isExpress(e) {
                    return this._checkStoreFlag(e, 64)
                }
                needVerification(e, t) {
                    return this._checkStoreFlag(e, 1 << this._localeBit(t), "import")
                }
                _checkStoreFlag(e, t, r="type") {
                    var s;
                    return ((null == (s = this[e]) ? void 0 : s[r]) & t) === t
                }
                _localeBit(e) {
                    const t = lt.indexOf(null == e ? void 0 : e.toLowerCase());
                    return Math.max(t, 0)
                }
            }
            ;
            const ut = "wb__cargo_data_dt"
              , dt = 9e5
              , pt = "cargo-stores"
              , ht = "stores-data";
            var mt = class {
                constructor() {
                    this._storeNames = it,
                    this._stores = new ct,
                    this._getCargoStoresAsync().then(( ({storesData: e}) => {
                        if (this._cargoStores = [],
                        e) {
                            for (let {id: t, name: r, type: s, intervals: n, workingHours: a} of e)
                                this._storeNames[t] = r,
                                !0 & s && this._cargoStores.push(t),
                                this._stores[t] = {
                                    name: r,
                                    type: s,
                                    intervals: n,
                                    workingHours: a
                                };
                            this._storesLoaded = !0
                        }
                        this._startJobSync()
                    }
                    ))
                }
                get cargoStores() {
                    return this._cargoStores || []
                }
                get names() {
                    return this._storeNames
                }
                get storesMap() {
                    return this._stores
                }
                _openDb() {
                    return this.$storageHelper.openDb("all-stores", {
                        onupgradeneeded: e => {
                            e.objectStoreNames.contains(pt) || e.createObjectStore(pt, {
                                keyPath: "id"
                            }),
                            e.objectStoreNames.contains(ht) || e.createObjectStore(ht, {
                                keyPath: "id"
                            })
                        }
                        ,
                        version: 2
                    })
                }
                _setStoresAsync(e, t) {
                    this._openDb().then((r => {
                        if (e instanceof Array) {
                            let t = r.transaction([pt], "readwrite").objectStore(pt);
                            t.clear();
                            for (let r = 0; r < e.length; r++)
                                t.add(e[r])
                        }
                        if (t instanceof Array) {
                            const e = r.transaction([ht], "readwrite").objectStore(ht);
                            for (const r of t)
                                e.put(r)
                        }
                    }
                    ))
                }
                async _getCargoStoresAsync() {
                    const e = await this._openDb()
                      , [t,r] = await Promise.all([this.$storageHelper.getAll(e, pt), this.$storageHelper.getAll(e, ht)]);
                    return {
                        cargoStores: t,
                        storesData: r
                    }
                }
                _startJobSync() {
                    (!this._cargoStores || !this._storesLoaded || +localStorage.getItem("wb__cargo_stores_dt") < Date.now() || +localStorage.getItem(ut) < Date.now()) && this._syncStores(),
                    setInterval(this._syncStores.bind(this), dt)
                }
                async _syncStores() {
                    const [e,t] = await Promise.all([this.$httpClient.fetchStaticDataV2("cargo-delivery-stores-v2.json"), this.$httpClient.fetchStaticDataV2("stores-data.json")]);
                    if (t instanceof Array) {
                        if (t instanceof Array) {
                            this._storesLoaded = !0,
                            this._cargoStores = [];
                            for (let {id: e, name: r, type: s, intervals: n=null, workingHours: a=null, import: o} of t)
                                this._storeNames[e] = r,
                                !0 & s && this._cargoStores.push(e),
                                this._stores[e] = {
                                    name: r,
                                    type: s,
                                    intervals: n,
                                    workingHours: a,
                                    import: o
                                };
                            localStorage.setItem(ut, Date.now() + dt)
                        }
                        this._setStoresAsync(e, t)
                    }
                }
            }
            ;
            const gt = [5352, 2255]
              , yt = [1, 2, 3, 4, 6, 200, 204, 1327, 1465, 1513, 1616, 2273, 3497, 4607, 4735]
              , bt = [213, 1542, 2605, 2693, 4733, 4737, 212, 380, 733, 1675, 2687, 4738, 4827, 4932, 214, 2616, 218, 757, 53, 61, 63, 305, 946, 1161, 1422, 1439, 1475, 1487, 2318, 2379, 2747, 2920, 3489, 3490, 3579, 3766, 4200, 4256, 4537, 5154, 5220, 5222, 5273, 5094, 5096, 1339, 836, 5131, 1542, 5095, 4021, 4022, 1338, 2564]
              , ft = [1, 2, 1513, 2692, 2688, 2690, 2691, 2685, 166, 2683, 2686, 2684, 2689, 4732, 4731, 4730, 4729, 4726, 4725, 4724, 4728, 4727, 4723, 6093, 6092, 6094, 6090, 6096, 6095, 6091, 5922, 133, 2048, 74, 75, 409, 76, 132, 5446, 5270, 168, 2649, 191, 155, 185, 163, 5268, 158, 70, 1687, 1641, 215, 170, 173, 1935, 162, 216, 5269, 11, 217, 1629, 1591, 69, 8098, 284, 4377, 149, 172, 180, 161, 1724, 160, 41, 1631, 8239, 159, 193, 157, 219, 233, 4315, 148, 322, 171, 209, 1635, 5271, 313, 156, 38, 285, 394, 174, 1429, 147, 2110, 192, 1791, 177, 151, 184, 153]
              , vt = [786, 1107]
              , wt = [1524, 1525]
              , St = [1, 2, 4, 200, 204, 239, 1513, 5038]
              , _t = "stashed_catalog_product";
            var Ct = class {
                async loadProductCardAsync(e, t, r=!1) {
                    try {
                        const s = this.stashedCatalogProduct;
                        return (null == s ? void 0 : s.nmId) !== e || r || s.currency !== WbSpaModel.prototype.$user.getCurrency() ? this.loadDynamicProductAsync(e, t, await this.loadStaticProductAsync(e)) : this.fromCatalogProduct(s, t)
                    } catch (e) {
                        return null
                    }
                }
                async loadStaticProductAsync(e) {
                    try {
                        const [t] = await Promise.all([this.$httpClient.fetchStaticV3(wb.helpers.url.urlProductStatic, {
                            timeout: 2e3
                        }, e), wb.xnm.waitNoReturnSubjectsInitialized()]);
                        return t
                    } catch (e) {
                        return null
                    }
                }
                async loadDynamicProductAsync(e, t, r, s) {
                    var n, a, o;
                    if (!e || isNaN(parseInt(e)))
                        throw new TypeError("[ProductCardService] nmId must be an integer at loadDynamicProductAsync");
                    t && isNaN(parseInt(t)) && (console.warn("[ProductCardService] chrtId is not an integer at loadDynamicProductAsync"),
                    t = null),
                    r = null != r ? r : await this.loadStaticProductAsync(e);
                    const i = new Map;
                    let l = null != (n = null == r ? void 0 : r.colors) ? n : [e];
                    r && (r.colors = this._colorLimiter(e, l),
                    l = r.colors,
                    i.set(r.nm_id, r));
                    const c = (null == (a = this.$router.queryParams) ? void 0 : a.get("helpKursk")) ? -2307160 : null
                      , u = 1 === l.length && s ? {
                        [e]: s
                    } : await wb.xnm.getXnmProducts(l, !1, c).catch((e => null));
                    let d = null == u ? void 0 : u[e];
                    if (!d)
                        return null;
                    const p = await this._getMultiInfo(d, r)
                      , h = !!p
                      , m = !h && this._canCheckForMulti(r)
                      , g = {}
                      , y = this._fillBaseProductCardFromX(r, d, h || m);
                    y.metacard = p,
                    h && (l = [e]),
                    l.forEach((t => {
                        const r = i.get(t)
                          , s = null == u ? void 0 : u[t];
                        if (s && s.pics > 0) {
                            const n = this._fillNomenclature(t, r, s);
                            n.groupedAddedOptions = y.groupedAddedOptions,
                            n.miniAddedOptions = y.miniAddedOptions,
                            n.verifiedCertificate = this._setVerifiedCertificate(r),
                            e === t && (n.isHelpKursk = new URL(window.location.href).searchParams.get("helpKursk") || window.location.pathname.includes("pomozhem-kursku-vmeste")),
                            y.nomenclatures.push(n)
                        }
                    }
                    )),
                    y.nomenclatures = y.nomenclatures.sort(( (t, r) => t.nmId === e ? -1 : r.nmId === e ? 1 : r.sort - t.sort));
                    const b = y.nomenclatures.find((t => t.nmId === e));
                    if (null == b || null == b.sizes)
                        return null;
                    const f = Object.assign({}, b);
                    return this.fillSelectedNomenclature(f, t),
                    this._addDigitalLinks(f, r),
                    Object.assign(g, {
                        product: y,
                        selectedNomenclature: f
                    }),
                    g.metaTags = this._fillProductCardMetaTags(y),
                    g.promoUrl = this._fillPromoUrl(e, y, r, f.brandId),
                    g.openGraphDescription = this._fillOpenGraphDescription(e, b, g.metaTags),
                    g.targetInfo = null != (o = g.targetInfo) ? o : {},
                    g.selectedNomenclature.goodsName || (g.product.goodsName = "Название не указано"),
                    this._checkGroupedAddedOptionsExist(g.selectedNomenclature.groupedAddedOptions) || (g.selectedNomenclature.groupedAddedOptions = []),
                    g.product.canCheckForMulti = m,
                    g
                }
                async getMultiInfo(e, t) {
                    return this._getMultiInfo(e, t)
                }
                async _getMultiInfo(e, t) {
                    var r;
                    if (!(null == (r = wb.global.settings.switches) ? void 0 : r.multicardV2Enable))
                        return null;
                    const s = e.rcId;
                    if (!s)
                        return null;
                    const n = e.id || e.nmId
                      , [a] = await Promise.all([(async () => null != t ? t : this.loadStaticProductAsync(n))(), this.$moduleLoader.loadServiceAsync("metacardService")])
                      , o = this.$services.metacardService;
                    if (!(null == a ? void 0 : a.rc) || 2 !== a.rc.type || a.rc.id !== s)
                        return null;
                    if (e.metacard && e.metacard.id == s)
                        return e.metacard = o.getMetacardFromExisting(e.metacard, n, a),
                        Promise.resolve(e.metacard);
                    e.metacard = null;
                    return await o.getMetacardData(s, n, a)
                }
                async loadSizeTable(e) {
                    const t = await this.loadStaticProductAsync(e);
                    return this._fillSizeTable(t)
                }
                fromCatalogProduct(e, t) {
                    var r, s, n, a;
                    const o = {}
                      , i = {
                        imtId: e.imtId,
                        nomenclatures: [],
                        supplierDeliveryInfo: {
                            time1: e.time1 || null,
                            time2: e.time2 || null,
                            storeId: e.fastestStore || null
                        },
                        rcId: e.rcId
                    }
                      , l = e.pics
                      , c = 20624 === e.brandId || 30624 === e.siteBrandId
                      , u = {
                        adult: e.adult,
                        brandId: e.brandCod,
                        brandName: e.brand,
                        canFit: this._setCanFit(e.subjectId, e.subjectParentId),
                        tilesVariable: this.canUseTilesVariable(e.subjectId, e.subjectParentId),
                        colorName: null,
                        consist: "",
                        deliveryHours: e.deliveryHours,
                        description: null,
                        markdownDescription: null,
                        dest: e.dest,
                        fastestStore: e.wh || e.fastestStore,
                        feedbacks: e.feedbacks,
                        specs: e.specs,
                        goodsName: e.name,
                        isActivationKey: -1 !== gt.indexOf(e.subjectId),
                        isDataLoaded: !1,
                        isDetailsLoaded: !1,
                        isDigital: e.isDigitalGood,
                        isWbInstCompliant: e.isWbInstCompliant,
                        isPreorder: 5772 === e.brandCod && wb.settings.preOrderList.includes(e.nmId),
                        isPrepaid: e.isPrepaid,
                        isVideo: 5105 === e.subjectId,
                        hasVideo: !!(16 & e.viewFlags),
                        isBestQualityVideo: !1,
                        hasRich: !1,
                        hasImageTags: !1,
                        kindId: null != (r = e.kindId) ? r : 0,
                        nmId: e.nmId,
                        nonRefundable: e.isUnrefusable || wb.xnm.setNoRefund(e.subjectId),
                        panelPromoId: e.panelPromoId,
                        picsCount: l,
                        bestQualityPics: [],
                        promoText: e.promoTextCard,
                        promotions: null,
                        saleConditions: e.saleConditions,
                        subjectId: e.subjectId,
                        subjectName: "",
                        subjectParent: "",
                        subjectParentId: e.subjectParentId,
                        sizes: e.sizes.map((t => {
                            var r, s, n;
                            const a = null != (r = t.catalogPrice) ? r : e.catalogPrice;
                            return {
                                characteristicId: t.ch,
                                sizeName: t.nm,
                                sizeNameRus: t.rusNm,
                                quantity: t.unavailable || e.soldOut ? 0 : 1,
                                stocks: t.stocks,
                                storeIds: null == (s = t.stocks) ? void 0 : s.map((e => e.wh)),
                                isSoldOut: !!t.unavailable || e.soldOut,
                                deliveryHours: e.deliveryHours,
                                payloadV2: t.payloadV2,
                                saleConditions: t.saleConditions,
                                whDtype: null != (n = t.dtype) ? n : t.whDtype,
                                price: a ? {
                                    price: a.basic ? a.basic / 100 : 0,
                                    salePrice: a.priceToShow ? a.priceToShow / 100 : 0,
                                    sale: a.sale,
                                    logisticsCost: a.logistics,
                                    returnCost: a.return
                                } : null
                            }
                        }
                        )),
                        sizeTable: null,
                        showMinDetails: !St.includes(e.subjectParentId),
                        reviewRating: e.reviewRating,
                        star: e.star,
                        urlForReccomendations: `/recommendation/catalog?type=visuallysimilar&forproduct=${e.nmId}&excludeNms=true`,
                        supplier: $.views.helpers.supplierFineName("Wildberries" === e.supplier ? "WILDBERRIES" : $.views.converters.trimWord(e.supplier, $.views.helpers.suppliersOrgForms), e.brandId),
                        supplierId: e.supplierId,
                        supplierRating: e.supplierRating,
                        viewFlags: e.viewFlags,
                        shouldShowOriginalMark: !c && !!(8 & e.viewFlags),
                        miniAddedOptions: [],
                        groupedAddedOptions: [],
                        showThermometer: e.showThermometer,
                        quantity: e.totalQuantity,
                        whDtype: e.whDtype,
                        isHelpKursk: new URL(window.location.href).searchParams.get("helpKursk") || window.location.pathname.includes("pomozhem-kursku-vmeste")
                    };
                    u.allSizesSoldOut = null == (s = u.sizes) ? void 0 : s.every((e => e.isSoldOut));
                    const d = !u.allSizesSoldOut && (null == (n = e.catalogPrice) ? void 0 : n.total) > 0;
                    return u.price = {
                        price: d ? e.catalogPrice.basic / 100 : 0,
                        salePrice: d ? e.catalogPrice.priceToShow / 100 : 0,
                        sale: d ? e.catalogPrice.sale : 0,
                        priceDiff: !!d && e.priceDiff,
                        logisticsCost: e.catalogPrice.logistics,
                        returnCost: e.catalogPrice.return,
                        soldOut: e.allSizesSoldOut
                    },
                    u.sort = 0,
                    u.sizes.length > 0 && (1 === u.sizes.length ? u.sort = u.sizes[0].quantity > 0 ? 1 : 0 : u.sizes.reduce(( (e, t) => u.sort += t.quantity > 0), {})),
                    i.nomenclatures.push(u),
                    this.fillSelectedNomenclature(u, t),
                    Object.assign(o, {
                        product: i,
                        selectedNomenclature: u
                    }),
                    o.product.canCheckForMulti = !0,
                    o.targetInfo = null != (a = o.targetInfo) ? a : {},
                    o.metaTags = this._fillProductCardMetaTags(i),
                    o.openGraphDescription = this._fillOpenGraphDescription(u.nmId, i, o.metaTags),
                    o
                }
                stashCatalogProduct(e) {
                    e && (this._stashedCatalogProduct = e,
                    localStorage.putObject(_t, e))
                }
                get stashedCatalogProduct() {
                    var e;
                    return null != (e = this._stashedCatalogProduct) ? e : localStorage.getObject(_t)
                }
                _checkGroupedAddedOptionsExist(e) {
                    return (null == e ? void 0 : e.length) > 0 && e.some((e => {
                        var t;
                        return (null == (t = e.addedOptions) ? void 0 : t.length) > 0
                    }
                    ))
                }
                fillSelectedNomenclature(e, t) {
                    var r, s, n;
                    wb.xnm.fillFeedbacksPayment([e]),
                    wb.xnm.isRedPrice(e.panelPromoId) && (e.showRedPrice = !0),
                    wb.settings.b2bMode && (e.isVatRefundable = wb.xnm.isVatRefundable(e.viewFlags),
                    e.vatPercent = wb.xnm.getVatPercent(e.viewFlags));
                    const a = e.sizes.length <= 2 && e.sizes.every((e => "0" === e.sizeName));
                    a || 1 === e.sizes.length ? e.selectedSize = e.sizes.find((e => !e.isSoldOut)) || e.sizes[0] : null != t && (e.selectedSize = e.sizes.find((e => e.characteristicId === t))),
                    this._setSelectedPrice(e),
                    this._setButtons(e),
                    e.showSize = !a,
                    e.deliveryInfoEnable = !e.isDigital && !((null == (r = e.selectedSize) ? void 0 : r.isSoldOut) || e.allSizesSoldOut),
                    e.isVehicle = 8242 == e.subjectParentId,
                    e.saleConditions = null == (n = null == (s = e.sizes) ? void 0 : s.find((e => {
                        var t;
                        return null == (t = e.stocks) ? void 0 : t.length
                    }
                    ))) ? void 0 : n.saleConditions,
                    e.colorGroupBaseType && e.selectedSize && (e.isShowChooseColorBtn = !0)
                }
                async loadNomenclature(e) {
                    var t, r, s, n, a, o, i, l, c, u, d, p, h, m, g, y, b, f;
                    let v = null;
                    if (!e.isDataLoaded)
                        try {
                            v = await this.loadStaticProductAsync(e.nmId)
                        } catch (e) {
                            v = null
                        }
                    if (v) {
                        if (e.goodsName = null != (t = null == v ? void 0 : v.imt_name) ? t : e.goodsName,
                        e.brandName = null != (s = null == (r = null == v ? void 0 : v.selling) ? void 0 : r.brand_name) ? s : e.brandName,
                        e.colorName = v.nm_colors_names,
                        e.hasVideo = null == (n = v.media) ? void 0 : n.has_video,
                        e.isBestQualityVideo = null != (o = null == (a = null == v ? void 0 : v.media) ? void 0 : a.is_best_quality_video) && o,
                        e.bestQualityPics = null != (l = null == (i = v.media) ? void 0 : i.best_qualities_photos) ? l : [],
                        e.hasRich = null != (c = null == v ? void 0 : v.has_rich) && c,
                        e.hasImageTags = null != (u = (null == v ? void 0 : v.enable_tags) && (null == v ? void 0 : v.has_photo_tags)) && u,
                        e.consist = null != (g = null != (m = null == (d = null == v ? void 0 : v.compositions) ? void 0 : d.map((e => e.value ? `${e.name} ${e.value}%` : e.name)).join(", ")) ? m : null == (h = null == (p = null == v ? void 0 : v.options) ? void 0 : p.find((e => "Состав" === e.name))) ? void 0 : h.value) ? g : "",
                        v.sizes_table && v.sizes_table.details_props) {
                            e.sizeTable = [];
                            const t = v.sizes_table.details_props.indexOf("RU")
                              , r = {
                                row: []
                            };
                            t >= 0 && (r.row[0] = this.$localziation.russianSize),
                            r.row[1] = this.$localziation.manufactureSize;
                            let s = 2;
                            for (let e = 2; e < v.sizes_table.details_props.length; e++) {
                                const t = v.sizes_table.details_props[e];
                                r.row[s++] = "" !== t ? t : "-"
                            }
                            e.sizeTable.push(r),
                            v.sizes_table.values.forEach((r => {
                                var s;
                                const n = {
                                    chrtId: null != (s = r.chrt_id) ? s : 0,
                                    row: []
                                };
                                if (t >= 0 && (n.row[0] = r.details[t]),
                                n.row[1] = r.tech_size,
                                r.details.length > 2)
                                    for (let e = 2; e < r.details.length; e++)
                                        n.row[e] = "" !== r.details[e] ? r.details[e] : "-";
                                e.sizeTable.push(n)
                            }
                            ));
                            for (const t of e.sizes) {
                                const e = v.sizes_table.values.find((e => e.chrt_id === t.characteristicId));
                                if (e && v.sizes_table.details_props.length === e.details.length)
                                    for (let r = 2; r < v.sizes_table.details_props.length; r++) {
                                        const s = {
                                            name: v.sizes_table.details_props[r],
                                            value: "" !== e.details[r] ? e.details[r] : "-"
                                        };
                                        t.dimensions.push(s)
                                    }
                            }
                        }
                        const w = this._fillGroupedAddedOptions(v);
                        e.groupedAddedOptions = w,
                        e.miniAddedOptions = this._fillMiniGroupedAddedOptions(w),
                        e.specs = wb.xnm.convertOptionsToSpecs(null == v ? void 0 : v.options),
                        e.subjectName = null != (y = null == v ? void 0 : v.subj_name) ? y : "",
                        e.subjectParent = null != (b = null == v ? void 0 : v.subj_root_name) ? b : "",
                        e.verifiedCertificate = this._setVerifiedCertificate(v),
                        this._addDigitalLinks(e, v),
                        e.description = v.description,
                        e.markdownDescription = v.markdown_description,
                        e.isAutoplayingVideo = null == (f = v.media) ? void 0 : f.is_autoplaying_video,
                        e.isDataLoaded = !0,
                        this._fillIsChooseColor(v, e)
                    }
                    const w = Object.assign({}, e);
                    return this.fillSelectedNomenclature(w),
                    w
                }
                async loadPriceHistory(e) {
                    return await this.$httpClient.fetchStaticV3(wb.helpers.url.urlPriceHistoryStatic, {
                        logOff: !0
                    }, e)
                }
                setChooseColorInBasket(e, t) {
                    var r, s, n;
                    for (let a = 0; a < e.length; a++)
                        if ((null == (s = null == (r = e[a].meta) ? void 0 : r.shade) ? void 0 : s.colorHex) && t.sizes) {
                            if (e[a].characteristicId === (null == (n = t.sizes[0]) ? void 0 : n.characteristicId)) {
                                $.observable(t).setProperty({
                                    chooseColorInBasket: !0
                                });
                                break
                            }
                        } else
                            $.observable(t).setProperty({
                                chooseColorInBasket: !1
                            })
                }
                _addDigitalLinks(e, t) {
                    var r, s;
                    e.digitalLinks = {
                        audio: null == (r = null == t ? void 0 : t.media) ? void 0 : r.audiobook,
                        electronic: null == (s = null == t ? void 0 : t.media) ? void 0 : s.electronic_book
                    }
                }
                _colorLimiter(e, t) {
                    if (null === t || t.length < 60)
                        return t;
                    if (t.indexOf(e) < 60)
                        return t.slice(0, 60);
                    const r = [e];
                    return r.push(...t.slice(0, 59)),
                    r
                }
                _fillBaseProductCardFromX(e, t, r) {
                    var s, n, a, o;
                    const i = this._fillGroupedAddedOptions(e);
                    return {
                        imtId: null != (n = null != (s = null == e ? void 0 : e.imt_id) ? s : null == t ? void 0 : t.root) ? n : 0,
                        groupedAddedOptions: i,
                        miniAddedOptions: this._fillMiniGroupedAddedOptions(i, r),
                        nomenclatures: [],
                        promoTemplateUfu: null == (o = null == (a = null == e ? void 0 : e.media) ? void 0 : a.promo_url) ? void 0 : o.replace(/^\/+|\/+$/g, ""),
                        supplierDeliveryInfo: {
                            time1: null == t ? void 0 : t.time1,
                            time2: null == t ? void 0 : t.time2,
                            storeId: null == t ? void 0 : t.wh
                        }
                    }
                }
                _fillGroupedAddedOptions(e) {
                    var t, r, s, n, a, o, i;
                    const l = null != (r = null == (t = null == e ? void 0 : e.grouped_options) ? void 0 : t.map((e => {
                        var t;
                        return {
                            categoryName: e.group_name,
                            addedOptions: null == (t = e.options) ? void 0 : t.map((e => ({
                                property: e.name,
                                subProperty: e.value
                            })))
                        }
                    }
                    ))) ? r : [];
                    let c = null == l ? void 0 : l.find((e => "Дополнительная информация" === (null == e ? void 0 : e.categoryName)));
                    return null != c && null != c.addedOptions || (c = {
                        categoryName: "Дополнительная информация",
                        addedOptions: []
                    },
                    l.push(c)),
                    (null == (s = null == e ? void 0 : e.options) ? void 0 : s.find((e => "Состав" === e.name))) || null == (null == e ? void 0 : e.compositions) || c.addedOptions.unshift({
                        property: "Состав",
                        subProperty: null == (n = null == e ? void 0 : e.compositions) ? void 0 : n.map((e => e.value ? `${e.name} ${e.value}%` : e.name)).join("; ")
                    }),
                    (null == (a = null == e ? void 0 : e.options) ? void 0 : a.find((e => "Комплектация" === e.name))) || null == (null == e ? void 0 : e.contents) || c.addedOptions.push({
                        property: "Комплектация",
                        subProperty: e.contents
                    }),
                    (null == (o = null == e ? void 0 : e.options) ? void 0 : o.find((e => "Пол" === e.name))) || null == (null == e ? void 0 : e.kinds) || c.addedOptions.push({
                        property: "Пол",
                        subProperty: e.kinds.join(", ")
                    }),
                    !(null == (i = null == e ? void 0 : e.options) ? void 0 : i.find((e => "Сезон" === e.name))) && (null == e ? void 0 : e.season) && c.addedOptions.push({
                        property: "Сезон",
                        subProperty: e.season
                    }),
                    l.filter((e => e.addedOptions.length > 0))
                }
                _fillNomenclature(e, t, r) {
                    var s, n, a, o, i, l, c, u, d, p, h, m, g, y, b, f, v, w, S, _, C, I, M, k, P, T, A, D, E, B, O, x, L, F, W, j, N, R, U, H, q;
                    const V = null != (a = null != (n = null == (s = null == t ? void 0 : t.data) ? void 0 : s.subject_id) ? n : null == r ? void 0 : r.subjectId) ? a : 0
                      , z = null != (l = null != (i = null == (o = null == t ? void 0 : t.data) ? void 0 : o.subject_root_id) ? i : null == r ? void 0 : r.subjectParentId) ? l : 0
                      , G = null != (c = null == t ? void 0 : t.subj_name) ? c : ""
                      , Q = null != (u = null == t ? void 0 : t.subj_root_name) ? u : ""
                      , J = null != (h = null != (p = null == r ? void 0 : r.pics) ? p : null == (d = null == t ? void 0 : t.media) ? void 0 : d.photo_count) ? h : 0
                      , K = null != (g = null == (m = null == t ? void 0 : t.media) ? void 0 : m.best_qualities_photos) ? g : []
                      , X = 20624 === (null == r ? void 0 : r.brandId) || 30624 === (null == r ? void 0 : r.siteBrandId)
                      , Y = this.$services.storeService.storesMap[null == r ? void 0 : r.wh] || null;
                    JSON.parse(localStorage.getItem("isWentAuthPage"));
                    setTimeout(( () => {
                        localStorage.putObject("isWentAuthPage", {
                            isWentAuthPage: !1
                        })
                    }
                    ), 2e3);
                    const Z = {
                        adult: null != (y = null == r ? void 0 : r.isAdult) && y,
                        attachments: null == t ? void 0 : t.attachments,
                        brandId: null != (b = null == r ? void 0 : r.brandId) ? b : 0,
                        brandName: null != (v = null == (f = null == t ? void 0 : t.selling) ? void 0 : f.brand_name) ? v : null == r ? void 0 : r.brand,
                        canFit: this._setCanFit(V, z),
                        tilesVariable: this.canUseTilesVariable(V, z),
                        colorName: -1 !== vt.indexOf(null == r ? void 0 : r.subjectId) ? null : null != (S = null == t ? void 0 : t.nm_colors_names) ? S : null == (w = null == r ? void 0 : r.colors) ? void 0 : w.map((e => e.name)).join(", "),
                        consist: null != (k = null != (M = null == (_ = null == t ? void 0 : t.compositions) ? void 0 : _.map((e => e.value ? `${e.name} ${e.value}%` : e.name)).join(", ")) ? M : null == (I = null == (C = null == t ? void 0 : t.options) ? void 0 : C.find((e => "Состав" === e.name))) ? void 0 : I.value) ? k : "",
                        deliveryHours: ((null == r ? void 0 : r.time1) || 0) + ((null == r ? void 0 : r.time2) || 0),
                        intervals: null == Y ? void 0 : Y.intervals,
                        workingHours: null == Y ? void 0 : Y.workingHours,
                        description: null == t ? void 0 : t.description,
                        markdownDescription: null == t ? void 0 : t.markdown_description,
                        dest: null == r ? void 0 : r.dest,
                        fastestStore: null == r ? void 0 : r.wh,
                        feedbacks: null != (P = null == r ? void 0 : r.feedbacks) ? P : 0,
                        specs: wb.xnm.convertOptionsToSpecs(null == t ? void 0 : t.options),
                        goodsName: null != (T = null == t ? void 0 : t.imt_name) ? T : null == r ? void 0 : r.name,
                        isActivationKey: -1 !== gt.indexOf(V),
                        isAutoplayingVideo: null != (D = null == (A = null == t ? void 0 : t.media) ? void 0 : A.is_autoplaying_video) && D,
                        isDataLoaded: null != t,
                        isDetailsLoaded: !0,
                        isDigital: null != (E = null == r ? void 0 : r.isDigital) && E,
                        isWbInstCompliant: null != (B = null == r ? void 0 : r.isWbInstCompliant) && B,
                        isPreorder: 5772 === (null == r ? void 0 : r.brandId) && wb.settings.preOrderList.includes(e),
                        isPrepaid: null == r ? void 0 : r.isPrepaid,
                        isVideo: 5105 === V,
                        hasVideo: null != (x = null == (O = null == t ? void 0 : t.media) ? void 0 : O.has_video) && x,
                        isBestQualityVideo: null != (F = null == (L = null == t ? void 0 : t.media) ? void 0 : L.is_best_quality_video) && F,
                        hasRich: null != (W = null == t ? void 0 : t.has_rich) && W,
                        hasImageTags: null != (j = (null == t ? void 0 : t.enable_tags) && (null == t ? void 0 : t.has_photo_tags)) && j,
                        kindId: null != (N = null == r ? void 0 : r.kindId) ? N : 0,
                        nmId: e,
                        nonRefundable: (null == r ? void 0 : r.isUnrefusable) || wb.xnm.setNoRefund(V),
                        panelPromoId: null == r ? void 0 : r.panelPromoId,
                        picsCount: J,
                        bestQualityPics: K,
                        promoText: null == r ? void 0 : r.promoTextCard,
                        promotions: null == r ? void 0 : r.promotions,
                        saleConditions: null == r ? void 0 : r.saleConditions,
                        subjectId: V,
                        subjectName: G,
                        subjectParent: Q,
                        subjectParentId: z,
                        sizes: this._fillSizes(r, t),
                        sizeTable: t ? this._fillSizeTable(t) : null,
                        showMinDetails: !St.includes(z),
                        reviewRating: null == r ? void 0 : r.reviewRating,
                        star: null != (R = null == r ? void 0 : r.rating) ? R : 0,
                        urlForReccomendations: `/recommendation/catalog?type=visuallysimilar&forproduct=${e}&excludeNms=true`,
                        supplier: $.views.helpers.supplierFineName(null == r ? void 0 : r.supplier, null == r ? void 0 : r.brandId),
                        supplierId: null == r ? void 0 : r.supplierId,
                        supplierRating: null == r ? void 0 : r.supplierRating,
                        premiumSale: null == r ? void 0 : r.premiumSale,
                        showRedPrice: wb.xnm.isRedPrice(r.panelPromoId),
                        whDtype: null == r ? void 0 : r.dtype
                    };
                    r && wb.settings.b2bMode && (Z.isVatRefundable = wb.xnm.isVatRefundable(r.viewFlags),
                    Z.vatPercent = wb.xnm.getVatPercent(r.viewFlags)),
                    Z.allSizesSoldOut = null == (U = Z.sizes) ? void 0 : U.every((e => e.isSoldOut));
                    const ee = !Z.allSizesSoldOut && (null == (H = null == r ? void 0 : r.price) ? void 0 : H.total) > 0;
                    return this._fillIsChooseColor(t || r, Z),
                    Z.price = {
                        price: ee && r.price.basic ? r.price.basic / 100 : 0,
                        salePrice: ee && r.price.total ? r.price.priceToShow / 100 : 0,
                        priceForBasket: ee && r.price.priceForBasket ? r.price.priceForBasket / 100 : 0,
                        sale: ee ? r.price.sale : 0,
                        priceDiff: !!ee && r.diffPrice,
                        logisticsCost: r.price.logistics,
                        returnCost: r.price.return,
                        soldOut: Z.allSizesSoldOut
                    },
                    Z.sort = 0,
                    Z.quantity = 0,
                    (null == (q = Z.sizes) ? void 0 : q.length) > 0 && (1 === Z.sizes.length ? (Z.quantity = Z.sizes[0].quantity,
                    Z.sort = Z.quantity > 0 ? 1 : 0) : Z.sizes.reduce(( (e, t) => {
                        Z.quantity += t.quantity,
                        Z.sort += t.quantity > 0
                    }
                    ), {})),
                    this._setCanShowThermometer(null == r ? void 0 : r.panelPromoId, Z),
                    Z.supplierDeliveryInfo = {
                        time1: null == r ? void 0 : r.time1,
                        time2: null == r ? void 0 : r.time2,
                        storeId: null == r ? void 0 : r.wh
                    },
                    r && (Z.viewFlags = r.viewFlags,
                    Z.shouldShowOriginalMark = !X && !!(8 & r.viewFlags)),
                    Z
                }
                _fillSizeTable(e) {
                    const t = [];
                    if (e.sizes_table && e.sizes_table.details_props) {
                        const r = e.sizes_table.details_props.indexOf("RU")
                          , s = e.sizes_table.details_props.indexOf("EU")
                          , n = {
                            row: []
                        };
                        let a = 0;
                        r >= 0 && (n.row[a++] = this.$localziation.russianSize),
                        n.row[a++] = this.$localziation.manufactureSize;
                        for (let t = 0; t < e.sizes_table.details_props.length; t++) {
                            if (t === r || t === s)
                                continue;
                            const o = e.sizes_table.details_props[t];
                            n.row[a++] = "" !== o ? o : "-"
                        }
                        t.push(n),
                        e.sizes_table.values.forEach((e => {
                            var n;
                            let a = 0;
                            const o = {
                                chrtId: null != (n = e.chrt_id) ? n : 0,
                                row: []
                            };
                            r >= 0 && (o.row[a++] = e.details[r]),
                            o.row[a++] = e.tech_size;
                            const i = (-1 !== r ? 1 : 0) + (-1 !== s ? 1 : 0);
                            if (e.details.length > i)
                                for (let t = 0; t < e.details.length; t++)
                                    t !== r && t !== s && (o.row[a++] = "" !== e.details[t] ? e.details[t] : "-");
                            t.push(o)
                        }
                        ))
                    }
                    return t
                }
                _fillIsChooseColor(e, t) {
                    var r, s, n, a, o, i;
                    const l = null == (r = null == e ? void 0 : e.options) ? void 0 : r.findIndex((e => "база для колеровки" === e.name.toLowerCase() && e.value))
                      , c = null == (s = null == e ? void 0 : e.options) ? void 0 : s.find((e => "продавец может заколеровать" === e.name.toLowerCase() && "да" === e.value.toLowerCase()))
                      , u = null == (n = null == e ? void 0 : e.options) ? void 0 : n.find((e => "каталог цветов" === e.name.toLowerCase() && e.value.toLowerCase().split(/[; ]+/).includes("ncs")))
                      , d = null == (o = null == (a = t.sizes[0]) ? void 0 : a.stocks) ? void 0 : o.every((e => [1, 2, 3].includes(e.dtype)));
                    if (l > 0 && c && u && d) {
                        if (!t.sizes.map((e => wb.xnm.expandSaleConditions({}, e))).some((e => e.isUnrefusable && e.isPrepaid && (e.isUnreturnable || e.isVerificationReturn))))
                            return;
                        const r = null == (i = null == e ? void 0 : e.options[l]) ? void 0 : i.value.toLowerCase()
                          , s = ["a", "1", "bw"]
                          , n = ["c", "3", "bc", "d"];
                        r && (t.colorBaseType = r.toUpperCase(),
                        s.includes(r) ? t.colorGroupBaseType = "A" : n.includes(r) && (t.colorGroupBaseType = "C"));
                        const a = this.$services.cartService.get().basketItems;
                        this.setChooseColorInBasket(a, t)
                    }
                }
                _fillProductCardMetaTags(e) {
                    const t = {};
                    return e.nomenclatures.map((e => {
                        const r = `${e.goodsName} ${e.brandName} ${e.nmId}`;
                        t[e.nmId] = {
                            title: `${r} купить %FORPRICE% в интернет-магазине Wildberries`,
                            description: `${r} купить %FORPRICE% в интернет-магазине Wildberries. Бесплатная доставка и постоянные скидки!`
                        }
                    }
                    )),
                    t
                }
                _fillPromoUrl(e, t, r, s) {
                    var n, a;
                    if (t.promoTemplateUfu)
                        return `promo/${t.promoTemplateUfu}`;
                    if (6012 === s || 3363 === s) {
                        if (null == (a = null == (n = null == r ? void 0 : r.options) ? void 0 : n.find((e => "Подробный обзор" === e.name))) ? void 0 : a.value)
                            return `https://www.wildberries.ru/productinfo/philips/${e}`
                    }
                }
                _canCheckForMulti(e) {
                    var t;
                    return !!(null == (t = null == e ? void 0 : e.options) ? void 0 : t.find((e => "Модель" === e.name)))
                }
                _fillOpenGraphDescription(e, t, r) {
                    if (null == t ? void 0 : t.description)
                        return t.description;
                    const s = r[e];
                    return (null == s ? void 0 : s.description) ? s.description : "Узнать подробнее, перейдите по ссылке"
                }
                _fillSizes(e, t) {
                    var r;
                    return e && e.sizes ? e.sizes.sort(( (e, t) => e.rank - t.rank)).map((r => {
                        var s, n, a, o, i, l, c, u;
                        const d = []
                          , p = null == (n = null == (s = null == t ? void 0 : t.sizes_table) ? void 0 : s.values) ? void 0 : n.find((e => e.chrt_id === r.optionId));
                        if ((null == p ? void 0 : p.details) && (null == (a = t.sizes_table.details_props) ? void 0 : a.length) === p.details.length)
                            for (let e = 0; e < t.sizes_table.details_props.length; e++) {
                                if ("RU" === t.sizes_table.details_props[e] || "EU" === t.sizes_table.details_props[e])
                                    continue;
                                const r = {
                                    name: t.sizes_table.details_props[e],
                                    value: "" !== p.details[e] ? p.details[e] : "-"
                                };
                                d.push(r)
                            }
                        const h = null != (l = null == (o = r.price) ? void 0 : o.total) ? l : null == (i = e.price) ? void 0 : i.total;
                        let m = 0;
                        h > 0 && (null == (c = r.stocks) ? void 0 : c.length) > 0 && (1 === r.stocks.length ? m = r.stocks[0].qty : r.stocks.reduce(( (e, t) => m += t.qty), 0));
                        const g = m > 0 ? null == (u = r.stocks) ? void 0 : u.map((e => e.wh)) : null
                          , y = {
                            characteristicId: r.optionId,
                            sizeName: r.origName,
                            sizeNameRus: r.name,
                            dimensions: d,
                            quantity: m,
                            stocks: r.stocks,
                            storeIds: g,
                            isSoldOut: 0 === m,
                            lowQuantity: m < 3 && m > 0,
                            deliveryHours: (r.time1 || 0) + (r.time2 || 0),
                            fastestStore: r.wh,
                            payloadV2: r.payload,
                            saleConditions: r.saleConditions,
                            whDtype: r.dtype,
                            isForeign: !!(32 & r.dtype)
                        };
                        return m > 0 && r.price && (y.price = {
                            price: r.price.basic ? r.price.basic / 100 : 0,
                            salePrice: r.price.total ? r.price.priceToShow / 100 : 0,
                            priceForBasket: r.price.priceForBasket ? r.price.priceForBasket / 100 : 0,
                            sale: r.price.sale,
                            logisticsCost: r.price.logistics,
                            returnCost: r.price.return
                        },
                        this._setCanShowThermometer(e.panelPromoId, y)),
                        y
                    }
                    )) : (null == (r = null == t ? void 0 : t.data) ? void 0 : r.chrt_ids) ? t.data.chrt_ids.map((e => {
                        var r, s, n;
                        const a = null == (r = null == t ? void 0 : t.sizes_table) ? void 0 : r.values.find((t => t.chrt_id === e))
                          , o = [];
                        if (a) {
                            const e = null == (s = null == t ? void 0 : t.sizes_table) ? void 0 : s.values.find((e => e.chrt_id === a.optionId));
                            if ((null == e ? void 0 : e.details) && (null == (n = t.sizes_table.details_props) ? void 0 : n.length) === e.details.length)
                                for (let r = 0; r < t.sizes_table.details_props.length; r++) {
                                    if ("RU" === t.sizes_table.details_props[r] || "EU" === t.sizes_table.details_props[r])
                                        continue;
                                    const s = {
                                        name: t.sizes_table.details_props[r],
                                        value: "" !== e.details[r] ? e.details[r] : "-"
                                    };
                                    o.push(s)
                                }
                        }
                        return {
                            characteristicId: e,
                            sizeName: "0",
                            sizeNameRus: "",
                            dimensions: o,
                            quantity: 0,
                            isSoldOut: !0
                        }
                    }
                    )) : null
                }
                _setCanFit(e, t) {
                    return -1 !== yt.indexOf(t) && -1 === bt.indexOf(e)
                }
                canUseTilesVariable(e, t) {
                    return wb.global.settings.switches.enableTalesKT || this.$analitic.checkDataInSplitterServiceV2Sync("common", "ab_EnableTalesKT", "Yes") ? -1 !== ft.indexOf(t) && -1 === bt.indexOf(e) : null
                }
                _fillMiniGroupedAddedOptions(e, t) {
                    const r = [];
                    if (!e)
                        return r;
                    let s = t ? 4 : 6;
                    for (let t = 0; t < e.length; t++) {
                        const n = e[t].addedOptions.slice(0, s).filter((e => "Цвет" !== e.property));
                        if (r.push(...n),
                        s -= n.length,
                        s < 1)
                            break
                    }
                    return r
                }
                _setVerifiedCertificate(e) {
                    var t, r;
                    return (null == (t = null == e ? void 0 : e.certificate) ? void 0 : t.verified) ? (null == (r = e.data) ? void 0 : r.subject_id) && wt.indexOf(e.data.subject_id) >= 0 ? 2 : 1 : 0
                }
                _setSelectedPrice(e) {
                    var t;
                    e.selectedPrice = (null == (t = e.selectedSize) ? void 0 : t.price) ? e.selectedSize.price : e.price
                }
                _setButtons(e) {
                    var t, r, s;
                    e.addToBasketEnable = !((null == (t = e.selectedSize) ? void 0 : t.isSoldOut) || e.allSizesSoldOut),
                    e.addToPonedEnable = !((null == (r = e.selectedSize) ? void 0 : r.isSoldOut) || e.allSizesSoldOut),
                    e.addToWaitingListEnable = (null == (s = e.selectedSize) ? void 0 : s.isSoldOut) || e.allSizesSoldOut,
                    e.addedToBasket = !1,
                    e.addedToWl = !1
                }
                _setCanShowThermometer(e, t) {
                    !WbSpaModel.prototype.$auth.isAuth || !t.quantity || t.quantity > 1e3 || WbSpaModel.prototype.$promotionsHelper.isThermometerNeeded(e) && (t.showThermometer = !0)
                }
            }
            ;
            var It = class {
                constructor(e, t) {
                    this.publicUrl = "https://banners-website.wildberries.ru/public/v1/banners",
                    this.enums = e,
                    this.helper = t
                }
                async getBannersFromApi(e) {
                    var t;
                    const r = null != (t = e.appType) ? t : this._getAppType();
                    let s = await this._getBannersFromApi(e.urlType, r, e.menuId, e.brandId);
                    return s = s.filter((e => null != e)).map((e => this.helper.convertToBannerItem(e))),
                    s.sort(( (e, t) => {
                        var r, s;
                        return (null != (r = e.placementOptions.sort) ? r : 0) - (null != (s = t.placementOptions.sort) ? s : 0)
                    }
                    )),
                    s
                }
                async _getBannersFromApi(e, t, r, s) {
                    var n, a;
                    let o = await WbSpaModel.prototype.$user.getLocationData();
                    const i = WbSpaModel.prototype.$user.getUserInfo()
                      , l = WbSpaModel.prototype.$user.getBannersClusters()
                      , c = this._getDisplayType(i)
                      , u = this._getCountry()
                      , d = WbSpaModel.prototype.$helper.currentCulture
                      , p = new URLSearchParams({
                        urltype: e,
                        apptype: t,
                        displaytype: c,
                        longitude: o.longitude,
                        latitude: o.latitude,
                        country: u,
                        culture: d
                    });
                    WbSpaModel.prototype.$analitic.appendSplitInfoV2(p, "banner"),
                    (null == l ? void 0 : l.length) && p.append("clusterids", l),
                    r && p.append("menuid", r),
                    s && p.append("brandId", s);
                    const h = `${this.publicUrl}?${new URLSearchParams(p)}`;
                    let m = await WbSpaModel.prototype.$httpClient.fetchBasicJSON(h, {}, {
                        timeout: 1e4,
                        nullOnError: !0,
                        addAuthHeader: !0
                    });
                    if (m && (null == m ? void 0 : m.length) || (m = await this._getDefaultBannersFromStatic(e, t, r)),
                    m && WbSpaModel.prototype.$apiSupport.webpImage && (null == (a = null == (n = wb.global.settings) ? void 0 : n.switches) ? void 0 : a.bannerWebp))
                        for (const e of m)
                            e.Src && (e.Src = e.Src.replace(".jpg", ".webp")),
                            e.src && (e.src = e.src.replace(".jpg", ".webp"));
                    return (null == m ? void 0 : m.length) > 0 ? m : []
                }
                async _getDefaultBannersFromStatic(e, t, r) {
                    const s = this._getBannersTypeForStatic(e);
                    if (!s)
                        return null;
                    const n = r ? `banners-${s}-${wb.settings.currentLocale}-${r}-v1.json` : `banners-${s}-${wb.settings.currentLocale}-v1.json`;
                    try {
                        let r = await WbSpaModel.prototype.$httpClient.fetchStaticDataV2(n, 3e3);
                        return t == this.enums.appType.desktop ? r = null == r ? void 0 : r.filter((e => e.applicationType == this.enums.appType.desktop || 225 == e.applicationType || 227 == e.applicationType)) : t == this.enums.appType.mobile && (r = null == r ? void 0 : r.filter((e => e.applicationType == this.enums.appType.mobile || 227 == e.applicationType))),
                        e == this.enums.urlType.promotion && t == this.enums.appType.desktop && (null == r || r.forEach((e => {
                            e.src = this.helper.createBannerPathByResolution(e.src, "c660x210")
                        }
                        ))),
                        r
                    } catch (e) {
                        return null
                    }
                }
                _getBannersTypeForStatic(e) {
                    switch (e) {
                    case this.enums.urlType.main:
                        return "main";
                    case this.enums.urlType.promotion:
                        return "promo";
                    case this.enums.urlType.cataloger:
                        return "catalog"
                    }
                }
                _getAppType() {
                    return "d" == wb.settings.displayMode ? this.enums.appType.desktop : this.enums.appType.mobile
                }
                _getDisplayType(e) {
                    return e.isAuth ? this.enums.bannerDisplayType.forAuth : this.enums.bannerDisplayType.forNotAuth
                }
                _getCountry() {
                    var e;
                    return 1 << (null != (e = this.enums.country[WbSpaModel.prototype.$user.getLocale()]) ? e : 0) - 1
                }
            }
            ;
            class Mt {
                constructor(e, t, r, s) {
                    this.urlType = e,
                    this.menuId = r,
                    this.brandId = s,
                    this.appType = t
                }
            }
            var kt = class {
                constructor(e, t) {
                    this.enums = e,
                    this.helper = t,
                    this.api = new It(this.enums,this.helper)
                }
                async getBannersForHomePageAsync() {
                    const e = await this.api.getBannersFromApi(new Mt(this.enums.urlType.main,this.enums.appType.desktopAndMobile))
                      , t = [this.enums.locationType._215x168, this.enums.locationType._705x394, this.enums.locationType._460x394, this.enums.locationType._364x668]
                      , r = []
                      , s = []
                      , n = []
                      , a = [];
                    let o = [];
                    return null == e || e.forEach((e => {
                        e.locationType == this.enums.locationType._1440x168 ? e.applicationType == this.enums.appType.desktop ? r.push(e) : e.applicationType == this.enums.appType.mobile && o.push(e) : e.locationType == this.enums.locationType.mainInfo ? e.applicationType == this.enums.appType.desktop ? n.push(e) : e.applicationType == this.enums.appType.mobile && a.push(e) : -1 != t.indexOf(e.locationType) && s.push(e)
                    }
                    )),
                    o.length || (o = r),
                    {
                        mainBanners: r,
                        mainMobileBanners: o,
                        contentBanners: s,
                        mainInfoBanners: n,
                        mainInfoMobileBanners: a
                    }
                }
                async getBannersForFooterAsync() {
                    const e = await this.api.getBannersFromApi(new Mt(this.enums.urlType.main,this.enums.appType.desktopAndMobile))
                      , t = []
                      , r = [];
                    return null == e || e.forEach((e => {
                        e.locationType === this.enums.locationType.footerSocial && (e.applicationType == this.enums.appType.desktop ? t.push(e) : e.applicationType == this.enums.appType.mobile && r.push(e))
                    }
                    )),
                    {
                        desktopBanners: t,
                        mobileBanners: r.length ? r : t
                    }
                }
                getPromoBanners() {
                    return this._getPromotionBanners()
                }
                async _getPromotionBanners() {
                    const e = (await this.api.getBannersFromApi(new Mt(this.enums.urlType.promotion,this.enums.appType.desktop))).filter((e => e.locationType == this.enums.locationType._770x245));
                    return this.helper.dividePromotionBanners(e)
                }
                async getPromoCatalogBanners(e, t=!1) {
                    return (await this.api.getBannersFromApi(new Mt(this.enums.urlType.promotionCatalog,t ? this.enums.appType.mobile : this.enums.appType.desktop,e))).filter((e => e.locationType === this.enums.locationType.promo_strip))
                }
                async getPromotionSpecialBanners(e=!1) {
                    const t = await this.api.getBannersFromApi(new Mt(this.enums.urlType.promotionCatalog,e ? this.enums.appType.mobile : this.enums.appType.desktop))
                      , r = []
                      , s = [];
                    return t.forEach((e => {
                        e.locationType === this.enums.locationType.promo_strip && r.push(e),
                        e.locationType === this.enums.locationType.special_promo && s.push(e)
                    }
                    )),
                    [r, s]
                }
                async getTopMenuBanners() {
                    const e = await this.api.getBannersFromApi(new Mt(this.enums.urlType.default,this.enums.appType.desktop))
                      , t = this._menuSingleBanners(e)
                      , r = await this._getMenuPromotionBanners()
                      , s = t;
                    return (null == r ? void 0 : r.length) > 0 && (s[2192] = r),
                    s
                }
                _menuSingleBanners(e) {
                    return e.reduce(( (e, t) => {
                        var r;
                        if (t.locationType != this.enums.locationType.menu_banners)
                            return e;
                        const s = null != (r = t.placementOptions.menuID) ? r : 0;
                        return e.hasOwnProperty(s) || (e[s] = []),
                        e[s].push(t),
                        e
                    }
                    ), {})
                }
                async _getMenuPromotionBanners() {
                    const e = await this._getPromotionBanners()
                      , t = e.leftBanners.slice(0, 5).concat(e.rightBanners.slice(0, 5));
                    return null == t || t.forEach((e => {
                        e.src = this.helper.createBannerPathByResolution(e.src, "t305x245q"),
                        e.absoluteUrl = e.getAbsoluteUrl(),
                        e.absoluteUrlPb = e.getAbsoluteUrl(!0)
                    }
                    )),
                    t
                }
                async getCatalogBanners(e, t, r=!1) {
                    var s, n;
                    this.menuIdEnum || (this.menuIdEnum = t);
                    const a = await this.api.getBannersFromApi(new Mt(this.enums.urlType.cataloger,this.enums.appType.desktop,e))
                      , o = this._getBannersForCatalog(a, e);
                    let i = o.firstCarousel
                      , l = o.secondCarousel;
                    if (r) {
                        const t = await this.api.getBannersFromApi(new Mt(this.enums.urlType.cataloger,this.enums.appType.mobile,e))
                          , r = this._getCatalogBigBanners(t);
                        i = (null == (s = r.firstCarousel) ? void 0 : s.length) > 0 ? r.firstCarousel : o.firstCarousel,
                        l = (null == (n = r.secondCarousel) ? void 0 : n.length) > 0 ? r.secondCarousel : o.secondCarousel
                    }
                    return {
                        mainBannersFirst: i,
                        mainBannersSecond: l,
                        verticalBanners: o.verticalBanners,
                        smallBanners: o.commonBanners,
                        seasonBanners: o.seasonBanners
                    }
                }
                _getBannersForCatalog(e, t) {
                    if (!e)
                        return [];
                    const {firstCarousel: r, secondCarousel: s} = this._getCatalogBigBanners(e)
                      , n = this._getCatalogVerticalBanners(e)
                      , a = e.filter((e => e.locationType == this.enums.locationType.small));
                    return {
                        firstCarousel: r,
                        secondCarousel: s,
                        verticalBanners: n,
                        commonBanners: this._getCommonBanners(a, t),
                        seasonBanners: this._getSeasonBanners(a, t)
                    }
                }
                _getCommonBanners(e, t) {
                    const r = this._getCatalogBannersSortParams(t, !0);
                    return this.helper.getBannersBySort(e, r).reduce(( (e, t) => {
                        const r = t.placementOptions.sort;
                        return e[r] = [...e[r] || [], t],
                        e
                    }
                    ), {})
                }
                _getSeasonBanners(e, t) {
                    const r = this._getCatalogBannersSortParams(t);
                    return this.helper.getBannersBySort(e, r)
                }
                _getCatalogVerticalBanners(e) {
                    return e.filter((e => e.locationType == this.enums.locationType.vertical)).reduce(( (e, t) => {
                        const r = t.placementOptions.sort;
                        return e[r] = [...e[r] || [], t],
                        e
                    }
                    ), {})
                }
                _getCatalogBigBanners(e) {
                    const t = e.filter((e => e.locationType == this.enums.locationType.big))
                      , r = []
                      , s = [];
                    return t.forEach((e => {
                        e.placementOptions.sort < 100 && r.push(e),
                        e.placementOptions.sort > 100 && e.placementOptions.sort < 110 && s.push(e)
                    }
                    )),
                    {
                        firstCarousel: r,
                        secondCarousel: s
                    }
                }
                _getCatalogBannersSortParams(e, t) {
                    const r = {
                        onlyMarketingSortStart: null,
                        onlyMarketingSortEnd: null,
                        suppliersSortStart: null,
                        suppliersSortCount: null
                    }
                      , s = [this.menuIdEnum.sport, this.menuIdEnum.monocity];
                    return t ? -1 != s.indexOf(e) ? (r.suppliersSortStart = 0,
                    r.suppliersSortCount = 3) : (r.onlyMarketingSortStart = 0,
                    r.onlyMarketingSortEnd = 100,
                    r.suppliersSortStart = 100,
                    r.suppliersSortCount = 3) : (r.onlyMarketingSortStart = 50,
                    r.onlyMarketingSortEnd = 99),
                    r
                }
            }
            ;
            var Pt = class {
                constructor() {
                    this.appType = this._getAppType(),
                    this.locationType = this._getLocationType(),
                    this.urlType = this._getUrlType(),
                    this.bannerDisplayType = this._getBannerDisplayType(),
                    this.country = this._getCountry(),
                    this.ownerType = this._getOwnerType()
                }
                _getAppType() {
                    return {
                        desktop: 1,
                        mobile: 2,
                        desktopAndMobile: 3
                    }
                }
                _getLocationType() {
                    return {
                        main: 42,
                        small: 38,
                        strip: 39,
                        _352x428: 60,
                        _305x245: 57,
                        _770x245: 59,
                        big: 41,
                        vertical: 36,
                        promo_strip: 61,
                        _1440x168: 62,
                        _215x168: 63,
                        _705x394: 64,
                        _460x394: 65,
                        _364x668: 66,
                        menu_banners: 73,
                        footerSocial: 80,
                        mainInfo: 81,
                        special_promo: 88
                    }
                }
                _getUrlType() {
                    return {
                        main: 1024,
                        default: 0,
                        promotion: 16384,
                        cataloger: 1 << 22,
                        promotionCatalog: 62
                    }
                }
                _getBannerDisplayType() {
                    return {
                        forAuth: 2,
                        forNotAuth: 3
                    }
                }
                _getCountry() {
                    return {
                        ru: 1,
                        by: 2,
                        kz: 3,
                        am: 4,
                        kg: 5,
                        uz: 13,
                        tj: 24
                    }
                }
                _getOwnerType() {
                    return {
                        marketing: 0,
                        supplier: 1
                    }
                }
            }
            ;
            class Tt {
                constructor(e) {
                    var t, r, s, n, a, o, i, l, c, u, d, p, h, m, g, y, b, f, v, w, S;
                    this.id = null != (t = e.UID) ? t : e.uID,
                    this.href = null != (r = e.Href) ? r : e.href,
                    this.applicationType = null != (s = e.ApplicationType) ? s : e.applicationType,
                    this.locationType = null != (n = e.LocationType) ? n : e.locationType,
                    this.placementOptions = {
                        sort: null != (i = null == (a = e.PlacementOptions) ? void 0 : a.Sort) ? i : null == (o = e.placementOptions) ? void 0 : o.sort,
                        menuID: null != (u = null == (l = e.PlacementOptions) ? void 0 : l.MenuID) ? u : null == (c = e.placementOptions) ? void 0 : c.menuID
                    },
                    this.src = null != (d = e.Src) ? d : e.src,
                    this.alt = null != (p = e.Alt) ? p : e.alt,
                    this.noFollow = null != (h = e.NoFollow) ? h : e.noFollow,
                    this.noIndex = null != (m = e.NoIndex) ? m : e.noIndex,
                    this.target = null != (g = e.Target) ? g : e.target,
                    this.ordBannerMark = null != (y = e.OrdBannerMark) ? y : e.ordBannerMark;
                    const _ = null != (b = e.AdditionalSections) ? b : e.additionalSections;
                    this.bannerSelections = null != (f = null == _ ? void 0 : _.map((e => new $t(e)))) ? f : [],
                    this.promoText = null != (v = e.PromoText) ? v : e.promoText,
                    this.promoTextLines = null != (w = e.PromoTextLines) ? w : e.promoTextLines,
                    this.owner = null != (S = e.Provider) ? S : e.provider,
                    this.statisticFields = new At(e),
                    this.absoluteUrl = this.getAbsoluteUrl(),
                    this.absoluteUrlPb = this.getAbsoluteUrl(!0),
                    this.link = this.getLink(),
                    this.pixelSrc = e.PixelSrc
                }
                getLink() {
                    if (0 === this.href.indexOf("https:"))
                        return new URL(this.href).href;
                    const e = new URL(this.href,window.location);
                    return e.searchParams.append("bid", this.id),
                    `${e.pathname}${e.search}`
                }
                getAbsoluteUrl(e) {
                    return -1 !== this.src.toLowerCase().indexOf("wildberries") ? this.src : wb.helpers.url.urlStaticBasket(`crm-bnrs${this.src}`, 1, e)
                }
            }
            class $t {
                constructor(e) {
                    var t, r, s, n, a;
                    this.href = null != (t = e.Href) ? t : e.href,
                    this.relativeXPos = null != (r = e.RelativeXPos) ? r : e.relativeXPos,
                    this.relativeYPos = null != (s = e.RelativeYPos) ? s : e.relativeYPos,
                    this.relativeHeight = null != (n = e.RelativeHeight) ? n : e.relativeHeight,
                    this.relativeWidth = null != (a = e.RelativeWidth) ? a : e.relativeWidth
                }
            }
            class At {
                constructor(e) {
                    var t, r, s, n, a, o;
                    this.urlType = null != (t = e.URLType) ? t : e.uRLType,
                    this.displayType = null != (r = e.DisplayType) ? r : e.displayType,
                    this.locationType = null != (s = e.LocationType) ? s : e.locationType,
                    this.sort = null != (o = null == (n = e.PlacementOptions) ? void 0 : n.Sort) ? o : null == (a = e.placementOptions) ? void 0 : a.sort
                }
            }
            var Dt = class {
                constructor(e) {
                    this.enums = e,
                    this.fillingGapsSortStart = 300
                }
                convertToBannerItem(e) {
                    return new Tt(e)
                }
                createBannerPathByResolution(e, t) {
                    const r = t
                      , s = e.split("/").slice(-1);
                    return `/poster/${WbSpaModel.prototype.$helper.currentCulture}/action2/${r}/${s}`
                }
                dividePromotionBanners(e) {
                    const t = this._getBannersSoldToSuppliers(e, 100, 20)
                      , r = null == e ? void 0 : e.filter((e => e.owner == this.enums.ownerType.marketing))
                      , s = r.filter((e => e.placementOptions.sort < 100));
                    let {leftBanners: n, rightBanners: a} = this._createTwoSidesWithTheSameSize(r, s, t);
                    return n = n.map((e => e)),
                    a = a.map((e => e)),
                    {
                        leftBanners: n,
                        rightBanners: a
                    }
                }
                getBannersBySort(e, t) {
                    const r = e.filter((e => e.owner == this.enums.ownerType.marketing && e.placementOptions.sort > t.onlyMarketingSortStart && e.placementOptions.sort < t.onlyMarketingSortEnd))
                      , s = this._getBannersSoldToSuppliers(e, t.suppliersSortStart, t.suppliersSortCount);
                    return r.concat(s)
                }
                _getBannersSoldToSuppliers(e, t, r) {
                    if (!WbSpaModel.prototype.$helper.isNumber(t) || !r)
                        return [];
                    const s = e.filter((e => e.owner == this.enums.ownerType.supplier))
                      , n = e.filter((e => e.owner == this.enums.ownerType.marketing && e.placementOptions.sort > 200 && e.placementOptions.sort < this.fillingGapsSortStart)).reduce(( (e, t) => {
                        const r = t.placementOptions.sort;
                        return e.set(r, [...e.get(r) || [], t])
                    }
                    ), new Map)
                      , a = s.reduce(( (e, t) => e.add(t.placementOptions.sort)), new Set);
                    for (let e = 1; e <= r; e++) {
                        const r = t + e;
                        if (!a.has(r)) {
                            const t = n.get(200 + e);
                            if ((null == t ? void 0 : t.length) > 0) {
                                const e = t[0];
                                e.placementOptions.sort = r,
                                s.push(e)
                            }
                        }
                    }
                    return s
                }
                _createTwoSidesWithTheSameSize(e, t, r) {
                    const s = e.filter((e => e.placementOptions.sort >= this.fillingGapsSortStart));
                    if (0 == s.length)
                        return r;
                    var n = Math.max(t.length, r.length);
                    return this._fillGapsIfNeeded(t, n, s),
                    this._fillGapsIfNeeded(r, n, s),
                    {
                        leftBanners: t,
                        rightBanners: r
                    }
                }
                _fillGapsIfNeeded(e, t, r) {
                    let s = t - e.length;
                    for (; s > 0 && r.length > 0; ) {
                        {
                            const t = r[0];
                            r.splice(0, 1),
                            e.push(t)
                        }
                        s--
                    }
                    e.sort(( (e, t) => e.placementOptions.sort - t.placementOptions.sort))
                }
            }
            ;
            const Et = "home-banners-cache-new"
              , Bt = "menu-banners-cache-v2"
              , Ot = "main-catalog-banners-cache"
              , xt = "promotions-banners-cache"
              , Lt = "footer-banners-cache"
              , Ft = "promotion-special-banners-cache"
              , Wt = 3e5;
            var jt = class {
                constructor() {
                    WbSpaModel.prototype.$eventBus.addEventListener("GeoUpdated", ( () => this._refreshCache())),
                    this.cacheVers = 5
                }
                get bannersCacheType() {
                    return {
                        main: 1,
                        menu: 2,
                        catalog: 3,
                        promotion: 4,
                        promotionCatalog: 5,
                        footer: 6,
                        promotionSpecial: 7
                    }
                }
                async getCachedResults(e, t, r, s) {
                    const n = WbSpaModel.prototype.$user.getUserInfo().uid
                      , a = this._getCacheKey(e);
                    return a ? (s || (s = 1),
                    await this._getCachedResults(a, t, n, r, s)) : Promise.resolve(null)
                }
                async _getCachedResults(e, t, r, s, n) {
                    const a = this._tryGetCachedData(e, r)
                      , o = this._getResultsFromCachedData(a, s, n);
                    if (o)
                        return Promise.resolve(o);
                    const i = await t();
                    if (!i)
                        return Promise.resolve(null);
                    if (this._checkBannersExist(i)) {
                        const t = this._toCacheResult(r, s, n, a, i);
                        localStorage.putObject(e, t)
                    }
                    return Promise.resolve(i)
                }
                _tryGetCachedData(e, t) {
                    const r = localStorage.getObject(e);
                    return r && this.cacheVers == r.version && r.userId == t ? r : null
                }
                _getResultsFromCachedData(e, t, r) {
                    var s;
                    const n = this._getDisplayName(t)
                      , a = null == (s = null == e ? void 0 : e[n]) ? void 0 : s[r];
                    return !a || Date.now() - a.updateTs > Wt ? null : a.data
                }
                _toCacheResult(e, t, r, s, n) {
                    s || (s = {}),
                    s.version = this.cacheVers,
                    s.userId = e,
                    s.desktop = this._getCleanedCachedData(s.desktop),
                    s.mobile = this._getCleanedCachedData(s.mobile);
                    return s[this._getDisplayName(t)][r] = {
                        updateTs: Date.now(),
                        data: n
                    },
                    s
                }
                _checkBannersExist(e) {
                    let t = !1;
                    if (Array.isArray(e))
                        return !0;
                    for (let r in e) {
                        const s = e[r];
                        if (s && (Array.isArray(s) ? t = s.length > 0 : "object" == typeof s && (t = this._checkBannersExist(s)),
                        t))
                            break
                    }
                    return t
                }
                _getCleanedCachedData(e) {
                    const t = {};
                    for (let r in null != e ? e : {})
                        !r || Date.now() - e[r].updateTs > Wt || (t[r] = e[r]);
                    return t
                }
                _getDisplayName(e) {
                    return e ? "mobile" : "desktop"
                }
                _getCacheKey(e) {
                    switch (e) {
                    case this.bannersCacheType.main:
                        return Et;
                    case this.bannersCacheType.menu:
                        return Bt;
                    case this.bannersCacheType.catalog:
                        return Ot;
                    case this.bannersCacheType.promotion:
                        return xt;
                    case this.bannersCacheType.promotionCatalog:
                        return "promotions-catalog-banners-cache";
                    case this.bannersCacheType.footer:
                        return Lt;
                    case this.bannersCacheType.promotionSpecial:
                        return Ft;
                    default:
                        return null
                    }
                }
                _refreshCache() {
                    [Et, Bt, Ot, xt, Lt, Ft].forEach((e => {
                        localStorage.removeItem(e)
                    }
                    ))
                }
            }
            ;
            const Nt = new Pt
              , Rt = new Dt(Nt);
            var Ut = class {
                constructor() {
                    this.service = new kt(Nt,Rt),
                    this.cache = new jt
                }
                async getBannersForHomePageAsync() {
                    return await this.cache.getCachedResults(this.cache.bannersCacheType.main, ( () => this.service.getBannersForHomePageAsync()))
                }
                async getBannersForFooterAsync() {
                    return await this.cache.getCachedResults(this.cache.bannersCacheType.footer, ( () => this.service.getBannersForFooterAsync()))
                }
                async getMenuBanners() {
                    return await this.cache.getCachedResults(this.cache.bannersCacheType.menu, ( () => this.service.getTopMenuBanners()))
                }
                async getCatalogBanners(e, t) {
                    this.menuIdEnum || (this.menuIdEnum = t);
                    const r = "m" == wb.settings.displayMode;
                    return await this.cache.getCachedResults(this.cache.bannersCacheType.catalog, ( () => this.service.getCatalogBanners(e, this.menuIdEnum, r)), r, e)
                }
                async getPromoBanners() {
                    return await this.cache.getCachedResults(this.cache.bannersCacheType.promotion, ( () => this.service.getPromoBanners()))
                }
                async getPromoCatalogBanners(e) {
                    const t = "m" == wb.settings.displayMode;
                    return await this.cache.getCachedResults(this.cache.bannersCacheType.promotionCatalog, ( () => this.service.getPromoCatalogBanners(e, t)), t, e)
                }
                async getPromotionSpecialBanners() {
                    const e = "m" == wb.settings.displayMode;
                    return await this.cache.getCachedResults(this.cache.bannersCacheType.promotionSpecial, ( () => this.service.getPromotionSpecialBanners(e)), e)
                }
            }
            ;
            const Ht = 24
              , qt = 50
              , Vt = 37
              , zt = 0
              , Gt = -1
              , Qt = "_userstorage_h";
            const Jt = {
                1: "user-storage-01dl.wb.ru",
                2: "user-storage-01iel.wb.ru",
                3: "user-storage-01hel.wb.ru",
                4: "user-storage-01fel.wb.ru",
                5: "user-storage-01eel.wb.ru",
                6: "user-storage-01gel.wb.ru",
                7: "user-storage-01del.wb.ru",
                8: "user-storage-01dp.wb.ru",
                9: "user-storage-01cxc.wb.ru",
                10: "user-storage-01bxc.wb.ru",
                11: "user-storage-01kel.wb.ru",
                12: "user-storage-01bdl.wb.ru",
                13: "user-storage-01adl.wb.ru",
                14: "user-storage-01hel.wb.ru",
                15: "user-storage-01fel.wb.ru",
                16: "user-storage-01eel.wb.ru",
                17: "user-storage-01gel.wb.ru",
                18: "user-storage-01del.wb.ru",
                19: "user-storage-01dp.wb.ru",
                20: "user-storage-01cxc.wb.ru",
                21: "user-storage-01bxc.wb.ru",
                22: "user-storage-01kel.wb.ru",
                23: "user-storage-01bdl.wb.ru",
                24: "user-storage-01adl.wb.ru",
                25: "user-storage-02dp.wb.ru",
                26: "user-storage-02el.wb.ru",
                27: "user-storage-02dp.wb.ru",
                28: "user-storage-02el.wb.ru",
                29: "user-storage-02dp.wb.ru",
                30: "user-storage-02el.wb.ru",
                31: "user-storage-02dp.wb.ru",
                32: "user-storage-02el.wb.ru",
                33: "user-storage-02dp.wb.ru",
                34: "user-storage-02el.wb.ru",
                35: "user-storage-02dp.wb.ru",
                36: "user-storage-02el.wb.ru",
                37: "user-storage-02dp.wb.ru",
                38: "user-storage-02el.wb.ru",
                39: "user-storage-02dp.wb.ru",
                40: "user-storage-02el.wb.ru",
                41: "user-storage-02dp.wb.ru",
                42: "user-storage-02el.wb.ru"
            };
            var Kt = class {
                getSavedHost() {
                    return this.savedHost = localStorage.getItem(Qt),
                    this.savedHost
                }
                saveHost(e) {
                    this.savedHost = e,
                    this.savedHost ? localStorage.setItem(Qt, this.savedHost) : localStorage.removeItem(Qt)
                }
                constructor() {
                    this.savedHost = null,
                    window.addEventListener("storage", (e => {
                        e.key === Qt && this.getSavedHost()
                    }
                    )),
                    this.$eventBus.addEventListener("onUserAuth", ( () => {
                        this.getSavedHost()
                    }
                    )),
                    this.$eventBus.addEventListener("onUserUnAuth", ( () => {
                        this.saveHost(null)
                    }
                    ))
                }
                fetch(e, t, r) {
                    return this.$wbxHttpClient.fetch(e, t, null, (e => r || this._userStorageHost(e))).then((e => e.json()))
                }
                async _get(e, t, r, s) {
                    var n, a;
                    try {
                        const a = await this.fetch(e, t, s);
                        if (a.state === zt)
                            return a.body;
                        if (a.state === Gt && a.reason === Ht)
                            return [];
                        if (a.state === Gt && a.reason === qt)
                            return (null == r ? void 0 : r.replaceBroken) && (null == (n = t.paths) ? void 0 : n.length) ? t.paths.map((e => ({
                                path: e.path,
                                file: "W10="
                            }))) : [];
                        if (a.state === Gt && a.reason === Vt) {
                            this.saveHost(a.location);
                            const r = await this.fetch(e, t);
                            if (r.state === zt)
                                return r.body;
                            if (r.state === Gt && r.reason === Ht)
                                return []
                        }
                        return null
                    } catch (n) {
                        if (!s) {
                            const s = `https://${Jt[Math.floor(Math.random() * Object.keys(Jt).length) + 1]}`;
                            if (!(null == (a = null == t ? void 0 : t.signal) ? void 0 : a.aborted))
                                return await this._get(e, t, r, s);
                            t.signal = null,
                            this._fixLocation(e, {
                                method: t.method,
                                body: t.body
                            }, s)
                        }
                        return null
                    }
                }
                async _fixLocation(e, t, r) {
                    const s = await this.fetch(e, t, r);
                    (null == s ? void 0 : s.state) === Gt && (null == s ? void 0 : s.reason) === Vt && this.saveHost(s.location)
                }
                getList(e, t) {
                    const r = {
                        method: "POST",
                        body: JSON.stringify({
                            path: e
                        }),
                        signal: null == t ? void 0 : t.signal,
                        timeout: null == t ? void 0 : t.timeout
                    };
                    return this._get("/api/v2/list", r, t)
                }
                getData(e, t) {
                    if (!e || 0 === e.length)
                        return null;
                    const r = {
                        method: "POST",
                        body: JSON.stringify(e),
                        signal: null == t ? void 0 : t.signal,
                        paths: e
                    };
                    return this._get("/api/v2/data/get", r, t)
                }
                async setData(e) {
                    try {
                        const t = {
                            method: "POST",
                            body: JSON.stringify(e)
                        }
                          , r = await this.fetch("/api/v2/data/set", t);
                        if (r.state === zt)
                            return {
                                success: !0
                            };
                        if (r.state === Gt && r.reason === Vt) {
                            this.saveHost(r.location);
                            const e = await this.fetch("/api/v2/data/set", t);
                            return e.state === zt ? {
                                success: !0
                            } : {
                                success: !1,
                                error: new Error(`error - ${e}`)
                            }
                        }
                        return {
                            success: !1,
                            error: new Error(`error - ${r}`)
                        }
                    } catch (e) {
                        return {
                            success: !1,
                            error: e
                        }
                    }
                }
                _userStorageHost(e) {
                    return `https://${this.savedHost || Jt[e || 1] || Jt[1]}`
                }
            }
            ;
            const Xt = "wbx__sessionID";
            var Yt = class {
                constructor() {
                    this.session = localStorage.getItem(Xt),
                    window.addEventListener("storage", (e => {
                        e.key === Xt && (this.session = localStorage.getItem(Xt))
                    }
                    ))
                }
                getSession() {
                    return this.session || (this.session = localStorage.getItem(Xt),
                    this.session || (this.session = `site_${wb.helpers.generateGuid()}`,
                    localStorage.setItem(Xt, this.session))),
                    this.session
                }
                getUserUid() {
                    return this.$auth.isAuth ? this.$auth.um.userUid : this.getBasketUid()
                }
                getBasketUid() {
                    let e = wb.cookieHelper.getCookie("BasketUID");
                    return e || (e = this.getSession()),
                    e
                }
            }
            ;
            class Zt {
                static createPagerModel(e, t, r=100, s=window.location.href, n=!1) {
                    let a = Math.ceil(e / r);
                    n && (a = a <= t ? t : t + 1);
                    let o = [];
                    if (a <= 8)
                        o.push(...Zt.createRange(a, 1));
                    else {
                        let e = 5;
                        if (t < 7)
                            o.push(...Zt.createRange(7, 1)),
                            o.push("");
                        else if (t >= a - e - 1)
                            o.push(1),
                            o.push(""),
                            o.push(...Zt.createRange(7, a - 7 + 1));
                        else {
                            o.push(1),
                            o.push("");
                            let e = t
                              , r = t
                              , s = !1
                              , n = 1;
                            for (; n < 7; )
                                r < a && s && (r++,
                                n++),
                                e > 1 && !1 === s && (e--,
                                n++),
                                s = !s;
                            e = 1 === e ? 2 : e,
                            o.push(...Zt.createRange(r - e + 1, e)),
                            r < a - 1 && o.push("")
                        }
                    }
                    const i = new URL(s,window.location.origin);
                    return {
                        pageUrls: o.map((e => (i.searchParams.set("page", e),
                        {
                            value: e,
                            href: "" !== e ? i.toString() : null
                        }))),
                        pagingInfo: {
                            currentPage: t,
                            totalPages: a,
                            totalItems: e,
                            hideTotal: n
                        }
                    }
                }
                static createRange(e, t) {
                    return Array.from({
                        length: e
                    }).map(( (e, r) => r + t))
                }
            }
            var er = Zt;
            const tr = "[RETRY FETCH SERVICE]";
            var rr = class {
                constructor() {
                    this.sendQueue = "queue",
                    this.storage = this.$storageHelper,
                    this.storage.supportIndexedDb() ? setInterval(( () => this._sendJobChecker.call(this, this.sendQueue)), 1e4) : this.dbPromise = Promise.reject()
                }
                saveRequest(e, t, {tryTill: r, timeout: s}={}) {
                    try {
                        delete t.signal;
                        const n = {
                            url: e,
                            options: t,
                            retryCount: 1,
                            retryTime: Date.now()
                        };
                        r > 0 && (n.tryTill = r),
                        s > 0 && (n.timeout = s),
                        this._openDb().then((e => e.transaction(this.sendQueue, "readwrite").objectStore(this.sendQueue).add(n)))
                    } catch (e) {
                        wb.spa.logError(e, `${tr}: failed to save table=${this.sendQueue}`, !0)
                    }
                }
                _openDb() {
                    return this.dbPromise || (this.dbPromise = this.storage.openDb("send-queue", {
                        onupgradeneeded: e => {
                            if (!e.objectStoreNames.contains(this.sendQueue)) {
                                e.createObjectStore(this.sendQueue, {
                                    autoIncrement: !0
                                }).createIndex("retryTime", "retryTime", {
                                    unique: !1
                                })
                            }
                            e.objectStoreNames.contains(this.storage.metadataTableName(this.sendQueue)) || e.createObjectStore(this.storage.metadataTableName(this.sendQueue), {
                                keyPath: "name"
                            })
                        }
                        ,
                        version: 2
                    })),
                    this.dbPromise
                }
                _log(e) {
                    window._debug && console.debug(`%c${tr}: ${e}`, "color:#4B6F44")
                }
                _sendJobChecker() {
                    const e = "job_in_progress"
                      , t = this.storage.metadataTableName(this.sendQueue);
                    wb.settings.isOffline || this._openDb().then((async r => {
                        let s = !1;
                        try {
                            const n = await this.storage.get(r, t, e);
                            n && Date.now() > n.value && await this.storage.removeItem(r, t, e).then(( () => this._log("lock cleared"))),
                            s = await this.storage.addItem(r, t, {
                                name: e,
                                value: Date.now() + 3e5
                            }, !0);
                            try {
                                await this.storage.withCursor(r, this.sendQueue, "retryTime", (async (e, t, s) => {
                                    var n;
                                    const a = Date.now();
                                    if (this._log(`checking ${s.primaryKey} url: ${t.url}, retryCount: ${t.retryCount}, retryTime: ${t.retryTime}`),
                                    t.retryCount > 10 && 0 < t.tryTill && t.tryTill > a && (t.retryCount = Math.max(2, 8),
                                    t.retryTime = a - 1e3),
                                    t.retryCount > 10)
                                        this.storage.removeItem(r, this.sendQueue, s.primaryKey).then(( () => this._log(`cleared url: ${t.url}`)));
                                    else if (t.retryTime < a) {
                                        const e = s.primaryKey;
                                        try {
                                            this._log(`executing ${e} url: ${t.url}, retryCount: ${t.retryCount}, retryTime: ${t.retryTime}`);
                                            const s = {
                                                timeout: t.timeout
                                            };
                                            if (await this.$httpClient.fetchText(t.url, t.options, s),
                                            null == (n = s.modified) ? void 0 : n.timeout)
                                                throw this._log(`timeout for ${e} url: ${t.url}`),
                                                new Error("service timeout");
                                            this.storage.removeItem(r, this.sendQueue, e).then(( () => this._log(`cleared ${e} url: ${t.url}`)))
                                        } catch (s) {
                                            t.retryTime = Date.now() + 2 ** t.retryCount * 1e3,
                                            t.retryCount++,
                                            delete t.options.signal,
                                            this.storage.updateItem(r, this.sendQueue, t, e).then(( () => this._log(`extended ${e} url: ${t.url}, retryCount: ${t.retryCount}, retryTime: ${t.retryTime}`)))
                                        }
                                    }
                                }
                                ))
                            } catch (e) {
                                console.log(e)
                            }
                        } catch (e) {} finally {
                            s && this.storage.removeItem(r, t, e)
                        }
                    }
                    ))
                }
            }
            ;
            const sr = 36e5
              , nr = "splitInfoV2"
              , ar = {
                splitId: "no_test",
                title: "no_test"
            }
              , or = {
                default: [{
                    key: "ab_testing",
                    value: !1
                }]
            };
            var ir = class {
                constructor() {
                    this._setSplitInfo = this._setSplitInfo.bind(this),
                    this.splitInfo = or.default,
                    this._setSplitInfo()
                }
                removeCountInFilters() {
                    return "no_filters_count" === this.splitInfo.title
                }
                getSplitInfo() {
                    return ar
                }
                getSplitInfoV2(e) {
                    return this.splitInfo[e] || or.default
                }
                appendSplitInfoV2(e, t) {
                    const r = this.getSplitInfoV2(t);
                    r && r.forEach((t => e.append(t.key, t.value)))
                }
                _updSplitInfo() {
                    this.timerId && clearTimeout(this.timerId),
                    this.timerId = setTimeout(this._setSplitInfo, sr)
                }
                async _setSplitInfo() {
                    var e;
                    const t = this._getSplitInfoFromCache();
                    if (this.splitInfo = null != (e = null == t ? void 0 : t.splitInfo) ? e : or,
                    !(null == t ? void 0 : t.skipSplitRequest)) {
                        const e = await this._getSplitInfoFromService() || or;
                        this._setSplitInfoToCache(e),
                        this.splitInfo = e
                    }
                    wb.analitics.sendEvent("AB_Test_Splitter_Request", this.splitInfo),
                    this._updSplitInfo()
                }
                async _getSplitInfoFromService() {
                    const e = wb.cookieHelper.getCookie("_wbauid");
                    if (!e)
                        return null;
                    try {
                        const t = "https://splitter.wb.ru/v2/result"
                          , r = {
                            "X-API-KEY": "c8ab0248-284e-4fad-a8a2-d4dd258cbd6c",
                            "X-USER-ID": e
                        };
                        let s = await WbSpaModel.prototype.$httpClient.fetchBasicJSON(t, {
                            credentials: "omit",
                            headers: r
                        }, {
                            saveToBlob: "splitter_response",
                            timeout: 3e3,
                            nullOnError: !0,
                            return204: !0
                        });
                        return s && 204 !== s.status ? this._convertToAssociativeArray(s) : or
                    } catch (e) {
                        return null
                    }
                }
                _convertToAssociativeArray(e) {
                    let t = {};
                    return Array.isArray(e) && (t = e.reduce(( (e, t) => (e[t.type] = t.properties,
                    e)), {})),
                    t
                }
                _getSplitInfoFromCache() {
                    var e;
                    let t = localStorage.getObject(nr);
                    return t ? (t.t = null != (e = t.t) ? e : 0,
                    Date.now() > t.t + 72e5 ? null : {
                        splitInfo: t.splitInfo,
                        skipSplitRequest: Date.now() <= t.t + sr
                    }) : null
                }
                _setSplitInfoToCache(e) {
                    e && localStorage.putObject(nr, {
                        splitInfo: e,
                        t: Date.now()
                    })
                }
            }
            ;
            var lr = class {
                async onActionExecuting() {
                    let e = WbSpaModel.prototype.$user.getUid();
                    WbSpaModel.prototype.$services.userData.setKey("0" !== e, e),
                    await WbSpaModel.prototype.$services.userData.getUserDataAsync()
                }
            }
            ;
            var cr = class {
                async onBeforeActionExecuting(e) {
                    if ("ru" === wb.settings.currentLocale)
                        e.searchParams.set("country", "ru");
                    else {
                        const t = await WbSpaModel.prototype.$user.getLocationData();
                        e.searchParams.set("country", t.locale)
                    }
                }
            }
            ;
            var ur = class {
                constructor(e) {
                    this.checkFunction = null != e ? e : () => !0
                }
                onBeforeActionExecuting(e, t, r) {
                    r.cancelRequest = this.checkFunction()
                }
            }
            ;
            var dr = class {
                onBeforeActionExecuting(e, t, r) {
                    t.body || (t.body = new URLSearchParams),
                    t.body.set("changeEmail", "SpaChangeEmailEntrypoint" == WbSpaModel.prototype.$router.targetRoute)
                }
            }
            ;
            var pr = class {
                async onBeforeActionExecuting(e, t, r, s, n) {
                    var a, o, i;
                    WbSpaModel.prototype.$services.favsService.syncFromServerAsync();
                    const l = WbSpaModel.prototype.$services.cartService
                      , c = WbSpaModel.prototype.$auth.isAuth
                      , u = await WbSpaModel.prototype.$user.getCurrencyAsync();
                    await WbSpaModel.prototype.$moduleLoader.loadServiceAsync("installmentAggregatorService"),
                    this.getBalanceTask = c ? WbSpaModel.prototype.$user.getBalance({
                        timeout: 1e3
                    }).catch((e => Promise.resolve())) : Promise.resolve();
                    try {
                        await l.sync({
                            timeout: 3e3
                        })
                    } catch (e) {
                        wb.spa.logError(e, {
                            customMsg: "BasketDataPipeline sync"
                        }, !0)
                    }
                    const d = l.publicBasketApiUrl;
                    t.credentials = "include";
                    const p = new URL(d,window.location.origin);
                    e.port = p.port,
                    e.pathname = (p.pathname + e.pathname).replace("//", ""),
                    e.host = p.host,
                    t.body || (t.body = new URLSearchParams);
                    const h = l.getItems();
                    0 === h.length && (r.cancelRequest = () => !0);
                    const [m,g,y,b,f,v,w] = await Promise.all([WbSpaModel.prototype.$user.getXinfoSignedV1(), this.getBalanceTask, WbSpaModel.prototype.$user.getUserGrade(u), WbSpaModel.prototype.$services.installmentAggregatorService.getAvailableInstallment(), WbSpaModel.prototype.$user.getBrokerInstallmentStatus(), WbSpaModel.prototype.$user.getBrokerInstallmentConfig(), WbSpaModel.prototype.$user.getCustomsDuty(u)]);
                    this.userBalanceSigned = g,
                    this.userGradeSigned = y,
                    this.pdlInstOptions = null;
                    let S, _ = null;
                    if ("pdl" === (null == b ? void 0 : b.type))
                        this.pdlInstOptions = await WbSpaModel.prototype.$services.installmentAggregatorService.getLimit("pdl");
                    else if ("cwb" === (null == b ? void 0 : b.type)) {
                        const [e,t] = await Promise.all([WbSpaModel.prototype.$user.getBrokerInstallmentStatus(), WbSpaModel.prototype.$user.getBrokerInstallmentConfig()]);
                        this.userBrokerInstStatus = e,
                        this.userBrokerInstConfig = t
                    } else
                        "iwb" === (null == b ? void 0 : b.type) && (_ = await WbSpaModel.prototype.$services.installmentAggregatorService.getLimit("iwb"));
                    if (this.customsDutySigned = w,
                    WbSpaModel.prototype.$services.userAddressService.getByCoordinates(m.latitude, m.longitude, m.address),
                    c) {
                        const e = await WbSpaModel.prototype.$getService("groupedDeliveriesService").then((e => e.getPurchaseInfo()));
                        S = null == e ? void 0 : e.unpaid
                    }
                    const C = this.userBrokerInstStatus && "completed" === this.userBrokerInstStatus.status ? Math.floor(this.userBrokerInstStatus.availableSum / 100) : 0
                      , I = e.searchParams.get("includeInOrderStr")
                      , M = h.find((e => e.characteristicId == I));
                    this.isBuyItNowMode = !!M,
                    M ? M.includeInOrder = !0 : 1 === h.length && (h[0].includeInOrder = !0),
                    t.body = WbSpaModel.prototype.$helper.objectSerializer({
                        isBuyItNowMode: this.isBuyItNowMode,
                        items: M ? [M] : h,
                        includeInOrderStr: this.isBuyItNowMode ? null : h.filter((e => e.includeInOrder)).map((e => e.characteristicId)).join(";") || "1",
                        currency: u,
                        xInfo: m.xinfo,
                        cityLatitude: m.latitude,
                        cityLongitude: m.longitude,
                        address: m.address,
                        userBalanceSigned: this.userBalanceSigned,
                        unpaidAmount: S,
                        userDataSigned: m.userDataSign,
                        addressDataSign: m.addressDataSign,
                        userGradeSigned: y,
                        customsDutySigned: w,
                        iwcNetLimit: (null == (o = null == (a = this.pdlInstOptions) ? void 0 : a.productTypes) ? void 0 : o.length) ? this.pdlInstOptions.limit : -1,
                        cwbLimit: C,
                        iwbLimit: null == _ ? void 0 : _.limit,
                        bplOffers: this.bplOffers,
                        instType: null == b ? void 0 : b.type,
                        b2bSellerId: wb.settings.b2bMode ? null == (i = wb.settings.selectedCompany) ? void 0 : i.id : null
                    }, t.body, !0, !0)
                }
                async onActionExecuted(e) {
                    var t, r;
                    e.responseData || (e.responseData = {}),
                    e.responseData.isNetworkError ? await WbSpaModel.prototype.$services.cartService.localBasket.enrichProductsIfNeedAsync() : ((null == (t = e.responseData.data) ? void 0 : t.basket) && WbSpaModel.prototype.$services.cartService.localBasket.enrichItemsLocalInfo(e.responseData.data.basket.basketItems),
                    (null == (r = e.responseData.data) ? void 0 : r.basket) && !this.isBuyItNowMode && WbSpaModel.prototype.$services.cartService.save(e.responseData.data.basket)),
                    e.responseData.userBalanceSigned = this.userBalanceSigned,
                    e.responseData.pdlInstOptions = this.pdlInstOptions,
                    e.responseData.userGradeSigned = this.userGradeSigned,
                    e.responseData.customsDutySigned = this.customsDutySigned,
                    e.responseData.isBuyItNowMode = this.isBuyItNowMode
                }
            }
            ;
            var hr = class {
                async onBeforeActionExecuting(e) {
                    try {
                        if (!!e.searchParams.get("bc")) {
                            WbSpaModel.prototype.$services.cartService.getBankCards(2e3, WbSpaModel.prototype.$user.getCurrency(), !0),
                            WbSpaModel.prototype.$moduleLoader.execModule("bottomNotificationPanel", "showNotification", [0, "Карта успешно привязана"]);
                            const e = new URL(location.href);
                            e.searchParams.delete("bc"),
                            window.history.replaceState({}, document.title, e.href),
                            WbSpaModel.prototype.$analitic.sendEvent("Checkout_PayMethod_AddCard_Ok", {
                                name: "not_defined"
                            })
                        }
                    } catch (e) {}
                }
            }
            ;
            var mr = class {
                async onActionExecuting(e, t, r) {
                    const s = WbSpaModel.prototype.$router
                      , n = parseInt(s.routeParameters.cod1S)
                      , a = s.queryParams.has("size") && parseInt(s.queryParams.get("size")) || null
                      , o = await WbSpaModel.prototype.$services.productCard.loadProductCardAsync(n, a);
                    if (null === o)
                        return r.redirected = !0,
                        s.moveTo404Async();
                    this.data = o
                }
                async onActionExecuted(e) {
                    e.responseData ? Object.assign(e.responseData, this.data) : e.responseData = this.data
                }
            }
              , gr = Object.defineProperty
              , yr = Object.defineProperties
              , br = Object.getOwnPropertyDescriptors
              , fr = Object.getOwnPropertySymbols
              , vr = Object.prototype.hasOwnProperty
              , wr = Object.prototype.propertyIsEnumerable
              , Sr = (e, t, r) => t in e ? gr(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }) : e[t] = r;
            var _r = class {
                constructor() {
                    this.data = null
                }
                get $services() {
                    return WbSpaModel.prototype.$services
                }
                get $router() {
                    return WbSpaModel.prototype.$router
                }
                onBeforeActionExecuting() {
                    this.data = null
                }
                async onActionExecuting(e, t, r) {
                    var s;
                    const n = await this.$services.favsService.getWlArrivedCatalogModelAsync();
                    if (0 == (null != (s = null == n ? void 0 : n.goods) ? s : []).length)
                        return r.redirected = !0,
                        this.$router.moveTo404Async();
                    this.data = n
                }
                onActionExecuted(e) {
                    var t;
                    if (null == this.data)
                        return;
                    const r = this._adaptGoods(null != (t = this.data.goods) ? t : []);
                    e.responseData = {
                        goods: r,
                        goodsCount: r.length
                    }
                }
                _adaptGoods(e) {
                    return e.map((e => {
                        var t, r, s;
                        return r = ( (e, t) => {
                            for (var r in t || (t = {}))
                                vr.call(t, r) && Sr(e, r, t[r]);
                            if (fr)
                                for (var r of fr(t))
                                    wr.call(t, r) && Sr(e, r, t[r]);
                            return e
                        }
                        )({}, e),
                        s = {
                            pics: 1,
                            brand: e.brandName,
                            name: e.goodsName,
                            canQuickOrder: !e.digitalGood,
                            sale: Math.max(e.sale, null != (t = null == e ? void 0 : e.personalSale) ? t : 0)
                        },
                        yr(r, br(s))
                    }
                    ))
                }
            }
            ;
            var Cr = class {
                constructor() {
                    this.data = null
                }
                async onActionExecuting(e) {
                    this.data = await WbSpaModel.prototype.$services.favsService.getFavsDataAsync(e.searchParams)
                }
                onActionExecuted(e) {
                    null != this.data && (e.responseData || (e.responseData = {}),
                    Object.assign(e.responseData, this.data))
                }
            }
              , Ir = Object.freeze({
                main: 1,
                goods: 2,
                search: 3,
                brand: 4,
                brandConstructor: 5,
                brandConstructorCatalog: 6,
                seller: 7,
                sellerCustomMain: 9,
                promoEntry: 11,
                categoryDenyLink: 12,
                recommendationsSearch: 13
            })
              , Mr = Object.defineProperty
              , kr = (e, t, r) => ( (e, t, r) => t in e ? Mr(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
            const Pr = 6048e5
              , Tr = "__catalogOptions";
            class $r {
                constructor() {
                    kr(this, "sort", "popular"),
                    kr(this, "cardSize", "c516x688")
                }
                setValues(e, t) {
                    e && (this.sort = e),
                    t && (this.cardSize = t)
                }
            }
            class Ar {
                static updateCatalogOptions(e, t) {
                    const r = Ar._getCatalogOptionsFromCache();
                    "cardSize" === e && (r.cardSize = t),
                    "sort" === e && (r.sort = t),
                    Ar._updateAllOptions(r)
                }
                static _updateAllOptions(e) {
                    localStorage.putObject(Tr, {
                        expired: Date.now() + Pr,
                        data: e
                    })
                }
                static getCatalogOptionsValueByKey(e) {
                    return Ar._getCatalogOptionsFromCache()[e]
                }
                static _getCatalogOptionsFromCache() {
                    const e = localStorage.getObject(Tr)
                      , t = new $r;
                    return null != e && e.data && e.expired > Date.now() - Pr ? t.setValues(e.data.sort, e.data.cardSize) : Ar._updateAllOptions(t),
                    t
                }
            }
            var Dr = Ar;
            var Er = class {
                async getSeoTags(e) {
                    e = e.replace("/catalogdata/", "/catalog/");
                    const t = `seo-catalog-tags-by-url-${wb.settings.currentLocale}-${e}.json`
                      , r = await WbSpaModel.prototype.$httpClient.fetchStaticDataV2(t, 3e3);
                    return (null == r ? void 0 : r.link) && (r.link = r.link.replace("/catalog/", "/catalogdata/")),
                    r
                }
            }
              , Br = Object.getOwnPropertySymbols
              , Or = Object.prototype.hasOwnProperty
              , xr = Object.prototype.propertyIsEnumerable;
            var Lr = class {
                constructor() {
                    this.initialized = !1,
                    this.cancelled = !1,
                    this.catalogMenu = null,
                    this.currentMenuItem = null,
                    this.modules = {}
                }
                get $router() {
                    return WbSpaModel.prototype.$router
                }
                get $moduleLoader() {
                    return WbSpaModel.prototype.$moduleLoader
                }
                get $services() {
                    return WbSpaModel.prototype.$services
                }
                async onBeforeActionExecuting(e, t, r) {
                    var s, n;
                    this.xData = this.xInfo = this.products = this.sort = null,
                    this.cancelled = !1,
                    this.searchSeoTag = !1,
                    this.initialized || await this._initAsync();
                    const a = new URL(e);
                    if (a.pathname = a.pathname.replace("/webapi", ""),
                    this.currentMenuItem = this.catalogMenu.getCurrentMenuItem(a),
                    (null == (s = this.currentMenuItem) ? void 0 : s.landing) || (null == (n = this.currentMenuItem) ? void 0 : n.isDenyLink))
                        return void (this.cancelled = !0);
                    this.currentMenuItem ? this.currentMenuItem.seoTagInfo = null : this.currentMenuItem = await this._tryGetMenuItemFromTags(a);
                    const [o,i] = await Promise.all([this._getXDataAsync(), WbSpaModel.prototype.$getCurrentXInfoWithClustersAndVectorsAsync()]);
                    this.xData = o,
                    this.xInfo = i,
                    r.cancelRequest = null != this.xData,
                    r.cancelRequest || (t.body = this.xInfo)
                }
                async _tryGetMenuItemFromTags(e) {
                    const t = e.pathname
                      , r = await this.seoTagsService.getSeoTags(t);
                    if (!r)
                        return null;
                    this.searchSeoTag = !!r.searchQuery,
                    e.pathname = r.link;
                    const s = this.searchSeoTag ? this.catalogMenu.getCurrentMenuItem(e) : this._selectedMenuItemFinder(e);
                    return s ? (this.searchSeoTag || (r.xQuery = 0 === s.query.indexOf("preset") ? `${s.query}&${r.parameters}` : r.parameters),
                    s.seoTagInfo = r,
                    s) : null
                }
                _selectedMenuItemFinder(e) {
                    let t, r = null;
                    for (; 0 !== (t = e.pathname.lastIndexOf("/")) && null == r; )
                        r = this.catalogMenu.getCurrentMenuItem(e),
                        e.pathname = e.pathname.substring(0, t);
                    return r
                }
                async onActionExecuting() {
                    if (this.xData && this.xInfo && !this.cancelled) {
                        let e = this.modules.QueryHelper.getInitialParams()
                          , {sort: t=this.modules.SorterModel.getSortFromCache, page: r} = e
                          , s = ( (e, t) => {
                            var r = {};
                            for (var s in e)
                                Or.call(e, s) && t.indexOf(s) < 0 && (r[s] = e[s]);
                            if (null != e && Br)
                                for (var s of Br(e))
                                    t.indexOf(s) < 0 && xr.call(e, s) && (r[s] = e[s]);
                            return r
                        }
                        )(e, ["sort", "page"]);
                        t !== this.modules.SorterModel.getSortFromCache && Dr.updateCatalogOptions("sort", t);
                        const n = new this.modules.QueryHelper({
                            sort: t,
                            page: r,
                            filters: this.modules.QueryHelper.checkOnlyFilterParams(s)
                        }).getQueryStringForCatalog()
                          , a = wb.global.settings.switches.enableInfiniteScroll || WbSpaModel.prototype.$analitic.checkDataInSplitterServiceV2Sync("common", "ab_enableAutoNextPage", "yes")
                          , o = new URLSearchParams(n);
                        o.delete("page");
                        const i = this.modules.CatalogProvider.createGoodsProvider(this.xData)
                          , {goods: l=[], resp: c} = await this._loadGoodsAsync(i, a ? o : n);
                        this.products = l,
                        this.sort = t,
                        this.searchSeoTag && (this.xData = this._updateXDataIfSearchTag(this.xData, c))
                    }
                }
                _updateXDataIfSearchTag(e, t) {
                    var r;
                    const s = (null == t ? void 0 : t.metadata) ? null == t ? void 0 : t.metadata : t;
                    return (null == s ? void 0 : s.name) || (e.gender = null),
                    (null == s ? void 0 : s.name) && e.search !== (null == s ? void 0 : s.name) && (e.search = s.name),
                    (null == s ? void 0 : s.catalog_value) && (e.xcatalogQuery = s.catalog_value),
                    (null == s ? void 0 : s.catalog_type) && (e.xcatalogShard = s.catalog_type),
                    (null == s ? void 0 : s.context) && (e.xcatalogContext = s.context),
                    e.originalSearch = null != (r = null == s ? void 0 : s.original) ? r : null,
                    e
                }
                async _loadGoodsAsync(e, t) {
                    try {
                        const {goods: r=[], resp: s} = await e.loadGoodsAsync(t);
                        return {
                            goods: r,
                            resp: s
                        }
                    } catch (e) {
                        return {
                            goods: [],
                            resp: null
                        }
                    }
                }
                onActionExecuted(e) {
                    var t;
                    if (null == this.xData || this.cancelled)
                        return;
                    e.responseData || (e.responseData = {});
                    const r = this.catalogMenu.getSitePathItems(this.currentMenuItem)
                      , s = {
                        xData: this.xData,
                        menuId: this.currentMenuItem.id,
                        currentMenuItem: this.currentMenuItem,
                        rootMenuItem: this.catalogMenu.getRootNode(this.currentMenuItem),
                        selectedHasChild: !!this.currentMenuItem.childs,
                        sitePathItems: r,
                        emptyCatalogLink: this.currentMenuItem.url,
                        tagsUrl: this.currentMenuItem.url,
                        products: this.products,
                        targetUrl: "GP",
                        title: null != (t = this.currentMenuItem.seo) ? t : this.currentMenuItem.name,
                        containerClass: "catalog-page",
                        needAdultProtection: !wb.adult.isConfirmed,
                        sorterModel: new this.modules.SorterModel(this.sort,this.currentMenuItem.url)
                    };
                    this.currentMenuItem.seoTagInfo && this._updateModelIfSeoTagUrl(s, this.currentMenuItem.seoTagInfo);
                    const n = {
                        mainVersion: 0,
                        type: Ir.goods,
                        model: s
                    };
                    Object.assign(e.responseData, {
                        data: n
                    })
                }
                async _updateModelIfSeoTagUrl(e, t) {
                    t.seo && (e.title = t.seo),
                    e.tagsUrl = t.url
                }
                async _initAsync() {
                    const [e,t,r,s,n] = await Promise.all([this.$moduleLoader.loadModuleAsync("xCatalogData"), this.$moduleLoader.loadModuleAsync("queryHelper"), this.$moduleLoader.loadModuleAsync("xCatalogProvider"), this.$moduleLoader.loadModuleAsync("sorterModel"), wb.spa.getCatalogMenu()]);
                    this.modules = {
                        XCatalogData: e.XCatalogData,
                        XSearchCatalogData: e.XSeachData,
                        QueryHelper: t,
                        CatalogProvider: r,
                        SorterModel: s.CatalogSorterModel
                    },
                    this.catalogMenu = n,
                    this.seoTagsService = new Er
                }
                async _getXDataAsync() {
                    var e;
                    const t = null == (e = this.currentMenuItem) ? void 0 : e.seoTagInfo;
                    if (this.searchSeoTag && t) {
                        const e = await WbSpaModel.prototype.$getUserGender();
                        return new this.modules.XSearchCatalogData(t.searchQuery,t.searchQuery,null,null,e,1)
                    }
                    const r = this.currentMenuItem && ((null == t ? void 0 : t.xQuery) || this.currentMenuItem.query);
                    return this.currentMenuItem && this.currentMenuItem.shard ? new this.modules.XCatalogData(r,this.currentMenuItem.shard) : null
                }
            }
            ;
            var Fr = class {
                constructor() {
                    this.initialized = !1,
                    this.requestCancelled = !1,
                    this.cancelled = !1,
                    this.catalogMenu = null,
                    this.currentMenuItem = null
                }
                get $services() {
                    return WbSpaModel.prototype.$services
                }
                get $moduleLoader() {
                    return WbSpaModel.prototype.$moduleLoader
                }
                get $isDesktop() {
                    return WbSpaModel.prototype.$isDesktop
                }
                get menuIdEnum() {
                    return this.catalogMenu.menuIdEnum
                }
                async onBeforeActionExecuting(e, t, r) {
                    var s;
                    this.requestCancelled = this.cancelled = !1,
                    this.initialized || await this._initAsync();
                    const n = new URL(e);
                    n.pathname = n.pathname.replace("/webapi", ""),
                    this.currentMenuItem = this.catalogMenu.getCurrentMenuItem(n),
                    (null == (s = this.currentMenuItem) ? void 0 : s.landing) ? r.cancelRequest = this.requestCancelled = null != this.currentMenuItem : this.cancelled = !0
                }
                async onActionExecuted(e) {
                    if (this.cancelled)
                        return;
                    if (!this.requestCancelled)
                        return this._modifyServerResult(e.responseData);
                    e.responseData || (e.responseData = {});
                    const t = this.catalogMenu.getSitePathItems(this.currentMenuItem)
                      , r = this.currentMenuItem.id
                      , [s,n] = await Promise.all([this.$moduleLoader.loadModuleAsync("mainCatalogConfig"), this._getCarouselsFromSearchService(r)])
                      , a = new s(s.template,this.menuIdEnum).getConfig(this.currentMenuItem)
                      , o = this.bannersTask(a, r)
                      , i = this.catalogMenu.menuById.get(r).childs
                      , l = JSON.parse(JSON.stringify(i))
                      , c = {
                        menuId: r,
                        bannersTask: o,
                        brandCatalogCode: a.brandCatalogCode,
                        pageTitle: this.currentMenuItem.name,
                        sitePathItems: t,
                        catalogMenu: this._transformMenu(l),
                        needAdultProtection: r == this.menuIdEnum.forAdults && !wb.adult.isConfirmed,
                        promoMenuV2: !1,
                        reqiredCss: a.reqiredCss,
                        requiredJs: [],
                        topMenu: a.useTopMenu ? this._buildTopMenu(l) : null,
                        topBrandsUrl: this._getUrlForTopBrands(r, a),
                        carouselsData: n
                    }
                      , u = {
                        mainVersion: r === this.menuIdEnum.sport ? 2 : 3,
                        type: Ir.main,
                        model: c
                    };
                    Object.assign(e.responseData, {
                        data: u
                    })
                }
                _modifyServerResult(e) {
                    const {data: t} = e;
                    if (!t)
                        return;
                    const {model: r} = t;
                    r && (r.bannersTask = Promise.resolve({
                        mainBannersFirst: this.$isDesktop ? r.firstBannersDesk : r.firstBannersMob,
                        mainBannersSecond: this.$isDesktop ? r.secondBannersDesk : r.secondBannersMob,
                        seasonBanners: r.seasonBanners,
                        verticalBanners: r.verticalBanners,
                        smallBanners: r.smallBanners
                    }))
                }
                async bannersTask(e, t) {
                    const r = await this.$services.bannersService.getCatalogBanners(t, this.menuIdEnum)
                      , s = this._buildBannersRows(r.smallBanners, e.bannersSort)
                      , n = this._buildBannersRows(r.verticalBanners, e.verticaBannerSort);
                    return {
                        mainBannersFirst: r.mainBannersFirst,
                        mainBannersSecond: r.mainBannersSecond,
                        seasonBanners: r.seasonBanners,
                        verticalBanners: n,
                        smallBanners: s
                    }
                }
                _getUrlForTopBrands(e, t) {
                    const r = new URLSearchParams({
                        menuId: e,
                        brandCode: t.brandCatalogCode
                    });
                    return t.topBrandsCount && r.append("count", t.topBrandsCount),
                    `/webapi/maincatalog/topBrands?${r}`
                }
                _buildTopMenu(e) {
                    if (!e || 0 == e.length)
                        return;
                    const t = e.slice(0, 7)
                      , r = this._toChunks(e, 10)
                      , s = [];
                    t.forEach((e => {
                        const t = this._toChunks(e.childs, 10)
                          , r = {
                            node: this._toTopMenuItem(e),
                            childNodes: t
                        };
                        s.push(r)
                    }
                    ));
                    return [{
                        node: this._allCategoriesMenuItem(e[0]),
                        childNodes: r
                    }].concat(s)
                }
                _toTopMenuItem(e) {
                    return {
                        name: e.name,
                        link: e.url
                    }
                }
                _allCategoriesMenuItem(e) {
                    return e.name = "Все категории",
                    this._toTopMenuItem(e)
                }
                _toChunks(e, t) {
                    const r = [];
                    for (let s = 0; s < e.length; s += t) {
                        const n = e.slice(s, s + t).map((e => this._toTopMenuItem(e)));
                        n.length > 0 && r.push(n)
                    }
                    return r
                }
                _buildBannersRows(e, t) {
                    if (!e || 0 == e.length || !t)
                        return null;
                    var r = {}
                      , s = 0;
                    return t.forEach(( (t, n) => {
                        let a = [];
                        n < 9 && this._isAllBannersExist(t, e) && t.forEach((t => {
                            var r;
                            (null == (r = e[t]) ? void 0 : r.length) > 0 && a.push(e[t][0])
                        }
                        )),
                        r[s] = a,
                        s++
                    }
                    )),
                    r
                }
                _isAllBannersExist(e, t) {
                    return e.forEach((e => {
                        var r;
                        if (!((null == (r = t[e]) ? void 0 : r.length) > 0))
                            return !1
                    }
                    )),
                    !0
                }
                async _initAsync() {
                    this.catalogMenu = await wb.spa.getCatalogMenu(),
                    this.initialized = this.catalogMenu.isInited
                }
                _transformMenu(e) {
                    return null == e ? void 0 : e.map((e => {
                        var t, r;
                        return {
                            childNodes: this._transformMenu(null != (t = e.childs) ? t : []),
                            entity: {
                                pageUrl: e.url,
                                name: e.name,
                                isDenyLink: null != (r = e.isDenyLink) && r
                            },
                            parent: {}
                        }
                    }
                    ))
                }
                async _getCarouselsFromSearchService(e) {
                    const t = async () => {
                        const [e,t,{XSeachData: r}] = await Promise.all([WbSpaModel.prototype.$getUserGender(), WbSpaModel.prototype.$getCurrentXInfoWithClustersAndVectorsAsync(), this.$moduleLoader.loadModuleAsync("xCatalogData")])
                          , s = new r(null,null,null,null,e)
                          , n = new URL(s.dataUrl);
                        return wb.helpers.appendToParamsFromQuery(n.searchParams, t),
                        n.searchParams.set("resultset", "catalog"),
                        WbSpaModel.prototype.$analitic.appendSplitInfoV2(n.searchParams, "search"),
                        n
                    }
                    ;
                    try {
                        const [r,s] = await Promise.all([WbSpaModel.prototype.$httpClient.fetchStaticDataV2(`main-catalog-carousels-${e}.json`, 3e3), t()])
                          , n = null == r ? void 0 : r.filter((e => {
                            var t;
                            return (null == (t = null == e ? void 0 : e.query) ? void 0 : t.length) > 0
                        }
                        )).map((e => ( (e, t) => (wb.helpers.appendToParamsFromQuery(t.searchParams, e.query),
                        t.searchParams.sort(),
                        {
                            fetchUrl: t.toString(),
                            firstTitle: e.name,
                            showAllURL: t.toString(),
                            sort: e.sort,
                            targetURL: "TG"
                        }))(e, s)));
                        return null == n || n.sort(( (e, t) => e.sort - t.sort)),
                        n
                    } catch (e) {
                        return console.error(e),
                        null
                    }
                }
            }
            ;
            var Wr = class {
                constructor() {
                    this.initialized = !1,
                    this.requestCancelled = !1,
                    this.cancelled = !1,
                    this.catalogMenu = null,
                    this.currentMenuItem = null
                }
                get $services() {
                    return WbSpaModel.prototype.$services
                }
                get $moduleLoader() {
                    return WbSpaModel.prototype.$moduleLoader
                }
                get $isDesktop() {
                    return WbSpaModel.prototype.$isDesktop
                }
                async onBeforeActionExecuting(e, t, r) {
                    var s;
                    this.requestCancelled = this.cancelled = !1,
                    this.initialized || await this._initAsync();
                    const n = new URL(e);
                    n.pathname = n.pathname.replace("/webapi", ""),
                    this.currentMenuItem = this.catalogMenu.getCurrentMenuItem(n),
                    (null == (s = this.currentMenuItem) ? void 0 : s.isDenyLink) ? r.cancelRequest = this.requestCancelled = null != this.currentMenuItem : this.cancelled = !0
                }
                async onActionExecuted(e) {
                    var t;
                    if (this.cancelled)
                        return;
                    e.responseData || (e.responseData = {});
                    const r = this.catalogMenu.getSitePathItems(this.currentMenuItem)
                      , s = {
                        mainVersion: 0,
                        type: Ir.categoryDenyLink,
                        model: {
                            menuId: this.currentMenuItem.id,
                            currentMenuItem: this.currentMenuItem,
                            rootMenuItem: this.catalogMenu.getRootNode(this.currentMenuItem),
                            children: this.currentMenuItem.childs,
                            sitePathItems: r,
                            title: null != (t = this.currentMenuItem.seo) ? t : this.currentMenuItem.name,
                            needAdultProtection: !wb.adult.isConfirmed,
                            catalogMenu: this.catalogMenu,
                            catalogPromoLeftMenu: this.catalogMenu.getCatalogDenyMenu(this.currentMenuItem, r)
                        }
                    };
                    Object.assign(e.responseData, {
                        data: s
                    })
                }
                async _initAsync() {
                    this.catalogMenu = await wb.spa.getCatalogMenu(),
                    this.initialized = this.catalogMenu.isInited
                }
            }
              , jr = Object.getOwnPropertySymbols
              , Nr = Object.prototype.hasOwnProperty
              , Rr = Object.prototype.propertyIsEnumerable;
            var Ur = class {
                get $router() {
                    return WbSpaModel.prototype.$router
                }
                get $moduleLoader() {
                    return WbSpaModel.prototype.$moduleLoader
                }
                get $services() {
                    return WbSpaModel.prototype.$services
                }
                get $httpClient() {
                    return WbSpaModel.prototype.$httpClient
                }
                get $helper() {
                    return WbSpaModel.prototype.$helper
                }
                async onBeforeActionExecuting(e, t, r) {
                    r.cancelRequest = !0,
                    this.initialized || await this._initAsync()
                }
                async onActionExecuting(e, t, r) {
                    var s, n;
                    const a = this.modules.QueryHelper.getInitialParams();
                    this.catalogMenu = this.xData = this.products = this.targetUrl = this.isEmpty = null,
                    this.isNetworkError = !1;
                    let o = a
                      , {brand: i, page: l, sort: c="popular", cardsize: u, search: d, targeturl: p, nocorrection: h, ssubject: m} = o
                      , g = ( (e, t) => {
                        var r = {};
                        for (var s in e)
                            Nr.call(e, s) && t.indexOf(s) < 0 && (r[s] = e[s]);
                        if (null != e && jr)
                            for (var s of jr(e))
                                t.indexOf(s) < 0 && Rr.call(e, s) && (r[s] = e[s]);
                        return r
                    }
                    )(o, ["brand", "page", "sort", "cardsize", "search", "targeturl", "nocorrection", "ssubject"]);
                    const y = new this.modules.QueryHelper({
                        sort: c,
                        page: l,
                        ssubject: m,
                        filters: this.modules.QueryHelper.checkOnlyFilterParams(g)
                    })
                      , b = y.getQueryStringForCatalog()
                      , f = wb.global.settings.switches.enableInfiniteScroll || WbSpaModel.prototype.$analitic.checkDataInSplitterServiceV2Sync("common", "ab_enableAutoNextPage", "yes")
                      , v = new URLSearchParams(b);
                    v.delete("page");
                    const w = await this._getXDataAsync(a);
                    if (null == w.search || "" === w.search)
                        return r.redirected = !0,
                        this.$router.moveTo404Async();
                    const {redirect: S, isProductRedirect: _} = await this._checkPossibleRedirects(a, w);
                    if (S && !_)
                        return r.redirected = !0,
                        this.$router.moveTo(S, !0);
                    const C = await WbSpaModel.prototype.$getCurrentXInfoWithClustersAndVectorsAsync()
                      , I = this.modules.CatalogProvider.createGoodsProvider(w)
                      , {goods: M=[], resp: k, isNetworkError: P=!1} = await this._loadGoodsAsync(I, f ? v : b)
                      , T = (null == k ? void 0 : k.metadata) ? null == k ? void 0 : k.metadata : k;
                    if (this.isEmpty = void 0 !== (null == T ? void 0 : T.is_empty) ? T.is_empty : null,
                    (null == T ? void 0 : T.name) || (w.gender = null),
                    "redirect" === (null == T ? void 0 : T.catalog_type) && (null == T ? void 0 : T.catalog_value)) {
                        const e = await this._checkRedirectUrl(T.catalog_value);
                        if (e)
                            return r.redirected = !0,
                            this.$router.moveTo(e, !0)
                    }
                    if ((null == T ? void 0 : T.title) && (w.title = T.title),
                    (null == T ? void 0 : T.name) && (null == T ? void 0 : T.change_input) && (w.search = T.name),
                    (null == T ? void 0 : T.catalog_value) && (w.xcatalogQuery = T.catalog_value),
                    (null == T ? void 0 : T.catalog_type) && (w.xcatalogShard = T.catalog_type),
                    (null == T ? void 0 : T.context) && (w.xcatalogContext = T.context),
                    (null == T ? void 0 : T.normquery) && (w.normQuery = T.normquery),
                    (null == T ? void 0 : T.rmi) && (w.rmi = T.rmi),
                    w.originalSearch = null != (s = null == T ? void 0 : T.original) ? s : null,
                    w.change_input = null != (n = null == T ? void 0 : T.change_input) && n,
                    this.products = P ? [] : M,
                    this.emptySearch = 0 === this.products.length && 0 === y.getFiltersQuery().toString().length,
                    this.isNetworkError = P,
                    _ && this.emptySearch)
                        return r.redirected = !0,
                        this.$router.moveTo(S, !0);
                    this.emptySearchRecom = [],
                    this.emptySearch && (this.emptySearchRecom = await this._getEmptySearchRecommendations(w)),
                    this._needChangeEmptyUserSearch(this, w) && (w.userSearch = w.search),
                    this.xData = w,
                    this.targetUrl = p,
                    this.xInfo = C,
                    this.sort = c
                }
                onActionExecuted(e) {
                    var t;
                    e.responseData || (e.responseData = {});
                    this.$router.queryParams.get("ssubject");
                    const r = String.format(null != (t = this.xData.title) ? t : this.xData.search)
                      , s = {
                        type: Ir.search,
                        model: {
                            title: r,
                            xData: this.xData,
                            tagsUrl: `${this.xData.search.toSafeString()}&lang=ru&${this.xInfo}&locale=${WbSpaModel.prototype.$user.getLocale()}`,
                            emptySearch: this.emptySearch,
                            products: this.products,
                            emptySearchRecom: this.emptySearchRecom,
                            targetUrl: this.targetUrl,
                            needAdultProtection: !wb.adult.isConfirmed,
                            sorterModel: new this.modules.SorterModel(this.sort,window.location.href),
                            currentMenuItem: null,
                            rootMenuItem: null,
                            isNetworkError: this.isNetworkError,
                            isEmpty: this.isEmpty,
                            selectedHasChild: !1
                        }
                    };
                    Object.assign(e.responseData, {
                        data: s
                    })
                }
                async _loadGoodsAsync(e, t) {
                    try {
                        const {goods: r=[], resp: s} = await e.loadGoodsAsync(t);
                        return {
                            goods: r,
                            resp: s
                        }
                    } catch (e) {
                        return {
                            goods: [],
                            resp: null,
                            isNetworkError: !0
                        }
                    }
                }
                async _initAsync() {
                    const [e,t,r,s] = await Promise.all([this.$moduleLoader.loadModuleAsync("xCatalogData"), this.$moduleLoader.loadModuleAsync("queryHelper"), this.$moduleLoader.loadModuleAsync("xCatalogProvider"), this.$moduleLoader.loadModuleAsync("sorterModel")]);
                    this.modules = {
                        XCatalogData: e.XSeachData,
                        QueryHelper: t,
                        CatalogProvider: r,
                        SorterModel: s.CatalogSorterModel
                    },
                    this.initialized = !0
                }
                async _getXDataAsync(e) {
                    const t = await WbSpaModel.prototype.$getUserGender();
                    return new this.modules.XCatalogData(e.search,e.search,null,null,t,e.nocorrection,e.ssubject)
                }
                async _checkPossibleRedirects(e, t) {
                    try {
                        const [r,s] = await Promise.all([this._getBrandsRedirect(e), this._tryGetUrlToProductCard(e, t)]);
                        return {
                            redirect: null != r ? r : s,
                            isProductRedirect: null != s
                        }
                    } catch (e) {
                        return console.error(`Error checking redirect ${e.message}`),
                        {
                            redirect: null
                        }
                    }
                }
                async _getBrandsRedirect(e) {
                    var t;
                    try {
                        const r = await this.$httpClient.fetchBasicJSON(`https://brand-suggestions.wildberries.ru/api/v1/redirect?query=${encodeURIComponent(e.search)}`, {}, {
                            timeout: 2e3
                        });
                        return "" === (null != (t = null == r ? void 0 : r.url) ? t : "") ? null : r.url
                    } catch (e) {
                        return null
                    }
                }
                async _checkRedirectUrl(e) {
                    var t;
                    try {
                        const r = new URL(e.startsWith("http") ? e : "https://" + e);
                        if (r.host.endsWith(".wildberries.ru")) {
                            const e = !r.pathname.startsWith("/recent") && r.pathname.startsWith("/catalog");
                            if (e && (null == (t = await wb.spa.getCatalogMenu()) ? void 0 : t.menuByUrl.get(r.pathname)) || !e)
                                return r.toString()
                        }
                        return r.toString()
                    } catch (e) {
                        return null
                    }
                }
                async _tryGetUrlToProductCard(e, t) {
                    var r;
                    if (!t.isValid || "merger" === t.shardKey)
                        return null;
                    const s = e.search;
                    if (!this.$helper.isNumber(s))
                        return null;
                    if (s <= 1e3 || s >= 1e9)
                        return null;
                    try {
                        const e = await wb.xnm.getXnmProducts([s]);
                        if (!((null == (r = null == e ? void 0 : e[s]) ? void 0 : r.pics) > 0))
                            return null;
                        const t = new URL(`/catalog/${s}/detail.aspx`,window.location.origin);
                        return t.searchParams.set("targetUrl", "SP"),
                        t
                    } catch (e) {
                        return null
                    }
                }
                async _getEmptySearchRecommendations(e) {
                    const t = `https://search-goods.wildberries.ru/search?query=${encodeURIComponent(e.search)}`;
                    try {
                        const e = await this.$httpClient.fetchBasicJSON(t, {}, {
                            timeout: 2e3
                        });
                        if (!(Array.isArray(e) && e.length > 0))
                            return [];
                        const r = await wb.xnm.getCatalogCards(e);
                        return Object.values(r).reduce(( (e, t) => (t.id && e.push(wb.xnm.convertXProductToSpaCatalogProduct(t)),
                        e)), [])
                    } catch (e) {
                        return console.error(e.message),
                        []
                    }
                }
                _notShowTecDoc(e) {
                    var t, r;
                    return !(null == (t = null == e ? void 0 : e.xcatalogContext) ? void 0 : t.includes("autoproduct")) || wb.settings.isIE || !(null == (r = wb.global.settings.switches) ? void 0 : r.tecDocEnable)
                }
                _needChangeEmptyUserSearch(e, t) {
                    var r;
                    if (!e.emptySearch)
                        return !1;
                    if (this._notShowTecDoc(t))
                        return !1;
                    return -1 !== (null == (r = t.userSearch) ? void 0 : r.indexOf("automodel:"))
                }
            }
            ;
            const Hr = ["wide", "mini"];
            var qr = class {
                constructor() {
                    this.fullMenu = null,
                    this.menuByUrl = new Map,
                    this.menuById = new Map,
                    this.brandsMenuList = {
                        items: null
                    },
                    this.promoId = null,
                    this.isSpecial = null,
                    this.isTrend = !1
                }
                async initMenu(e) {
                    var t;
                    e && (this.promoId = null != (t = e.promo.id) ? t : 0,
                    this.isSpecial = e.promo.isSpecial,
                    this.isTrend = e.isTrend,
                    this.shelves = e.promo.shelves,
                    this.isExtended = e.promo.isExtended,
                    this._createMenuMap(e),
                    this._generateImg(e))
                }
                getCurrentMenuItem(e) {
                    if (!e)
                        return null;
                    const t = e.pathname.replace("promotionscatalogdata", "promotions");
                    return this.menuByUrl.get(t)
                }
                getSitePathItems(e) {
                    if (!e)
                        return null;
                    const t = [];
                    t.push({
                        id: e.id,
                        name: e.name,
                        pageUrl: e.url
                    });
                    let r = this.menuById.get(e.id).parentId;
                    for (; null != r; ) {
                        const e = this.menuById.get(r);
                        t.push({
                            id: r,
                            name: e.name,
                            pageUrl: e.url
                        }),
                        r = e.parentId
                    }
                    return t.push({
                        id: 2192,
                        name: "Акции",
                        pageUrl: "/promotions"
                    }),
                    t.reverse()
                }
                getCatalogMenu(e, t) {
                    var r, s, n, a, o, i;
                    if (!e)
                        return;
                    if (e.landing || 2 === t.length)
                        return {
                            current: {
                                name: e.name,
                                link: e.url,
                                isTop: e.isTop,
                                lastSelected: !1
                            },
                            sideMenu: [],
                            parent: {},
                            parents: [],
                            tagsMenu: null != (s = null == (r = e.childNodes) ? void 0 : r.map((e => ({
                                name: e.name,
                                link: e.url
                            })))) ? s : []
                        };
                    const l = t[t.length - 2]
                      , c = t.slice(1).map((e => ({
                        name: e.name,
                        link: e.pageUrl
                    })));
                    c[c.length - 1].lastSelected = !0;
                    const u = null == (n = e.childNodes) ? void 0 : n.map((e => ({
                        name: e.name,
                        link: e.url,
                        anc: !0
                    })));
                    if ((null == (a = e.childNodes) ? void 0 : a.length) > 0)
                        return {
                            current: {
                                name: e.name,
                                link: e.url,
                                isTop: e.isTop,
                                lastSelected: !1
                            },
                            sideMenu: [...c, ...u],
                            parent: {
                                name: l.name,
                                link: l.pageUrl
                            },
                            parents: this.getParents(e.id),
                            tagsMenu: null != u ? u : []
                        };
                    const d = this.menuByUrl.get(l.pageUrl);
                    return {
                        current: {
                            name: e.name,
                            link: e.url,
                            isTop: e.isTop,
                            lastSelected: !0
                        },
                        sideMenu: c,
                        parent: {
                            name: l.name,
                            link: l.pageUrl
                        },
                        parents: this.getParents(e.id),
                        tagsMenu: null != (i = null == (o = d.childNodes) ? void 0 : o.map((e => ({
                            name: e.name,
                            link: e.url
                        })))) ? i : []
                    }
                }
                hasItem(e) {
                    return !!e && this.menuById.has(e)
                }
                getCatalogLink(e) {
                    return this.menuById.get(e).url
                }
                getParents(e) {
                    const t = [];
                    let r = this.menuById.get(e).parentId;
                    for (; null != r; ) {
                        const e = this.menuById.get(r);
                        t.push({
                            name: e.name,
                            link: e.url,
                            isLanding: e.landing
                        }),
                        r = e.parentId
                    }
                    return t.reverse()
                }
                getRootNode(e) {
                    let t = this.menuById.get(e.id);
                    for (; null != t.parentId; )
                        t = this.menuById.get(t.parentId);
                    return this._adaptMenu(t)
                }
                _createMenuMap(e) {
                    this.brandsMenuList.items = e.promo.brands,
                    this.fullMenu = e.menu,
                    e.extraMenu && this.fullMenu.unshift(...e.extraMenu),
                    this.fullMenu.forEach((e => this._setNode(e, null)))
                }
                _setNode(e, t) {
                    var r;
                    this.menuByUrl.set(e.url, e),
                    this.menuById.set(e.id, {
                        id: e.id,
                        parentId: t,
                        url: e.url,
                        name: e.name,
                        landing: e.landing,
                        childs: e.childNodes,
                        promoId: this.promoId
                    }),
                    null == (r = e.childNodes) || r.forEach((t => this._setNode(t, e.id)))
                }
                _adaptMenu(e) {
                    var t;
                    const r = this.menuById.get(e.id);
                    return r.childs = null == (t = r.childs) ? void 0 : t.map((e => this._adaptMenu(e))),
                    r
                }
                _generateImg(e) {
                    const t = e.promo.poster;
                    t && (e.isTrend ? this._generatePoster(t) : this.isSpecial && (this._generatePoster(t),
                    this._generateCategoryImgBackground(t.category)))
                }
                _generatePoster(e) {
                    e && Hr.forEach((t => {
                        const r = e.gradient ? `no-repeat url('${e[t]}'), ${e.gradient}, ${e.background}` : `no-repeat url('${e[t]}'), ${e.background}`;
                        document.documentElement.style.setProperty(`--custom-promo-poster-${t}`, r)
                    }
                    ))
                }
                _generateCategoryImgBackground(e) {
                    document.documentElement.style.setProperty("--custom-promo-image-background", e)
                }
            }
              , Vr = Object.getOwnPropertySymbols
              , zr = Object.prototype.hasOwnProperty
              , Gr = Object.prototype.propertyIsEnumerable;
            var Qr = class {
                constructor() {
                    this.initialized = !1,
                    this.catalogMenu = null,
                    this.modules = {}
                }
                async onBeforeActionExecuting(e, t, r) {
                    var s;
                    if (this.xData = this.xInfo = this.currentMenuItem = this.products = this.type = this.sort = this.isKursk = null,
                    r.cancelRequest)
                        return;
                    this.initialized || await this._initAsync();
                    const n = new URL(e);
                    n.pathname = n.pathname.replace("/webapi", "");
                    const a = n.pathname.split("/")[2];
                    if (this.promo !== a) {
                        this.promotionsService = WbSpaModel.prototype.$services.promotionsService;
                        const e = await this.promotionsService.getPromoDataByUrl(a);
                        await this._loadPromoMenu(e, a)
                    }
                    if (!(this.catalogMenu.promoId > 0 && (this.currentMenuItem = this.catalogMenu.getCurrentMenuItem(n))))
                        return r.redirected = !0,
                        WbSpaModel.prototype.$router.moveTo404Async();
                    if (this.isKursk = 189881 === this.catalogMenu.promoId,
                    this.isKursk) {
                        if ("ru" !== wb.settings.currentLocale)
                            return r.redirected = !0,
                            this.$router.moveTo404Async();
                        this.rewriteDestTo = -2307160
                    }
                    this.currentMenuItem = this.catalogMenu.getCurrentMenuItem(n),
                    this.showCategories = null == (s = this.currentMenuItem) ? void 0 : s.isTop,
                    this.xData = this.currentMenuItem ? new this.modules.XCatalogData(this.currentMenuItem.query,this.currentMenuItem.shardKey,null,null,this.rewriteDestTo) : null,
                    this.xData.isPromo = !0,
                    this.enableEntryPromoPage = this.showCategories,
                    this.bannersTask = this.showCategories ? this._bannersTask(this.catalogMenu.promoId) : Promise.resolve(null),
                    this.xInfo = await WbSpaModel.prototype.$getCurrentXInfoWithClustersAndVectorsAsync(),
                    r.cancelRequest = null != this.xData
                }
                async onActionExecuting() {
                    if (this.xData && this.xInfo && !this.enableEntryPromoPage) {
                        let e = this.modules.QueryHelper.getInitialParams()
                          , {sort: t=this.modules.SorterModel.getSortFromCache, page: r} = e
                          , s = ( (e, t) => {
                            var r = {};
                            for (var s in e)
                                zr.call(e, s) && t.indexOf(s) < 0 && (r[s] = e[s]);
                            if (null != e && Vr)
                                for (var s of Vr(e))
                                    t.indexOf(s) < 0 && Gr.call(e, s) && (r[s] = e[s]);
                            return r
                        }
                        )(e, ["sort", "page"]);
                        const n = new this.modules.QueryHelper({
                            sort: t,
                            page: r,
                            filters: this.modules.QueryHelper.checkOnlyFilterParams(s)
                        }).getQueryStringForCatalog()
                          , a = wb.global.settings.switches.enableInfiniteScroll || WbSpaModel.prototype.$analitic.checkDataInSplitterServiceV2Sync("common", "ab_enableAutoNextPage", "yes")
                          , o = new URLSearchParams(n);
                        o.delete("page");
                        const i = this.modules.xCatalogProvider.createGoodsProvider(this.xData)
                          , {goods: l=[]} = await i.loadGoodsAsync(a ? o : n);
                        this.products = l,
                        this.sort = t
                    }
                }
                onActionExecuted(e) {
                    if (null == this.xData)
                        return;
                    e.responseData || (e.responseData = {});
                    const t = this.catalogMenu.getSitePathItems(this.currentMenuItem)
                      , r = this.enableEntryPromoPage ? this._getEntryModel(t) : this._getCatalogModel(t);
                    Object.assign(e.responseData, {
                        data: r
                    })
                }
                async _initAsync() {
                    const [e,t,r,s,n] = await Promise.all([WbSpaModel.prototype.$moduleLoader.loadModuleAsync("xCatalogData"), WbSpaModel.prototype.$moduleLoader.loadModuleAsync("queryHelper"), WbSpaModel.prototype.$moduleLoader.loadModuleAsync("xCatalogProvider"), WbSpaModel.prototype.$moduleLoader.loadModuleAsync("sorterModel"), WbSpaModel.prototype.$getService("promotionsService")]);
                    this.modules = {
                        XCatalogData: e.XCatalogData,
                        QueryHelper: t,
                        xCatalogProvider: r,
                        SorterModel: s.CatalogSorterModel
                    },
                    this.catalogMenu = new qr,
                    this.initialized = !0
                }
                async _loadPromoMenu(e, t) {
                    await this.catalogMenu.initMenu(e),
                    this.promo = this.catalogMenu ? t : null
                }
                _getEntryModel(e) {
                    var t;
                    if (this.catalogMenu.isTrend) {
                        const e = new URL(window.location.href);
                        e.pathname = this.catalogMenu.getRootNode(this.catalogMenu.getCurrentMenuItem(e)).url,
                        this.currentMenuItem = this.catalogMenu.getCurrentMenuItem(e),
                        WbSpaModel.prototype.$router.replaceState(window.history.state, document.title, e)
                    }
                    return {
                        mainVersion: 0,
                        type: Ir.promoEntry,
                        model: {
                            xData: this.xData,
                            menuId: this.currentMenuItem.id,
                            currentMenuItem: this.catalogMenu.menuById.get(this.currentMenuItem.id),
                            rootMenuItem: this.catalogMenu.getRootNode(this.currentMenuItem),
                            children: this.currentMenuItem.childNodes,
                            sitePathItems: e,
                            title: null != (t = this.currentMenuItem.seo) ? t : this.currentMenuItem.name,
                            needAdultProtection: !wb.adult.isConfirmed,
                            catalogMenu: this.catalogMenu,
                            promoId: this.catalogMenu.promoId,
                            catalogPromoLeftMenu: this.catalogMenu.getCatalogMenu(this.currentMenuItem, e),
                            bannersTask: this.bannersTask,
                            isSpecial: this.catalogMenu.isSpecial,
                            catalogType: Ir.promoEntry,
                            isKursk: this.isKursk,
                            shelves: this.catalogMenu.shelves,
                            isExtended: this.catalogMenu.isExtended
                        }
                    }
                }
                _getCatalogModel(e) {
                    var t;
                    return {
                        mainVersion: 0,
                        type: Ir.goods,
                        model: {
                            xData: this.xData,
                            menuId: this.currentMenuItem.id,
                            currentMenuItem: this.catalogMenu.menuById.get(this.currentMenuItem.id),
                            rootMenuItem: this.catalogMenu.getRootNode(this.currentMenuItem),
                            selectedHasChild: !!this.currentMenuItem.childs,
                            sitePathItems: e,
                            promoMenuV2: !0,
                            catalogPromoLeftMenu: this.catalogMenu.getCatalogMenu(this.currentMenuItem, e),
                            emptyCatalogLink: this.currentMenuItem.url,
                            tagsUrl: this.currentMenuItem.url,
                            products: this.products,
                            targetUrl: "GP",
                            title: null != (t = this.currentMenuItem.seo) ? t : this.currentMenuItem.name,
                            containerClass: "catalog-page",
                            needAdultProtection: !wb.adult.isConfirmed,
                            sorterModel: new this.modules.SorterModel(this.sort,this.currentMenuItem.url),
                            promoId: this.catalogMenu.promoId,
                            isSpecial: this.catalogMenu.isSpecial,
                            isKursk: this.isKursk,
                            shelves: this.catalogMenu.shelves,
                            isExtended: this.catalogMenu.isExtended,
                            isTrend: this.catalogMenu.isTrend
                        }
                    }
                }
                async _bannersTask(e) {
                    return this.catalogMenu.isExtended ? WbSpaModel.prototype.$services.bannersService.getPromotionSpecialBanners() : WbSpaModel.prototype.$services.bannersService.getPromoCatalogBanners(e)
                }
            }
            ;
            class Jr {
                get menuBase() {
                    return Jr.prototype.menuBaseData
                }
                set menuBase(e) {
                    Jr.prototype.menuBaseData = e
                }
                static get menuById() {
                    return Jr.prototype.menuByIdData
                }
                static async init() {
                    var e;
                    if (Jr.prototype.menuBaseData)
                        return;
                    Jr.prototype.menuBaseData = null != (e = await WbSpaModel.prototype.$httpClient.fetchStaticDataV2("subject-base.json", 1e4)) ? e : [],
                    Jr.prototype.menuByIdData = new Map,
                    Jr.prototype._createMenuMap()
                }
                _createMenuMap() {
                    Jr.prototype.menuBase.forEach((e => Jr.prototype._setNode(e, null)))
                }
                _setNode(e, t) {
                    var r;
                    t && (e.parentId = t),
                    Jr.prototype.menuByIdData.set(e.id, e),
                    null == (r = e.childs) || r.forEach((t => Jr.prototype._setNode(t, e.id)))
                }
            }
            var Kr = Jr;
            var Xr = class extends Kr {
                constructor(e, t) {
                    super(),
                    this.modules = e,
                    this.brandConstructorService = t,
                    this.brandData = null,
                    this.fullMenu = null,
                    this.menuByUrl = new Map,
                    this.menuById = new Map
                }
                async initMenu(e, t, r, s) {
                    var n;
                    let a = await WbSpaModel.prototype.$httpClient.fetchStaticV3(wb.helpers.url.urlStaticData, {}, `brands/${e}.json`);
                    if (!a) {
                        const t = null == (n = e.split("-")) ? void 0 : n[0];
                        t && (a = await WbSpaModel.prototype.$httpClient.fetchStaticV3(wb.helpers.url.urlStaticData, {}, `brands-by-id/${t}.json`)),
                        a && (location.href = $.views.helpers.brandUrl(a.url))
                    }
                    if (!a)
                        return null;
                    super.menuBase || await Kr.init(),
                    this.isConstructor = t.indexOf(a.id) >= 0,
                    this.brandData = a;
                    const o = $.views.helpers.brandUrl(a.url)
                      , i = await this._getMenuItems(a, r, o, s);
                    this.fullMenu = this._getFullMenu(a, o, i, this.infoMenu),
                    this._createMenuMap(),
                    this.isInited = !0
                }
                _getFullMenu(e, t, r, s=[]) {
                    return [{
                        id: e.id + "b",
                        name: e.name,
                        url: t,
                        shard: this.isConstructor ? "" : this._brandToShard(e.name),
                        query: this.isConstructor ? "" : this._brandToQuery(e.id),
                        childs: r.concat(s)
                    }]
                }
                async _getMenuItems(e, t, r, s) {
                    var n, a, o;
                    if (!this.isConstructor)
                        return await this._getChildsFromSubjects(e, t, r);
                    const i = this.brandConstructorService.getPageInfo(s)
                      , l = await this.brandConstructorService.getMenus(e, i.pageType, i.infoUrl, i.previewMode);
                    if (this.previewMode = i.previewMode,
                    this.hasCustomMenu = (null == (n = null == l ? void 0 : l.menu) ? void 0 : n.length) > 0,
                    (null == (o = null == (a = null == l ? void 0 : l.infoMenu) ? void 0 : a.menuInfoItems) ? void 0 : o.length) > 0 && (this.infoMenu = l.infoMenu.menuInfoItems.map((t => (t.id = `${t.id}info`,
                    t.url = `${r}/info/${t.href}`,
                    t.isInfo = !0,
                    this._convertBrandScemeItemToMenuItemDTO(t, e))))),
                    this.hasCustomMenu)
                        return await this._getChildsFromCustomMenu(e, l.menu);
                    const c = await this._getChildsFromSubjects(e, t, r)
                      , u = {
                        id: e.id + "b-all",
                        name: "Весь ассортимент",
                        url: `${r}/all`,
                        seo: `${e.name} Весь ассортимент`,
                        shard: this._brandToShard(e.name),
                        query: this._brandToQuery(e.id),
                        childs: []
                    };
                    return c.push(u),
                    c
                }
                async _getChildsFromCustomMenu(e, t) {
                    const r = t.map((t => this._convertBrandScemeItemToMenuItemDTO(t, e, !0)));
                    return r.sort(( (e, t) => e - t)),
                    r
                }
                async _getChildsFromSubjects(e, t, r) {
                    var s, n, a, o;
                    const i = this._brandToShard(e.name)
                      , l = this._brandToQuery(e.id)
                      , c = new this.modules.XCatalogData(l,i,"Brand")
                      , u = this.modules.xCatalogProvider.createGoodsProvider(c)
                      , d = await u.loadSubjectsAsync(t, c)
                      , p = null != (a = null == (n = null == (s = null == d ? void 0 : d.data) ? void 0 : s.filters.find((e => "xsubject" === e.key))) ? void 0 : n.items.map((e => e.id))) ? a : []
                      , h = [];
                    for (const t of this.menuBase) {
                        let s = !1;
                        const n = [];
                        for (const a of null != (o = null == t ? void 0 : t.childs) ? o : [])
                            if (p.indexOf(a.id) >= 0) {
                                s = !0;
                                const t = Object.assign({}, a);
                                t.seo = `${e.name} ${a.name}`,
                                t.url = `${r}/${t.url}`,
                                t.shard = this._brandToShard(e.name),
                                t.query = this._brandToQuery(e.id, t.id),
                                n.push(t)
                            }
                        if (s) {
                            const s = Object.assign({}, t);
                            s.seo = `${e.name} ${t.name}`,
                            s.url = `${r}/${t.url}`,
                            s.shard = this._brandToShard(e.name),
                            s.query = this._brandToQuery(e.id, s.id),
                            s.childs = n,
                            s.parent = e.id + "b",
                            h.push(s)
                        }
                    }
                    return h
                }
                _convertBrandScemeItemToMenuItemDTO(e, t, r) {
                    const s = this._getXQueryForMenuItem(t, e.query)
                      , n = {
                        id: e.id,
                        name: e.title,
                        url: e.url.toLowerCase(),
                        seo: `${t.name} ${e.title}`,
                        sort: e.sort,
                        shard: this._brandToShard(t.name),
                        query: s
                    };
                    return r && (n.isCustom = r,
                    n.parentId = t.id + "b"),
                    e.isInfo && (n.isInfo = !0),
                    n
                }
                _getXQueryForMenuItem(e, t) {
                    const r = new URLSearchParams(t);
                    return r.has("type") && r.delete("type"),
                    r.set("brand", e.id),
                    decodeURIComponent(r)
                }
                getBrandInfo() {
                    return {
                        id: this.brandData.siteId,
                        brandCod: this.brandData.id,
                        name: this.brandData.name,
                        brandLink: $.views.helpers.brandUrl(this.brandData.url),
                        hash: this.brandData.hash
                    }
                }
                getCurrentMenuItem(e) {
                    var t;
                    if (!(e = null != (t = null == e ? void 0 : e.pathname) ? t : e))
                        return null;
                    const r = e.replace("/data", "").replace("/preview", "");
                    let s = this.menuByUrl.get(r);
                    return !s && this.hasCustomMenu && this.menuByUrl.forEach((e => {
                        e.url.split("?")[0] == r && (s = e)
                    }
                    )),
                    null != s ? s : this.menuByUrl.get(r.slice(0, r.lastIndexOf("/")))
                }
                getSitePathItems(e) {
                    if (!e)
                        return null;
                    const t = [];
                    t.push({
                        id: e.id,
                        name: e.name,
                        pageUrl: e.url,
                        isInfo: e.isInfo,
                        analytic: ["BCA", null, null, e.id]
                    });
                    let r = this.menuById.get(e.id).parentId;
                    for (; null != r; ) {
                        const e = this.menuById.get(r);
                        t.push({
                            id: r,
                            name: e.name,
                            pageUrl: e.url,
                            analytic: ["BCA", null, null, r]
                        }),
                        r = e.parentId
                    }
                    const s = this._brandLetterToSitePathParam(this.brandData.letter);
                    return t.push({
                        id: 0,
                        name: `Бренды на «${s.toUpperCase()}»`,
                        pageUrl: `/wildberries/brandlist.aspx?letter=${s}`
                    }),
                    t.reverse()
                }
                getCatalogMenu(e) {
                    var t, r, s, n;
                    const a = [];
                    if ((e = null == e ? void 0 : e.filter((e => !e.isInfo))) && 0 !== e.length)
                        if (1 === e.length) {
                            const s = {
                                name: "",
                                link: ""
                            }
                              , n = null != (r = null == (t = this.menuByUrl.get(e[0].pageUrl).childs) ? void 0 : t.filter((e => !e.isInfo)).map((e => ({
                                node: {
                                    id: e.id,
                                    name: e.name,
                                    link: e.url
                                },
                                children: []
                            })))) ? r : [];
                            a.push({
                                node: s,
                                children: n
                            })
                        } else {
                            const t = this.menuByUrl.get(e[1].pageUrl)
                              , r = {
                                id: t.id,
                                isOpen: !0,
                                lastSelected: e[e.length - 1].id === t.id,
                                link: t.isDenyLink ? null : t.url,
                                name: t.name
                            }
                              , o = r.lastSelected ? null != (n = null == (s = t.childs) ? void 0 : s.filter((e => !e.isInfo)).map((e => ({
                                node: {
                                    id: e.id,
                                    name: e.name,
                                    link: e.url
                                },
                                children: []
                            })))) ? n : [] : this.getCatalogMenu(e.slice(1));
                            a.push({
                                node: r,
                                children: o
                            })
                        }
                    else
                        a.push({
                            node: {
                                name: "",
                                link: ""
                            },
                            children: []
                        });
                    return a
                }
                hasItem(e) {
                    return !!e && this.menuById.has(e)
                }
                getCatalogLink(e) {
                    return this.menuById.get(e).url
                }
                getParents(e) {
                    const t = [];
                    let r = this.menuById.get(e).parentId;
                    for (; null != r; ) {
                        const e = this.menuById.get(r);
                        t.push(e.name),
                        r = e.parentId
                    }
                    return t.reverse()
                }
                getRootNode(e) {
                    let t = this.menuById.get(e.id);
                    for (; null != t.parentId; )
                        t = this.menuById.get(t.parentId);
                    return this._adaptMenu(t)
                }
                _createMenuMap() {
                    this.fullMenu.forEach((e => this._setNode(e, null)))
                }
                _setNode(e, t, r) {
                    var s;
                    this.menuByUrl.set(e.url, e),
                    this.menuById.set(e.id, {
                        parentId: t,
                        url: e.url,
                        name: e.name,
                        childs: e.childs,
                        id: e.id
                    }),
                    null == (s = e.childs) || s.forEach((t => this._setNode(t, e.id, r)))
                }
                _brandToShard(e) {
                    const t = e ? e.toLowerCase() : " "
                      , r = t.charCodeAt(0);
                    return 48 <= r && r <= 57 || 97 <= r && r <= 122 || 1072 <= r && r <= 1105 ? `brands/${t[0]}` : "brands/special"
                }
                _brandToQuery(e, t) {
                    return t ? `brand=${e}&subject=${t}` : `brand=${e}`
                }
                _brandLetterToSitePathParam(e) {
                    const t = e.charCodeAt(0);
                    return 1072 <= t && t <= 1105 ? "а-я" : 97 <= t && t <= 122 ? e : "123"
                }
                _adaptMenu(e) {
                    var t;
                    const r = this.menuById.get(e.id);
                    return r.childs = null == (t = r.childs) ? void 0 : t.map((e => this._adaptMenu(e))),
                    r
                }
            }
              , Yr = Object.getOwnPropertySymbols
              , Zr = Object.prototype.hasOwnProperty
              , es = Object.prototype.propertyIsEnumerable;
            var ts = class {
                constructor(e) {
                    Object.assign(this, e)
                }
                async onBeforeActionExecuting(e, t, r) {
                    this.xData = new this.modules.XCatalogData(this.currentMenuItem.query,this.currentMenuItem.shard,"Brand"),
                    r.cancelRequest = null != this.xData
                }
                async onActionExecuting(e, t, r) {
                    if (this.xData && this.xInfo) {
                        let e = this.modules.QueryHelper.getInitialParams()
                          , {sort: t=this.modules.SorterModel.getSortFromCache, page: s, sle: n} = e
                          , a = ( (e, t) => {
                            var r = {};
                            for (var s in e)
                                Zr.call(e, s) && t.indexOf(s) < 0 && (r[s] = e[s]);
                            if (null != e && Yr)
                                for (var s of Yr(e))
                                    t.indexOf(s) < 0 && es.call(e, s) && (r[s] = e[s]);
                            return r
                        }
                        )(e, ["sort", "page", "sle"]);
                        if ("adidas" === this.brand && n)
                            return r.redirected = !0,
                            void this.$router.moveTo404Async();
                        const o = new this.modules.QueryHelper({
                            sort: t,
                            page: s,
                            filters: this.modules.QueryHelper.checkOnlyFilterParams(a)
                        }).getQueryStringForCatalog()
                          , i = wb.global.settings.switches.enableInfiniteScroll || WbSpaModel.prototype.$analitic.checkDataInSplitterServiceV2Sync("common", "ab_enableAutoNextPage", "yes")
                          , l = new URLSearchParams(o);
                        l.delete("page");
                        const c = this.modules.xCatalogProvider.createGoodsProvider(this.xData)
                          , {goods: u=[]} = await c.loadGoodsAsync(i ? l : o);
                        this.products = u,
                        this.sort = t
                    }
                }
                onActionExecuted(e) {
                    var t;
                    if (null == this.xData)
                        return;
                    e.responseData || (e.responseData = {});
                    const r = this.catalogMenu.getSitePathItems(this.currentMenuItem)
                      , s = {
                        mainVersion: 0,
                        type: Ir.brand,
                        model: {
                            brandInfo: this.catalogMenu.getBrandInfo(),
                            xData: this.xData,
                            currentMenuItem: this.currentMenuItem,
                            rootMenuItem: this.catalogMenu.getRootNode(this.currentMenuItem),
                            selectedHasChild: !1,
                            sitePathItems: r,
                            catalogMenu: this.catalogMenu.getCatalogMenu(null == r ? void 0 : r.slice(1)),
                            emptyCatalogLink: this.currentMenuItem.url,
                            tagsUrl: this.currentMenuItem.url,
                            products: this.products,
                            promoMenuV2: !1,
                            targetUrl: "BP",
                            title: null != (t = this.currentMenuItem.seo) ? t : this.currentMenuItem.name,
                            containerClass: "catalog-page",
                            needAdultProtection: !wb.adult.isConfirmed,
                            sorterModel: new this.modules.SorterModel(this.sort,this.currentMenuItem.url)
                        }
                    };
                    Object.assign(e.responseData, {
                        data: s
                    })
                }
            }
              , rs = Object.getOwnPropertySymbols
              , ss = Object.prototype.hasOwnProperty
              , ns = Object.prototype.propertyIsEnumerable;
            var as = class {
                constructor(e) {
                    Object.assign(this, e)
                }
                async onBeforeActionExecuting(e, t, r) {
                    this.xData = new this.modules.XCatalogData(this.currentMenuItem.query,this.currentMenuItem.shard,"Brand"),
                    r.cancelRequest = null != this.xData
                }
                async onActionExecuting() {
                    if (this.xData && this.xData.xcatalogShard && this.xInfo) {
                        let e = this.modules.QueryHelper.getInitialParams()
                          , {sort: t=this.modules.SorterModel.getSortFromCache, page: r, sle: s} = e
                          , n = ( (e, t) => {
                            var r = {};
                            for (var s in e)
                                ss.call(e, s) && t.indexOf(s) < 0 && (r[s] = e[s]);
                            if (null != e && rs)
                                for (var s of rs(e))
                                    t.indexOf(s) < 0 && ns.call(e, s) && (r[s] = e[s]);
                            return r
                        }
                        )(e, ["sort", "page", "sle"]);
                        if ("adidas" === this.brand && s)
                            return options.redirected = !0,
                            void this.$router.moveTo404Async();
                        const a = new this.modules.QueryHelper({
                            sort: t,
                            page: r,
                            filters: this.modules.QueryHelper.checkOnlyFilterParams(n)
                        }).getQueryStringForCatalog()
                          , o = this.modules.xCatalogProvider.createGoodsProvider(this.xData)
                          , {goods: i=[]} = await o.loadGoodsAsync(a);
                        this.products = i,
                        this.sort = t
                    }
                }
                async onActionExecuted(e) {
                    if (null == this.xData)
                        return;
                    e.responseData || (e.responseData = {});
                    const t = this.catalogMenu.getSitePathItems(this.currentMenuItem)
                      , r = this.catalogMenu.getCatalogMenu(null == t ? void 0 : t.slice(1))
                      , s = this.brandConstructorService.convertSchemeToViewModel(this.brandScheme, this.catalogMenu, this.currentMenuItem);
                    await WbSpaModel.prototype.$moduleLoader.loadModuleAsync("brandConstructorConfig");
                    const n = await this._getMetaTags(this.currentMenuItem)
                      , a = {
                        brandInfo: this.catalogMenu.getBrandInfo(),
                        currentMenuItem: this.currentMenuItem,
                        rootMenuItem: this.catalogMenu.getRootNode(this.currentMenuItem),
                        containerClass: "brand-constructor-catalog",
                        isCatalog: !0,
                        needAdultProtection: !wb.adult.isConfirmed,
                        sitePathItems: t,
                        catalogMenu: r,
                        brandScheme: s,
                        title: this.currentMenuItem.seo,
                        metaTags: n,
                        tagsUrl: this.currentMenuItem.url,
                        sorterModel: new this.modules.SorterModel(this.sort,this.currentMenuItem.url),
                        products: this.products,
                        xData: this.xData,
                        targetUrl: "BP",
                        emptyCatalogLink: this.currentMenuItem.url
                    }
                      , o = {
                        mainVersion: 0,
                        type: Ir.brandConstructorCatalog,
                        model: a
                    };
                    Object.assign(e.responseData, {
                        data: o
                    })
                }
                async _getMetaTags(e) {
                    var t;
                    try {
                        const r = e.url.split("?")[0].replace("brands/", "brands/metatags/")
                          , s = await WbSpaModel.prototype.$httpClient.fetchJSON(`/webapi/spa${r}?${new URLSearchParams({
                            name: e.name
                        })}`, {}, {
                            timeout: 3e3,
                            nullOnError: !0
                        });
                        return null != (t = null == s ? void 0 : s.metaTags) ? t : []
                    } catch (e) {
                        return []
                    }
                }
            }
            ;
            var os = class {
                constructor(e) {
                    Object.assign(this, e)
                }
                async onBeforeActionExecuting(e, t, r) {
                    r.cancelRequest = null != this.currentMenuItem
                }
                async onActionExecuting() {}
                async onActionExecuted(e) {
                    e.responseData || (e.responseData = {});
                    const t = this.catalogMenu.getSitePathItems(this.currentMenuItem)
                      , r = this.catalogMenu.getCatalogMenu(null == t ? void 0 : t.slice(1))
                      , s = this.brandConstructorService.convertSchemeToViewModel(this.brandScheme, this.catalogMenu, this.currentMenuItem)
                      , n = await this.brandConstructorService.getMainBanners(this.catalogMenu);
                    await WbSpaModel.prototype.$moduleLoader.loadModuleAsync("brandConstructorConfig");
                    const a = {
                        brandInfo: this.catalogMenu.getBrandInfo(),
                        brandDirections: {},
                        containerClass: "brand-constructor-ordinary",
                        isCatalog: !1,
                        needAdultProtection: !wb.adult.isConfirmed,
                        sitePathItems: t,
                        catalogMenu: r,
                        brandScheme: s,
                        mainBanners: n
                    }
                      , o = {
                        mainVersion: 0,
                        type: Ir.brandConstructor,
                        model: a
                    };
                    Object.assign(e.responseData, {
                        data: o
                    })
                }
            }
            ;
            var is = class {
                constructor(e) {
                    this.initialized = !1,
                    this.catalogMenu = null,
                    this.modules = {},
                    this.preview = e,
                    this.pipeline = null
                }
                async onBeforeActionExecuting(e, t, r) {
                    var s, n;
                    if (this.xData = this.xInfo = this.currentMenuItem = this.products = this.sort = this.pipeline = this.brandScheme = null,
                    r.cancelRequest)
                        return;
                    let a = new URL(e);
                    a.pathname = a.pathname.replace("/webapi", "").toLowerCase();
                    const o = a.pathname.split("/")[this.preview ? 4 : 3];
                    if (this.brand !== o && (this.initialized = !1,
                    this.brand = this.catalogMenu = null),
                    this.brand === o && this.initialized || await this._initAsync(this.preview),
                    this.xInfo = await WbSpaModel.prototype.$getCurrentXInfoWithClustersAndVectorsAsync(),
                    this.brand !== o && await this._loadBrandMenu(o, a.pathname),
                    this.brand) {
                        if (this.preview && !this.catalogMenu.isConstructor && (a = new URL(e.href.replace("/preview", "")),
                        a.pathname = a.pathname.replace("/webapi", "").toLowerCase()),
                        this.currentMenuItem = this.catalogMenu.getCurrentMenuItem(a),
                        !this.currentMenuItem)
                            return r.cancelRequest = !1,
                            void (r.cancelRequest || (t.body = await WbSpaModel.prototype.$getCurrentXInfoWithClustersAndVectorsAsync()));
                        if (this.catalogMenu.isConstructor) {
                            const e = this.brandConstructorService.getPageInfo(a.pathname)
                              , t = null == e ? void 0 : e.pageType
                              , r = null == e ? void 0 : e.infoUrl;
                            this.brandScheme = await this.brandConstructorService.getBrandSchemeAsync(this.catalogMenu.brandData, t, r, e.previewMode),
                            this.brandScheme || (this.ids = [],
                            await this._loadBrandMenu(o, a.pathname, !0))
                        }
                        return this.catalogMenu.isConstructor ? this.brandScheme.pageType == this.brandConstructorService.enums.pageType.catalog ? this.pipeline = new as(this) : this.pipeline = new os(this) : this.pipeline = new ts(this),
                        null == (n = (s = this.pipeline).onBeforeActionExecuting) ? void 0 : n.call(s, e, t, r)
                    }
                    r.cancelRequest = !1
                }
                async onActionExecuting(e, t, r) {
                    var s, n;
                    return null == (n = null == (s = this.pipeline) ? void 0 : s.onActionExecuting) ? void 0 : n.call(s, e, t, r)
                }
                onActionExecuted(e) {
                    var t, r;
                    return null == (r = null == (t = this.pipeline) ? void 0 : t.onActionExecuted) ? void 0 : r.call(t, e)
                }
                async _initAsync(e) {
                    const t = this._initConstructorServiceAndGetBrands(e)
                      , [r,s,n,a,o] = await Promise.all([WbSpaModel.prototype.$moduleLoader.loadModuleAsync("xCatalogData"), WbSpaModel.prototype.$moduleLoader.loadModuleAsync("queryHelper"), WbSpaModel.prototype.$moduleLoader.loadModuleAsync("xCatalogProvider"), WbSpaModel.prototype.$moduleLoader.loadModuleAsync("sorterModel"), WbSpaModel.prototype.$getService("promotionsService")]);
                    this.modules = {
                        XCatalogData: r.XCatalogData,
                        QueryHelper: s,
                        xCatalogProvider: n,
                        SorterModel: a.CatalogSorterModel
                    },
                    this.ids = await t,
                    this.catalogMenu = new Xr(this.modules,this.brandConstructorService),
                    this.initialized = !0
                }
                async _initConstructorServiceAndGetBrands(e) {
                    var t;
                    return await WbSpaModel.prototype.$moduleLoader.loadServiceAsync("brandConstructorService"),
                    this.brandConstructorService = WbSpaModel.prototype.$services.brandConstructorService,
                    null != (t = await this.brandConstructorService.getConstructorBrands(e)) ? t : []
                }
                async _loadBrandMenu(e, t) {
                    await this.catalogMenu.initMenu(e, this.ids, this.xInfo, t),
                    this.brand = this.catalogMenu.brandData ? e : null
                }
            }
            ;
            var ls = class extends Kr {
                constructor(e) {
                    super(),
                    this.modules = e,
                    this.sellerData = null,
                    this.fullMenu = null,
                    this.menuByUrl = new Map,
                    this.menuById = new Map,
                    this.shard = "sellers"
                }
                async initMenu(e, t) {
                    var r, s, n, a, o, i, l;
                    super.menuBase || await Kr.init();
                    const c = this.shard
                      , u = this._sellerToQuery(e, null)
                      , d = new this.modules.XCatalogData(u,c,"Seller")
                      , p = this.modules.xCatalogProvider.createGoodsProvider(d)
                      , h = await p.loadSubjectsAsync(t, d)
                      , m = await this._getSellerData(e);
                    this.sellerData = m,
                    this.fullMenu = [{
                        id: m.id + "s",
                        name: this._trimSellerOrgForms(null != (s = null != (r = m.trademark) ? r : m.fineName) ? s : m.name, m.orgForms),
                        url: "/seller/" + m.id,
                        shard: this.shard,
                        query: this._sellerToQuery(m.id, null),
                        childs: [],
                        title: "Все товары"
                    }];
                    const g = null != (o = null == (a = null == (n = null == h ? void 0 : h.data) ? void 0 : n.filters.find((e => "xsubject" === e.key))) ? void 0 : a.items.toHashSet((e => e.id))) ? o : new Set;
                    for (const e of this.menuBase) {
                        let t = !1;
                        const r = [];
                        for (const s of null != (i = null == e ? void 0 : e.childs) ? i : [])
                            if (g.has(s.id)) {
                                t = !0;
                                const e = Object.assign({}, s);
                                e.url = `/seller/${m.id}/${e.url}`,
                                e.shard = this.shard,
                                e.query = this._sellerToQuery(m.id, e.id),
                                e.parentId = null != (l = e.parentId) ? l : m.id + "s",
                                e.title = e.name,
                                r.push(e)
                            }
                        if (t) {
                            const t = Object.assign({}, e);
                            t.url = `/seller/${m.id}/${e.url}`,
                            t.shard = this.shard,
                            t.query = this._sellerToQuery(m.id, t.id),
                            t.childs = r,
                            t.parentId = m.id + "s",
                            t.title = t.name,
                            this.fullMenu[0].childs.push(t)
                        }
                    }
                    this._createMenuMap(),
                    this.isInited = !0
                }
                getSellerInfo() {
                    return this.sellerData
                }
                getCurrentMenuItem(e) {
                    var t;
                    if (!e)
                        return null;
                    const r = e.pathname.replace("/data", "");
                    return null != (t = this.menuByUrl.get(r)) ? t : this.menuByUrl.get(r.slice(0, r.lastIndexOf("/")))
                }
                getSitePathItems(e) {
                    if (!e)
                        return null;
                    const t = [];
                    t.push({
                        id: e.id,
                        name: e.name,
                        pageUrl: e.url
                    });
                    let r = this.menuById.get(e.id).parentId;
                    for (; null != r; ) {
                        const e = this.menuById.get(r);
                        t.push({
                            id: r,
                            name: e.name,
                            pageUrl: e.url
                        }),
                        r = e.parentId
                    }
                    return t.reverse()
                }
                getCatalogMenu(e) {
                    var t, r, s, n;
                    const a = [];
                    if (e && 0 !== e.length)
                        if (1 === e.length) {
                            const s = {
                                name: "",
                                link: ""
                            }
                              , n = null != (r = null == (t = this.menuByUrl.get(e[0].pageUrl).childs) ? void 0 : t.map((e => ({
                                node: {
                                    id: e.id,
                                    name: e.name,
                                    link: e.url
                                },
                                children: []
                            })))) ? r : [];
                            a.push({
                                node: s,
                                children: n
                            })
                        } else {
                            const t = this.menuByUrl.get(e[1].pageUrl)
                              , r = {
                                id: t.id,
                                isOpen: !0,
                                lastSelected: e[e.length - 1].id === t.id,
                                link: t.url,
                                name: t.name
                            }
                              , o = r.lastSelected ? null != (n = null == (s = t.childs) ? void 0 : s.map((e => ({
                                node: {
                                    id: e.id,
                                    name: e.name,
                                    link: e.url
                                },
                                children: []
                            })))) ? n : [] : this.getCatalogMenu(e.slice(1));
                            a.push({
                                node: r,
                                children: o
                            })
                        }
                    else
                        a.push({
                            node: {
                                name: "",
                                link: ""
                            },
                            children: []
                        });
                    return a
                }
                hasItem(e) {
                    return !!e && this.menuById.has(e)
                }
                getCatalogLink(e) {
                    return this.menuById.get(e).url
                }
                getParents(e) {
                    const t = [];
                    let r = this.menuById.get(e).parentId;
                    for (; null != r; ) {
                        const e = this.menuById.get(r);
                        t.push(e.name),
                        r = e.parentId
                    }
                    return t.reverse()
                }
                getRootNode(e) {
                    let t = this.menuById.get(e.id);
                    for (; null != t.parentId; )
                        t = this.menuById.get(t.parentId);
                    return this._adaptMenu(t)
                }
                async _getSellerData(e) {
                    var t;
                    const r = {
                        id: e,
                        isUnknown: !0,
                        name: $.localize("Продавец")
                    }
                      , s = await WbSpaModel.prototype.$httpClient.fetchStaticV3(wb.helpers.url.urlStaticData, {}, `supplier-by-id/${e}.json`);
                    if (!s)
                        return r;
                    const n = WbSpaModel.prototype.$services.suppliersService.setSupplierInfo(s);
                    return {
                        id: n.supplierId,
                        name: null != (t = n.supplierFullName) ? t : n.supplierName,
                        fineName: this._trimSellerOrgForms(n.supplierName, n.orgForms),
                        ogrn: n.ogrn,
                        ogrnip: n.ogrnip,
                        taxpayerCode: n.taxpayerCode,
                        inn: n.inn,
                        kpp: n.kpp,
                        unp: n.unp,
                        bin: n.bin,
                        unn: n.unn,
                        trademark: n.trademark,
                        legalAddress: n.legalAddress,
                        isUnknown: !1,
                        orgForms: n.orgForms
                    }
                }
                _trimSellerOrgForms(e, t=[]) {
                    return $.views.converters.trimWord(e, t)
                }
                _createMenuMap() {
                    this.fullMenu.forEach((e => this._setNode(e, null)))
                }
                _setNode(e, t) {
                    var r;
                    this.menuByUrl.set(e.url, e),
                    this.menuById.set(e.id, {
                        parentId: t,
                        url: e.url,
                        name: e.name,
                        id: e.id,
                        childs: e.childs
                    }),
                    null == (r = e.childs) || r.forEach((t => this._setNode(t, e.id)))
                }
                _sellerToQuery(e, t) {
                    return t ? `supplier=${e}&subject=${t}` : `supplier=${e}`
                }
                _adaptMenu(e) {
                    var t;
                    const r = this.menuById.get(e.id);
                    return r.childs = null == (t = r.childs) ? void 0 : t.map((e => this._adaptMenu(e))),
                    r
                }
            }
              , cs = Object.getOwnPropertySymbols
              , us = Object.prototype.hasOwnProperty
              , ds = Object.prototype.propertyIsEnumerable;
            var ps = class {
                constructor() {
                    this.initialized = !1,
                    this.catalogMenu = null,
                    this.modules = {}
                }
                async onBeforeActionExecuting(e, t, r) {
                    var s;
                    if (this.xData = this.xInfo = this.currentMenuItem = this.products = this.type = this.sort = null,
                    r.cancelRequest)
                        return;
                    this.initialized || await this._initAsync();
                    let n = new URL(e);
                    n.pathname = n.pathname.replace("/webapi", "");
                    let a = n.pathname.split("/")[3];
                    if (wb.global.settings.switches.enableNewShopWindow) {
                        let e = function(e) {
                            return wb.helpers.url.urlStaticBasket(`constructor-api/shops/${a}.json`, 0, e)
                        };
                        if (this.constructorData = await WbSpaModel.prototype.$httpClient.fetchStaticV3(e),
                        this.constructorData && isNaN(a))
                            n.pathname = `/seller/data/${this.constructorData.supplierID}`,
                            a = this.constructorData.supplierID;
                        else if (this.constructorData && !isNaN(a) && (null == (s = this.constructorData.urlPath) ? void 0 : s.length) > 0) {
                            const e = window.location.pathname.replace(a, this.constructorData.urlPath).replace("/data", "") + n.search;
                            window.history.replaceState(null, null, e)
                        }
                        const t = new URLSearchParams(n.search);
                        if (this.isPreview = t.get("preview"),
                        this.isPreview) {
                            let e = function(e) {
                                return wb.helpers.url.urlStaticBasket(`constructor-api/shops/moderation/${a}.json`, 0, e)
                            };
                            document.body.classList.add("body--no-click");
                            const t = await WbSpaModel.prototype.$httpClient.fetchStaticV3(e);
                            this.constructorData = t
                        }
                    }
                    this.xInfo = await WbSpaModel.prototype.$getCurrentXInfoWithClustersAndVectorsAsync(),
                    this.seller !== a && await this._loadBrandMenu(a),
                    this.catalogMenu.isConstructor ? t.body = this.xInfo : (this.seller && (this.currentMenuItem = this.catalogMenu.getCurrentMenuItem(n),
                    this.xData = new this.modules.XCatalogData(this.currentMenuItem.query,this.currentMenuItem.shard,"Seller")),
                    r.cancelRequest = null != this.xData)
                }
                async onActionExecuting() {
                    if (this.xData && this.xInfo) {
                        let e = this.modules.QueryHelper.getInitialParams()
                          , {sort: t=this.modules.SorterModel.getSortFromCache, page: r} = e
                          , s = ( (e, t) => {
                            var r = {};
                            for (var s in e)
                                us.call(e, s) && t.indexOf(s) < 0 && (r[s] = e[s]);
                            if (null != e && cs)
                                for (var s of cs(e))
                                    t.indexOf(s) < 0 && ds.call(e, s) && (r[s] = e[s]);
                            return r
                        }
                        )(e, ["sort", "page"]);
                        const n = new this.modules.QueryHelper({
                            sort: t,
                            page: r,
                            filters: this.modules.QueryHelper.checkOnlyFilterParams(s)
                        }).getQueryStringForCatalog()
                          , a = this.modules.xCatalogProvider.createGoodsProvider(this.xData)
                          , {goods: o} = await a.loadGoodsAsync(n);
                        this.products = o,
                        this.sort = t
                    }
                }
                async onActionExecuted(e) {
                    if (null == this.xData)
                        return;
                    e.responseData || (e.responseData = {});
                    const t = this.catalogMenu.getSitePathItems(this.currentMenuItem)
                      , r = {
                        mainVersion: 0,
                        type: Ir.seller,
                        model: {
                            sellerId: this.catalogMenu.sellerData.id,
                            sellerInfo: this.catalogMenu.getSellerInfo(),
                            xData: this.xData,
                            rootMenuItem: this.catalogMenu.getRootNode(this.currentMenuItem),
                            currentMenuItem: this.currentMenuItem,
                            selectedHasChild: !1,
                            sitePathItems: t,
                            catalogMenu: this.catalogMenu.getCatalogMenu(t),
                            emptyCatalogLink: this.currentMenuItem.url,
                            tagsUrl: this.currentMenuItem.url,
                            products: this.products,
                            promoMenuV2: !1,
                            title: this.currentMenuItem.title,
                            containerClass: "catalog-page catalog-page--brand",
                            needAdultProtection: !wb.adult.isConfirmed,
                            sorterModel: new this.modules.SorterModel(this.sort,this.currentMenuItem.url),
                            constructorData: this.constructorData,
                            isPreview: this.isPreview
                        }
                    };
                    Object.assign(e.responseData, {
                        data: r
                    })
                }
                async _initAsync() {
                    const [e,t,r,s,n] = await Promise.all([WbSpaModel.prototype.$moduleLoader.loadModuleAsync("xCatalogData"), WbSpaModel.prototype.$moduleLoader.loadModuleAsync("queryHelper"), WbSpaModel.prototype.$moduleLoader.loadModuleAsync("xCatalogProvider"), WbSpaModel.prototype.$moduleLoader.loadModuleAsync("sorterModel"), WbSpaModel.prototype.$moduleLoader.loadServiceAsync("suppliersService")]);
                    this.modules = {
                        XCatalogData: e.XCatalogData,
                        QueryHelper: t,
                        xCatalogProvider: r,
                        SorterModel: s.CatalogSorterModel
                    },
                    this.catalogMenu = new ls(this.modules),
                    this.initialized = !0
                }
                async _loadBrandMenu(e) {
                    await this.catalogMenu.initMenu(e, this.xInfo),
                    this.seller = this.catalogMenu.sellerData ? e : null
                }
            }
            ;
            var hs = class {
                constructor() {
                    this.bannersTask = null
                }
                async onBeforeActionExecuting(e, t, r) {
                    this.bannersTask = null,
                    r.cancelRequest = !0
                }
                async onActionExecuting(e) {
                    this.bannersTask = WbSpaModel.prototype.$services.bannersService.getBannersForHomePageAsync(),
                    this.splitInfoTask = WbSpaModel.prototype.$analitic.getSplitInfo()
                }
                async onActionExecuted(e) {
                    e.responseData || (e.responseData = {});
                    const t = await this._getBanners();
                    Object.assign(e.responseData, {
                        bannersTask: this.bannersTask,
                        banners: t,
                        splitInfoTask: this.splitInfoTask
                    })
                }
                async _getBanners() {
                    let e = 2e3
                      , t = null;
                    return this.bannersTask.then((e => {
                        t = e
                    }
                    )),
                    new Promise((r => {
                        let s = setTimeout((function n() {
                            if (!(e >= 0 && null == t))
                                return clearTimeout(s),
                                r(t);
                            e -= 200,
                            s = setTimeout(n, 200)
                        }
                        ), 200)
                    }
                    ))
                }
            }
            ;
            var ms = class {
                constructor(e) {
                    this.timeout = e
                }
                onBeforeActionExecuting(e, t, r) {
                    r.timeout = this.timeout
                }
            }
            ;
            var gs = class {
                async onBeforeActionExecuting() {
                    this.data = null,
                    await WbSpaModel.prototype.$moduleLoader.loadServiceAsync("multipleSellersService")
                }
                async onActionExecuting() {
                    const e = WbSpaModel.prototype
                      , t = parseInt(e.$router.routeParameters.cod1S)
                      , {nmIds: r} = await this._getNmsForOtherSellers(t);
                    if (null == r ? void 0 : r.length)
                        try {
                            const t = await e.$services.multipleSellersService.loadSellersInfoAsync(r);
                            this.data = t.filter((e => e.salePrice > 0 && e.deliveryModel))
                        } catch (e) {
                            console.error(e)
                        }
                }
                async _getNmsForOtherSellers(e) {
                    const [t,r] = await Promise.all([wb.xnm.getGoodsForRecommendAndCatalog([e], !0), WbSpaModel.prototype.$httpClient.fetchStaticV3(wb.helpers.url.urlProductStatic, {
                        timeout: 2e3
                    }, e)])
                      , s = null == t ? void 0 : t[0]
                      , [n,a] = await Promise.all([WbSpaModel.prototype.$services.productCard.getMultiInfo(s, r), WbSpaModel.prototype.$moduleLoader.loadModuleAsync("productSelectionManager")]);
                    s.metacard = n,
                    s.canCheckForMulti = WbSpaModel.prototype.$services.productCard._canCheckForMulti(r),
                    this.productSelectionManager = new a(null,{
                        nmId: e
                    },s);
                    const o = await this.productSelectionManager.getNmsForOtherSellers(e);
                    return o.isMulticard ? {
                        nmIds: o.nms
                    } : await WbSpaModel.prototype.$services.multipleSellersService.loadOtherSellersNmIds(e)
                }
                onActionExecuted(e) {
                    var t;
                    e.responseData || (e.responseData = {});
                    const r = {
                        otherSellers: null != (t = this.data) ? t : []
                    };
                    Object.assign(e.responseData, r)
                }
            }
            ;
            var ys = class {
                async onBeforeActionExecuting() {
                    this.data = null,
                    await WbSpaModel.prototype.$moduleLoader.loadServiceAsync("productFeedbacksService")
                }
                async onActionExecuting() {
                    var e;
                    const t = WbSpaModel.prototype
                      , r = parseInt(t.$router.routeParameters.cod1S);
                    let s = parseInt(t.$router.queryParams.get("imtId"));
                    isNaN(s) && (s = await this._loadImtIdAsync(r));
                    try {
                        const n = await t.$services.productCard.loadStaticProductAsync(r)
                          , a = !(null == (e = n.colors) ? void 0 : e.length) || 1 == n.colors.length
                          , o = await this._setDefaultSort()
                          , {summary: i, votes: l} = await t.$services.productFeedbacksService.loadSummaryAndVotes(s, r, 10, o, null);
                        this.data = {
                            imtId: s,
                            summary: i,
                            votes: l,
                            sortValue: o,
                            nmId: r,
                            isOneColor: a,
                            staticProduct: n
                        }
                    } catch (e) {
                        return {
                            imtId: s
                        }
                    }
                }
                onActionExecuted(e) {
                    var t;
                    e.responseData || (e.responseData = {}),
                    Object.assign(e.responseData, null != (t = this.data) ? t : {})
                }
                async _loadImtIdAsync(e) {
                    if (isNaN(e))
                        return null;
                    try {
                        const t = await WbSpaModel.prototype.$httpClient.fetchStaticV3(wb.helpers.url.urlProductStatic, {
                            timeout: 2e3
                        }, e);
                        return null == t ? void 0 : t.imt_id
                    } catch (e) {
                        return console.error(e),
                        0
                    }
                }
                async _setDefaultSort() {
                    return "dateDesc"
                }
            }
            ;
            var bs = class {
                async onBeforeActionExecuting() {
                    this.data = null,
                    await WbSpaModel.prototype.$moduleLoader.loadServiceAsync("productQuestionsService")
                }
                async onActionExecuting() {
                    const e = WbSpaModel.prototype
                      , t = parseInt(e.$router.routeParameters.cod1S);
                    let r = parseInt(e.$router.queryParams.get("imtId"));
                    isNaN(r) && (r = await this._loadImtIdAsync(t));
                    try {
                        const [s,n] = await Promise.all([e.$services.productQuestionsService.loadQuestionsFromCache(r, 10), WbSpaModel.prototype.$httpClient.fetchStaticV3(wb.helpers.url.urlProductStatic, null, t)]);
                        this.data = {
                            staticProduct: n,
                            imtId: r,
                            questionsModel: s
                        }
                    } catch (e) {
                        return {
                            imtId: r
                        }
                    }
                }
                onActionExecuted(e) {
                    var t;
                    e.responseData || (e.responseData = {}),
                    Object.assign(e.responseData, null != (t = this.data) ? t : {})
                }
                async _loadImtIdAsync(e) {
                    if (isNaN(e))
                        return 0;
                    try {
                        const t = await WbSpaModel.prototype.$httpClient.fetchStaticV3(wb.helpers.url.urlProductStatic, null, e);
                        return null == t ? void 0 : t.imt_id
                    } catch (e) {
                        return console.error(e),
                        0
                    }
                }
            }
            ;
            var fs = class {
                get $router() {
                    return WbSpaModel.prototype.$router
                }
                onBeforeActionExecuting() {
                    this.data = null
                }
                async onActionExecuting(e, t, r) {
                    const s = WbSpaModel.prototype
                      , n = parseInt(s.$router.routeParameters.cod1S);
                    try {
                        if (this.data = await wb.xnm.getMiniProductCard(n),
                        null == this.data)
                            return r.redirected = !0,
                            void this.$router.moveTo404Async()
                    } catch (e) {
                        console.error(e)
                    }
                }
                onActionExecuted(e) {
                    var t, r, s;
                    e.responseData || (e.responseData = {});
                    let n = parseInt(WbSpaModel.prototype.$router.queryParams.get("size"));
                    const a = this.data;
                    if (!isNaN(n) && (null == (t = a.sizes) ? void 0 : t.some((e => e.ch == n))))
                        a.characteristicId = n,
                        a.sizeName = null == (r = a.sizes.find((e => e.ch == n))) ? void 0 : r.nm;
                    else if (1 == (null == (s = a.sizes) ? void 0 : s.length)) {
                        const e = a.sizes[0];
                        a.characteristicId = e.ch,
                        a.sizeName = null == e ? void 0 : e.nm
                    }
                    a.tilesVariable = WbSpaModel.prototype.$services.productCard.canUseTilesVariable(a.subjectId, a.subjectParentId),
                    e.responseData.miniCard = a
                }
            }
            ;
            var vs = class {
                get $moduleLoader() {
                    return WbSpaModel.prototype.$moduleLoader
                }
                get $services() {
                    return WbSpaModel.prototype.$services
                }
                get $router() {
                    return WbSpaModel.prototype.$router
                }
                onBeforeActionExecuting() {
                    this.model = this.imageId = null
                }
                async onActionExecuting() {
                    var e;
                    await this.$moduleLoader.loadServiceAsync("searchByImageService");
                    const t = this.$router.routeParameters.imageId
                      , r = this.$services.searchByImageService.getSearchResult(t);
                    !r.invalidPhoto && !r.error && (null == (e = r.recommendationsNms) ? void 0 : e.length) > 0 && (r.products = await this._loadGoods(r.recommendationsNms),
                    r.statistic && (r.statistic.foundByImageOnStock = r.products.length)),
                    r.imageId = t,
                    this.model = r,
                    this.imageId = t
                }
                onActionExecuted(e) {
                    e.responseData || (e.responseData = {}),
                    Object.assign(e.responseData, this.model)
                }
                async _loadGoods(e) {
                    try {
                        const t = await wb.xnm.getCatalogCards(e, !1, !1)
                          , r = e.reduce(( (e, r) => {
                            var s;
                            return (null == (s = t[r]) ? void 0 : s.id) && e.push(wb.xnm.convertXProductToSpaCatalogProduct(t[r])),
                            e
                        }
                        ), []);
                        return r
                    } catch (e) {
                        return []
                    }
                }
            }
            ;
            var ws = class {
                get $httpClient() {
                    return WbSpaModel.prototype.$httpClient
                }
                get $router() {
                    return WbSpaModel.prototype.$router
                }
                get $user() {
                    return WbSpaModel.prototype.$user
                }
                async onActionExecuted(e) {
                    e.responseData || (e.responseData = {});
                    const t = WbSpaModel.prototype.$router.queryParams.get("searchQuery")
                      , r = WbSpaModel.prototype.$router.queryParams.get("targetUrl")
                      , s = this._getSearchCatalogLink(t)
                      , n = `/recommendationssearch?searchQuery?searchQuery=${new URLSearchParams({
                        searchQuery: t,
                        targetUrl: r
                    })}`
                      , a = await this._loadGoods(t);
                    if (!Array.isArray(a) || 0 == a.length)
                        return this.$router.moveTo404Async();
                    const o = {
                        type: Ir.recommendationsSearch,
                        searchQuery: t,
                        targetUrl: r,
                        linkToSearchCatalog: s,
                        originalUrl: n,
                        products: a
                    };
                    Object.assign(e.responseData, o)
                }
                _getSearchCatalogLink(e) {
                    let t = encodeURIComponent(e.replace(/<\/?[^>]+>/gi, "").trim());
                    return `${wb.urlHelper.xSearchBase}?search=${t}`
                }
                async _loadGoods(e) {
                    try {
                        const t = `https://search-goods.wildberries.ru/search?query=${encodeURIComponent(e)}`
                          , r = WbSpaModel.prototype.$analitic.getRecomendationsSplitterHeaders()
                          , s = await this.$httpClient.fetchBasicJSON(t, {
                            credentials: "omit",
                            headers: r
                        }, {
                            timeout: 5e3
                        });
                        if (!((null == s ? void 0 : s.length) > 0))
                            return null;
                        const n = await wb.xnm.getCatalogCards(s, !1, !1)
                          , a = s.reduce(( (e, t) => {
                            var r;
                            return (null == (r = n[t]) ? void 0 : r.id) && e.push(wb.xnm.convertXProductToSpaCatalogProduct(n[t])),
                            e
                        }
                        ), []);
                        return a
                    } catch (e) {
                        return null
                    }
                }
            }
            ;
            var Ss = class {
                get $moduleLoader() {
                    return WbSpaModel.prototype.$moduleLoader
                }
                get $services() {
                    return WbSpaModel.prototype.$services
                }
                get $router() {
                    return WbSpaModel.prototype.$router
                }
                async onActionExecuting(e, t, r) {
                    var s, n;
                    this.goods = this.type = this.forproduct = this.result = null,
                    await this.$moduleLoader.loadServiceAsync("recommendationsCatalogService");
                    const a = this.$router.queryParams.get("type")
                      , o = this.$router.queryParams.get("forproduct")
                      , i = this.$services.recommendationsCatalogService
                      , l = i.getType(a)
                      , c = await i.getRecommendations(l.id, o);
                    let u;
                    if ((null == (s = null == c ? void 0 : c.goods) ? void 0 : s.length) ? u = c.goods : (null == (n = null == c ? void 0 : c.nms) ? void 0 : n.length) && (u = await this._loadGoods(c.nms)),
                    !(Array.isArray(u) && u.length > 0))
                        return r.redirected = !0,
                        void this.$router.moveTo404Async();
                    this.type = l,
                    this.goods = u,
                    this.result = c,
                    this.forproduct = o
                }
                async onActionExecuted(e) {
                    var t, r, s, n;
                    e.responseData || (e.responseData = {});
                    const {type: a, goods: o, result: i, forproduct: l} = this
                      , c = {
                        type: a.id,
                        targetInfo: {
                            targetUrl: a.targetUrl
                        },
                        products: o,
                        statistic: {
                            type: a.id,
                            source: null == i ? void 0 : i.source,
                            recommendationsCount: null != (n = null != (s = null == (t = null == i ? void 0 : i.goods) ? void 0 : t.length) ? s : null == (r = null == i ? void 0 : i.nms) ? void 0 : r.length) ? n : 0,
                            productsCount: o.length,
                            parentProduct: l
                        },
                        nmId: l,
                        title: a.title
                    };
                    Object.assign(e.responseData, c)
                }
                async _loadGoods(e) {
                    try {
                        const t = await wb.xnm.getCatalogCards(e, !1, !1)
                          , r = e.reduce(( (e, r) => {
                            var s;
                            return (null == (s = t[r]) ? void 0 : s.id) && e.push(wb.xnm.convertXProductToSpaCatalogProduct(t[r])),
                            e
                        }
                        ), []);
                        return r
                    } catch (e) {
                        return []
                    }
                }
            }
            ;
            var _s = class {
                get $recentViews() {
                    return WbSpaModel.prototype.$recentViews
                }
                get $httpClient() {
                    return WbSpaModel.prototype.$httpClient
                }
                get $router() {
                    return WbSpaModel.prototype.$router
                }
                async onActionExecuted(e) {
                    e.responseData || (e.responseData = {});
                    const t = await this._loadNms();
                    if (0 == t.length)
                        return this.$router.moveTo404Async();
                    const r = await this._loadGoods(t);
                    if (0 == r.length)
                        return this.$router.moveTo404Async();
                    const s = {
                        title: "Вы смотрели",
                        products: r,
                        type: "recent",
                        targetInfo: {
                            targetUrl: "RG"
                        },
                        statistic: {
                            recommendationsCount: t.length,
                            productsCount: r.length
                        }
                    };
                    Object.assign(e.responseData, s)
                }
                async _loadNms() {
                    var e, t, r, s;
                    let n = null != (t = null == (e = this.$recentViews.get()) ? void 0 : e.nm) ? t : [];
                    try {
                        const e = await this.$httpClient.fetchBasicJSON("/webapi/goods/visited-nm", {
                            method: "POST",
                            body: null
                        }, {
                            timeout: 2e3
                        });
                        (null == (s = null == (r = null == e ? void 0 : e.value) ? void 0 : r.nmsArr) ? void 0 : s.length) > 0 && (n = e.value.nmsArr)
                    } catch (e) {
                        console.error(e)
                    }
                    return n
                }
                async _loadGoods(e) {
                    try {
                        const t = await wb.xnm.getCatalogCards(e, !0, !0)
                          , r = e.reduce(( (e, r) => {
                            var s;
                            return (null == (s = t[r]) ? void 0 : s.id) && e.push(wb.xnm.convertXProductToSpaCatalogProduct(t[r])),
                            e
                        }
                        ), []);
                        return r
                    } catch (e) {
                        return []
                    }
                }
            }
            ;
            var Cs = class {
                constructor(e) {
                    this.defaultValue = e
                }
                onBeforeActionExecuting(e, t, r) {
                    r.defaultValue = this.defaultValue
                }
            }
            ;
            var Is = class {
                get $router() {
                    return WbSpaModel.prototype.$router
                }
                get $services() {
                    return WbSpaModel.prototype.$services
                }
                async onActionExecuting(e, t, r) {
                    const {userInfo: s} = await this.$services.userData.getUserDataAsync();
                    s.isAuthenticated || (r.redirected = !0,
                    this.$router.moveToSignIn({
                        query: {
                            returnUrl: window.location.href
                        }
                    }, !0))
                }
            }
            ;
            var Ms = class {
                constructor() {
                    this.bannersTask = null
                }
                async onBeforeActionExecuting(e, t, r) {
                    this.bannersTask = null,
                    r.cancelRequest = !0
                }
                async onActionExecuting(e) {
                    this.bannersTask = WbSpaModel.prototype.$services.bannersService.getPromoBanners()
                }
                onActionExecuted(e) {
                    e.responseData || (e.responseData = {}),
                    Object.assign(e.responseData, {
                        bannersTask: this.bannersTask
                    })
                }
            }
            ;
            var ks = class {
                async onActionExecuting() {
                    WbSpaModel.prototype.$moduleLoader.loadModuleAsync("spaWbxAuthController")
                }
            }
            ;
            var Ps = class {
                async onBeforeActionExecuting(e, t) {
                    const r = WbSpaModel.prototype.$services.cartService.publicBasketApiUrl;
                    t.credentials = "include";
                    const s = new URL(r,window.location.origin);
                    e.port = s.port,
                    e.pathname = (s.pathname + e.pathname).replace("//", ""),
                    e.host = s.host
                }
            }
            ;
            var Ts = class {
                constructor() {}
                onBeforeActionExecuting(e, t, r) {
                    t.body || (t.body = new URLSearchParams),
                    t.body.append("currency", WbSpaModel.prototype.$user.getCurrency())
                }
            }
            ;
            var $s = class {
                get $router() {
                    return WbSpaModel.prototype.$router
                }
                get $services() {
                    return WbSpaModel.prototype.$services
                }
                async onActionExecuting(e, t, r) {
                    var s;
                    if (WbSpaModel.prototype.$auth.isAuth && WbSpaModel.prototype.$auth.jwt) {
                        let e, t = null != (s = this.$router.queryParams.get("ReturnUrl") || this.$router.queryParams.get("returnUrl")) ? s : "/lk";
                        try {
                            e = new URL(t,window.location.origin)
                        } catch (e) {}
                        e.hostname !== window.location.hostname && (t = "/lk"),
                        r.redirected = !0,
                        this.$router.moveTo(t)
                    }
                }
            }
            ;
            var As = class {
                async onActionExecuting(e, t) {
                    if (!(e.searchParams.get("redirect_uri") && e.searchParams.get("client_id") && e.searchParams.get("scope") && e.searchParams.get("code_challenge") && (e => {
                        const t = e.searchParams.get("redirect_uri");
                        return /^((http|https):\/\/)/.test(t)
                    }
                    )(e)))
                        throw new NotFoundError;
                    WbSpaModel.prototype.$auth.isAuth ? this.getSavedOptionsTask = WbSpaModel.prototype.$services.apiUserStorage.getData([{
                        path: "wb_oauth_saved_options"
                    }], {
                        timeout: 1200
                    }) : window.location.replace($.views.helpers.urlSignIn(window.location.pathname + window.location.search))
                }
                async onActionExecuted(e) {
                    if (!WbSpaModel.prototype.$auth.isAuth)
                        return;
                    const t = await this.getSavedOptionsTask;
                    if (t) {
                        if (null == t ? void 0 : t.length)
                            try {
                                return void (e.responseData = JSON.parse(WbSpaModel.prototype.$helper.base64.decode(t[0].file)))
                            } catch (e) {}
                        e.responseData = []
                    }
                }
            }
            ;
            var Ds = class {
                async onBeforeActionExecuting(e, t, r) {
                    r.redirected = !0,
                    WbSpaModel.prototype.$router.moveTo("/lk#notifications")
                }
            }
            ;
            const Es = new lr
              , Bs = new ur
              , Os = new fs
              , xs = new Cs({
                isNetworkError: !0
            })
              , Ls = new Is;
            var Fs = class {
                constructor() {
                    const e = new Map;
                    this.globalPipelines = [new hr],
                    e.set("SpaHomeData", {
                        pipelines: [new hs]
                    }),
                    e.set("SpaPromotionsData", {
                        pipelines: [new Ms]
                    }),
                    e.set("SpaSignInData", {
                        pipelines: [new $s, xs, new ks, new ms(1e3)]
                    }),
                    e.set("SpaRefundData", {
                        pipelines: [xs]
                    }),
                    e.set("SpaProductCardData", {
                        pipelines: [Bs, new mr]
                    }),
                    e.set("SpaGetGroupedDeliveries", {
                        pipelines: [Ls, Bs, new ms(1e3)],
                        fallback: () => ({
                            options: {}
                        })
                    }),
                    e.set("SpaHeadArchivePositions", {
                        pipelines: [Ls, xs],
                        fallback: () => ({
                            limit: 150,
                            filters: {
                                type: "all",
                                status: 0
                            }
                        })
                    }),
                    e.set("SpaBasketData", {
                        maxTriesCount: 0,
                        pipelines: [xs, Es, new pr, new ms(4e3)]
                    }),
                    e.set("SpaEmailedConfirmData", {
                        pipelines: [new dr, new ur(( () => {
                            const {targetRoute: e} = WbSpaModel.prototype.$router;
                            return "SpaConfirmEmailedEntrypoint" != e && "SpaChangeEmailEntrypoint" != e
                        }
                        ))]
                    }),
                    e.set("SpaAccountData", {
                        pipelines: [Ls, Es, xs],
                        fallback: () => ({
                            broken: !0,
                            data: {
                                subscriptions: {
                                    subscribtionsByType: {}
                                },
                                discountTable: {},
                                mySafety: {},
                                deleteAccountSettings: {},
                                settings: {},
                                calendarSettings: {}
                            }
                        })
                    }),
                    e.set("SpaWalletPurchaseData", {
                        pipelines: [Ls, Es, xs, new Ts]
                    }),
                    e.set("SpaCustomerReceiptData", {
                        pipelines: [Es, xs]
                    }),
                    e.set("SpaPersonalCabinetData", {
                        pipelines: [xs, Es, Ls]
                    }),
                    e.set("SpaTravelLkData", {
                        pipelines: [Bs]
                    }),
                    e.set("SpaProfileData", {
                        pipelines: [Es]
                    }),
                    e.set("SpaBasketBuyItNowData", {
                        maxTriesCount: 0,
                        pipelines: [Es, new pr, xs, new ms(3e3)]
                    }),
                    e.set("SpaSearchData", {
                        pipelines: [new Ur]
                    }),
                    e.set("SpaRecommendationsSearchCatalogData", {
                        pipelines: [Bs, new ws]
                    }),
                    e.set("SpaRecommendationsCatalogData", {
                        pipelines: [Bs, new Ss]
                    }),
                    e.set("SpaRecentCatalogData", {
                        pipelines: [Bs, new _s]
                    }),
                    e.set("SpaWlArrivedData", {
                        pipelines: [Bs, new _r, Ls]
                    }),
                    e.set("SpaCatalogData", {
                        pipelines: [new Lr, new Fr, new Wr]
                    }),
                    e.set("SpaPromotionsCatalogData", {
                        pipelines: [new Qr]
                    }),
                    e.set("SpaSellerCatalogData", {
                        pipelines: [new ps]
                    }),
                    e.set("SpaBrandsData", {
                        pipelines: [new is]
                    }),
                    e.set("SpaBrandsPreviewData", {
                        pipelines: [new is(!0)]
                    }),
                    e.set("SpaFavoritesData", {
                        pipelines: [Bs, new Cr, Ls]
                    }),
                    e.set("SpaProductCardOtherSellersData", {
                        pipelines: [Bs, Es, Os, new gs]
                    }),
                    e.set("SpaProductCardFeedbacksData", {
                        pipelines: [Bs, Es, Os, new ys]
                    }),
                    e.set("SpaProductCardQuestionsData", {
                        pipelines: [Bs, Es, Os, new bs]
                    }),
                    e.set("SpaSearchByImageData", {
                        pipelines: [Bs, new vs]
                    }),
                    e.set("SpaOrderConfirmedData", {
                        fallback: e => {
                            if (e) {
                                const t = e.url.searchParams.get("orderId");
                                if (t) {
                                    const e = sessionStorage.getItem(`confirmed_order_${t}`);
                                    if (e)
                                        return {
                                            data: JSON.parse(e)
                                        }
                                }
                            }
                            return {
                                data: {
                                    broken: !0,
                                    order: {}
                                }
                            }
                        }
                        ,
                        pipelines: [Es, new Ps]
                    }),
                    e.set("SpaOrderThankYouEntrypoint", {
                        fallback: () => ({})
                    }),
                    e.set("SpaPaymentFailData", {
                        fallback: () => ({})
                    }),
                    e.set("SpaFavoriteBrandsData", {
                        pipelines: [Ls, xs]
                    }),
                    e.set("SpaHistoryRefundsData", {
                        pipelines: [Ls, xs]
                    }),
                    e.set("SpaMyCommunicationsData", {
                        pipelines: [Ls, xs]
                    }),
                    e.set("SpaMyClaimsData", {
                        pipelines: [Ls, xs]
                    }),
                    e.set("SpaMyFeedbacksData", {
                        pipelines: [Ls, xs]
                    }),
                    e.set("SpaNotificationsData", {
                        pipelines: [Ls, new Ds, xs]
                    }),
                    e.set("SpaOAuthSignInData", {
                        pipelines: [Bs, new As, Es]
                    }),
                    e.set("SubscriptionPageData", {
                        pipelines: [Bs, Ls, Es]
                    }),
                    e.set("ServicePagesData", {
                        pipelines: [new cr]
                    }),
                    this.map = e
                }
                extend(e) {
                    var t;
                    const r = this.map.get(e) || {};
                    return r.pipelines = (null != (t = r.pipelines) ? t : []).concat(this.globalPipelines),
                    r
                }
            }
            ;
            let Ws = new s.A;
            Ws.initTask = new S.Deferred;
            const js = new Fs
              , Ns = new q;
            let Rs, Us = null, Hs = null, qs = null;
            const Vs = Object.freeze({
                mobile: "m",
                desktop: "d"
            });
            class zs {
                get $userEnv() {
                    return Zs
                }
                get $router() {
                    return Ws
                }
                get $helper() {
                    return S
                }
                get $moduleLoader() {
                    return Gs
                }
                get $verificationTokenHelper() {
                    return D
                }
                get $menuLk() {
                    return null == Hs && (Hs = (new n).init()),
                    Hs
                }
                get $localziation() {
                    return Rs
                }
                set $localziation(e) {
                    Rs = e
                }
                get $httpClient() {
                    return p
                }
                get $auth() {
                    return w
                }
                get $wbxHttpClient() {
                    return h
                }
                get $observable() {
                    return $.observable(this)
                }
                asObservable(e) {
                    return $.observable(e)
                }
                toggleProperty(e) {
                    this.asObservable(this).setProperty(e, !this[e])
                }
                get $storageHelper() {
                    return R
                }
                get $seoHelper() {
                    return A
                }
                get $stat() {
                    return wb.stat
                }
                get $user() {
                    return Js
                }
                get $geoLocation() {
                    return Ks
                }
                get $adult() {
                    return Qs
                }
                get $observerHelper() {
                    return Xs
                }
                get $analitic() {
                    return wb.analitics
                }
                get $productCardPopup() {
                    return Us = null != Us ? Us : new P,
                    Us
                }
                get $isDesktop() {
                    return Vs.desktop == wb.settings.displayMode
                }
                get $eventBus() {
                    return T
                }
                get $services() {
                    return en
                }
                get $routeExtensions() {
                    return js
                }
                get $apiSupport() {
                    return Ns
                }
                get $recentViews() {
                    return z
                }
                get $promotionsHelper() {
                    return ee
                }
                $localize(e) {
                    var t;
                    return (null == (t = Rs[Ws.current]) ? void 0 : t[e]) || e
                }
                $moveToAnchor(...e) {
                    const t = arguments[0]
                      , r = e.find((e => e instanceof Event || e instanceof jQuery.Event))
                      , s = arguments[1]instanceof Event || arguments[1]instanceof jQuery.Event || arguments[1]
                      , n = !(arguments[2]instanceof Event || arguments[2]instanceof jQuery.Event) && arguments[2]
                      , a = arguments[3]instanceof Event || arguments[3]instanceof jQuery.Event || !arguments[3] ? 0 : arguments[3];
                    null == r || r.preventDefault(),
                    null == r || r.stopPropagation(),
                    null == r || r.stopImmediatePropagation();
                    const o = document.getElementById(t);
                    if (null == o)
                        return void console.warn("anchor element doesnt exist");
                    const i = {
                        top: 0 + a
                    };
                    let l = this.$helper.isElementInViewport(o, !0, i);
                    function c() {
                        "scrollBehavior"in document.documentElement.style ? window.scrollTo({
                            top: window.pageYOffset + o.getBoundingClientRect().top - a,
                            left: 0,
                            behavior: s ? "smooth" : "auto"
                        }) : window.scrollTo(0, window.pageYOffset + o.getBoundingClientRect().top - a)
                    }
                    if (c(),
                    n) {
                        const e = setInterval(( () => {
                            l = this.$helper.isElementInViewport(o, !0, i),
                            l ? clearInterval(e) : c()
                        }
                        ), 500)
                    }
                }
                $void() {}
                $getCurrentXInfoAsync() {
                    return Js.getXinfo()
                }
                $getCurrentXInfoWithClustersAndVectorsAsync(e) {
                    return Js.getXinfoWithClustersAndVectors(e)
                }
                async $getUserGender() {
                    const {userInfo: e} = await this.$services.userData.getUserDataAsync();
                    return e.genderE
                }
                $generateGuid() {
                    const e = () => Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);
                    return e() + e() + "-" + e() + "-" + e() + "-" + e() + "-" + e() + e() + e()
                }
                async $getLoadingError() {
                    if (qs)
                        return qs;
                    try {
                        const e = await Gs.loadModuleAsync("loadingError");
                        return qs = new e,
                        qs
                    } catch (e) {
                        return null
                    }
                }
                async $checkLotteryAvailabilityAsync() {
                    var e, t, r, s, n;
                    if ("ru" != wb.settings.currentLocale)
                        return !1;
                    const a = null != (n = null == (s = null == (r = null == (t = null == (e = wb.global) ? void 0 : e.settings) ? void 0 : t.variables.lotteryAccessSettings) ? void 0 : r.permitted) ? void 0 : s.split(";")) ? n : [];
                    if (a.length) {
                        const [e,{userInfo: t}] = await Promise.all([this.$user.getShardAsync(), this.$services.userData.getUserDataAsync()]);
                        return t.isAuthenticated && a.some((t => {
                            const [r,s] = t.split("&").map((e => parseInt(e)));
                            return e >= r && e <= s
                        }
                        ))
                    }
                    return !0
                }
                $isWbxOrderEnabled(e) {
                    var t, r, s;
                    return !!(null == (t = this.$auth.jwtData) ? void 0 : t.user) && ("ru" !== wb.settings.currentLocale || (!!e.isWbxOrderEnabled || !!(null == (s = null == (r = wb.global.settings) ? void 0 : r.variables) ? void 0 : s.wbxOrderUsersRange) && this._checkByRange(wb.global.settings.variables.wbxOrderUsersRange)))
                }
                $isWbxOrderCancelEnabled(e) {
                    var t, r, s;
                    return !!(null == (t = this.$auth.jwtData) ? void 0 : t.user) && (!!e.wbxCanCancel || !!(null == (s = null == (r = wb.global.settings) ? void 0 : r.variables) ? void 0 : s.wbxOrderCancelUsersRange) && this._checkByRange(wb.global.settings.variables.wbxOrderCancelUsersRange))
                }
                $isUserGradeEnabled() {
                    var e, t, r;
                    return !(!(null == (e = this.$auth.jwtData) ? void 0 : e.user) || !(null == (r = null == (t = wb.global.settings) ? void 0 : t.variables) ? void 0 : r.userGradeUsersRange)) && this._checkByRange(wb.global.settings.variables.userGradeUsersRange)
                }
                $isUserPremiumEnabled() {
                    var e, t, r;
                    if (!(null == (e = this.$auth.jwtData) ? void 0 : e.user) || "ru" !== wb.settings.currentLocale)
                        return !1;
                    const s = this.$services.userData.getMaskedInfo();
                    return (null == (t = this.$user.getUserGradeFromCache()) ? void 0 : t.premiumIsAvailable) && ((null == s ? void 0 : s.phone.startsWith("79")) || (null == (r = this.$user.getUserGradeFromCache().subscription_features) ? void 0 : r.length) > 0)
                }
                _checkByRange(e) {
                    var t;
                    const r = (null != (t = null == e ? void 0 : e.split(";")) ? t : []).map((e => parseInt(e)));
                    if (r.length < 2)
                        return !1;
                    const s = isNaN(this.$auth.jwtData.user) ? Math.abs(this.$auth.jwtData.user.hashCode()) : parseInt(this.$auth.jwtData.user);
                    return s > r[0] && s <= r[1]
                }
                $isRangeEnabledFor(e) {
                    var t;
                    return !(!(null == (t = this.$auth.jwtData) ? void 0 : t.user) || !e) && this._checkByRange(e)
                }
                $useCatalogReturnCost() {
                    var e, t, r, s;
                    return !!(null == (t = null == (e = wb.global.settings) ? void 0 : e.variables) ? void 0 : t.catalogReturnCostLocales) && (null == (s = null == (r = wb.global.settings) ? void 0 : r.variables) ? void 0 : s.catalogReturnCostLocales.includes(this.$user.getLocale()))
                }
                $getService(e) {
                    return Gs.loadServiceAsSingletonAsync(e).then(( () => en[e]))
                }
            }
            Object.defineProperties(window, {
                WbSpaModel: {
                    value: zs
                }
            }),
            Object.setPrototypeOf(s.A.prototype, zs.prototype),
            Object.setPrototypeOf(U.A.prototype, zs.prototype),
            Object.setPrototypeOf(H.prototype, zs.prototype),
            Object.setPrototypeOf(_.prototype, zs.prototype),
            Object.setPrototypeOf(C.prototype, zs.prototype),
            Object.setPrototypeOf(I.prototype, zs.prototype),
            Object.setPrototypeOf(P.prototype, zs.prototype),
            Object.setPrototypeOf(Object.getPrototypeOf(A), zs.prototype),
            Object.setPrototypeOf(n.prototype, zs.prototype),
            Object.setPrototypeOf(Fs.prototype, zs.prototype),
            Object.setPrototypeOf(ee.prototype, zs.prototype),
            Object.setPrototypeOf(nt.prototype, zs.prototype),
            Object.setPrototypeOf(at.A.prototype, zs.prototype),
            Object.setPrototypeOf(mt.prototype, zs.prototype),
            Object.setPrototypeOf(Me.prototype, zs.prototype),
            Object.setPrototypeOf(Pe.prototype, zs.prototype),
            Object.setPrototypeOf(Fe.prototype, zs.prototype),
            Object.setPrototypeOf(Ut.prototype, zs.prototype),
            Object.setPrototypeOf(Kt.prototype, zs.prototype),
            Object.setPrototypeOf(Yt.prototype, zs.prototype),
            Object.setPrototypeOf(Ct.prototype, zs.prototype),
            Object.setPrototypeOf(rr.prototype, zs.prototype),
            Object.setPrototypeOf(ir.prototype, zs.prototype);
            const Gs = (new _).init()
              , Qs = new C
              , Js = new U.A
              , Ks = new H
              , Xs = new I;
            var Ys = zs;
            wb.utils = Object.assign(wb.utils, S),
            wb.user = Js,
            wb.adult = Qs;
            const Zs = {
                currency: wb.user.getCurrency(),
                activePositions: [],
                activePositionsTask: new S.Deferred
            }
              , en = {
                storeService: new mt,
                userAddressService: new at.A,
                cartService: new nt,
                favsService: new Me,
                userData: new Pe,
                notifications: new Fe,
                productCard: new Ct,
                bannersService: new Ut,
                apiUserStorage: new Kt,
                sessionService: new Yt,
                pager: er,
                retryFetchService: new rr,
                splitterService: new ir
            };
            Object.keys(en).forEach((e => {
                const t = en[e];
                "init"in t && t.init && t.init()
            }
            ));
            var tn = r(68982)
              , rn = r(17728)
              , sn = Object.defineProperty
              , nn = Object.getOwnPropertySymbols
              , an = Object.prototype.hasOwnProperty
              , on = Object.prototype.propertyIsEnumerable
              , ln = (e, t, r) => t in e ? sn(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }) : e[t] = r;
            const cn = "wb__lang";
            var un = new class {
                constructor() {
                    this.currLang = localStorage.getItem(cn) || "ru"
                }
                async init() {
                    const e = !!localStorage.getItem("i18n_debug");
                    if (await i18next.init({
                        lng: this.currLang,
                        fallbackLng: "ru",
                        debug: e,
                        saveMissing: !0,
                        missingKeyHandler: (e, t, r, s, n, a) => (a && a.ignoreMissingKey || console.warn("i18next missingKey: " + r),
                        r),
                        resources: {
                            ru: {
                                translation: rn
                            }
                        }
                    }),
                    e) {
                        const e = i18next.t;
                        i18next.t = (...t) => `[[${e(...t)}]]`
                    }
                    await this.loadTranslationsModule(),
                    wb.i18n = {
                        t: i18next.t,
                        plural: (e, t) => {
                            var r = t
                              , {count: s, displayCount: n} = r
                              , a = ( (e, t) => {
                                var r = {};
                                for (var s in e)
                                    an.call(e, s) && t.indexOf(s) < 0 && (r[s] = e[s]);
                                if (null != e && nn)
                                    for (var s of nn(e))
                                        t.indexOf(s) < 0 && on.call(e, s) && (r[s] = e[s]);
                                return r
                            }
                            )(r, ["count", "displayCount"]);
                            return i18next.t(`${e}.plural`, ( (e, t) => {
                                for (var r in t || (t = {}))
                                    an.call(t, r) && ln(e, r, t[r]);
                                if (nn)
                                    for (var r of nn(t))
                                        on.call(t, r) && ln(e, r, t[r]);
                                return e
                            }
                            )({
                                count: s,
                                displayCount: n || s,
                                interpolation: {
                                    escapeValue: !n
                                }
                            }, a))
                        }
                        ,
                        language: i18next.language
                    },
                    localStorage.setItem(cn, this.currLang),
                    $.views.helpers({
                        t: wb.i18n.t,
                        plural: wb.i18n.plural
                    })
                }
                async loadTranslationsModule() {
                    try {
                        if ("ru" !== this.currLang) {
                            const e = new Promise(( (e, t) => setTimeout(( () => t(new Error("загрузка перевода превысила 15 секунд"))), 15e3)))
                              , t = r(81442)(`./lang.${this.currLang}.json`)
                              , s = await Promise.race([t, e]);
                            s && i18next.addResourceBundle(this.currLang, "translation", s.default)
                        }
                    } catch (e) {
                        console.log("Translation loading error:", e)
                    }
                }
            }
            ;
            var dn = class {
                constructor() {
                    this.fullMenu = null,
                    this.menuByUrl = new Map,
                    this.menuById = new Map,
                    this.isInited = !1,
                    this.menuIdEnum = this._menuIdEnum()
                }
                _menuIdEnum() {
                    return {
                        sport: 784,
                        monocity: 61042,
                        forAdults: 62057,
                        promotion: 2192
                    }
                }
                async initMenu() {
                    var e;
                    const t = wb.i18n.language || "ru"
                      , r = `main-menu-${WbSpaModel.prototype.$user.getLocale()}-${t}-v3.json`;
                    if (this.fullMenu = await WbSpaModel.prototype.$httpClient.fetchStaticDataV2(r, 1e4),
                    this.fullMenu) {
                        const t = null == (e = WbSpaModel.prototype.$user.getUserGradeFromCache()) ? void 0 : e.wbClub
                          , r = this.fullMenu.findIndex((e => 1234 === e.id));
                        if (!wb.settings.b2bMode && WbSpaModel.prototype.$isUserPremiumEnabled()) {
                            const e = {
                                id: 1122,
                                name: "Скидки WB Клуба",
                                url: t && "subscribed" === t ? "/promotions/klubnye-skidki" : "/subscription",
                                locked: !t || "subscribed" !== t
                            };
                            t && "subscribed" === t || (e.target = "_blank"),
                            this.fullMenu.splice(r >= 0 ? r : 0, 0, e)
                        }
                        this.fullMenu.splice(this.fullMenu.findIndex((e => 306 === e.id)), 0, {
                            id: 131387,
                            name: "Доброшрифт",
                            url: "/promotions/dobroshrift"
                        }),
                        "ru" !== wb.settings.currentLocale && r >= 0 && this.fullMenu.splice(r, 1),
                        this._createMenuMap();
                        const s = this.fullMenu.filter((e => e.dynamic)).map((e => this.loadDynamicBranch(e)));
                        await Promise.all(s),
                        this.isInited = !0
                    }
                    return this
                }
                setEntryPointWBClub() {
                    window.localStorage.setItem("entryPointWBClub", "Catalog")
                }
                async loadDynamicBranch(e) {
                    const t = WbSpaModel.prototype.$user.getDest()
                      , r = `${m.g2}menu/v11/api?locale=${WbSpaModel.prototype.$user.getLocale()}&lang=ru&id=${e.id}&collapse&dest=${t}`
                      , s = await WbSpaModel.prototype.$httpClient.fetchBasicJSON(r, {}, {
                        timeout: 1e4
                    });
                    if (null == s ? void 0 : s.data) {
                        const r = this._fromDynamicMenu(s.data, e);
                        r.forEach((t => this._setNode(t, e.id))),
                        e.childs = r,
                        e.isDenyLink = !0,
                        e.loadedForDest = t
                    }
                }
                getCurrentMenuItem(e) {
                    if (!e)
                        return null;
                    let t = e.pathname.replace("catalogdata", "catalog");
                    return this.menuByUrl.get(t)
                }
                getSitePathItems(e) {
                    if (!e)
                        return null;
                    const t = [];
                    t.push({
                        id: e.id,
                        name: e.name,
                        pageUrl: e.url,
                        analytic: ["CCC", null, null, e.id]
                    });
                    let r = this.menuById.get(e.id).parentId;
                    for (; null != r; ) {
                        const e = this.menuById.get(r);
                        t.push({
                            id: r,
                            name: e.name,
                            pageUrl: e.url,
                            analytic: ["CCC", null, null, r]
                        }),
                        r = e.parentId
                    }
                    return t.reverse()
                }
                getCatalogMenu(e) {
                    var t, r, s, n;
                    const a = [];
                    if (e && 0 !== e.length)
                        if (1 === e.length) {
                            const s = {
                                name: "",
                                link: ""
                            }
                              , n = null != (r = null == (t = this.menuByUrl.get(e[0].pageUrl).childs) ? void 0 : t.map((e => ({
                                node: {
                                    id: e.id,
                                    name: e.name,
                                    link: e.url,
                                    isDenyLink: e.isDenyLink
                                },
                                children: []
                            })))) ? r : [];
                            a.push({
                                node: s,
                                children: n
                            })
                        } else {
                            const t = this.menuByUrl.get(e[1].pageUrl)
                              , r = {
                                id: t.id,
                                isOpen: !0,
                                lastSelected: e[e.length - 1].id === t.id,
                                link: t.url,
                                name: t.name
                            }
                              , o = r.lastSelected ? null != (n = null == (s = t.childs) ? void 0 : s.map((e => {
                                var t;
                                return {
                                    node: {
                                        id: e.id,
                                        name: e.name,
                                        link: e.url,
                                        isDenyLink: e.isDenyLink
                                    },
                                    children: null == (t = e.childs) ? void 0 : t.map((e => ({
                                        node: {
                                            id: e.id,
                                            name: e.name,
                                            link: e.url
                                        },
                                        children: []
                                    })))
                                }
                            }
                            ))) ? n : [] : this.getCatalogMenu(e.slice(1));
                            a.push({
                                node: r,
                                children: o
                            })
                        }
                    else
                        a.push({
                            node: {
                                name: "",
                                link: ""
                            },
                            children: []
                        });
                    return a
                }
                getCatalogDenyMenu(e, t) {
                    var r, s, n, a, o, i;
                    if (!e)
                        return;
                    if (e.landing || 1 === t.length)
                        return {
                            current: {
                                name: e.name,
                                link: e.url,
                                isTop: e.isTop,
                                lastSelected: !1
                            },
                            sideMenu: [],
                            parent: {},
                            parents: [],
                            tagsMenu: null != (s = null == (r = e.childs) ? void 0 : r.map((e => ({
                                name: e.name,
                                link: e.url
                            })))) ? s : []
                        };
                    const l = t[t.length - 2]
                      , c = t.slice(1).map((e => ({
                        name: e.name,
                        link: e.pageUrl
                    })));
                    c[c.length - 1].lastSelected = !0;
                    const u = null == (n = e.childs) ? void 0 : n.map((e => ({
                        name: e.name,
                        link: e.url,
                        anc: !0
                    })));
                    if ((null == (a = e.childs) ? void 0 : a.length) > 0)
                        return {
                            current: {
                                name: e.name,
                                link: e.url,
                                isTop: e.isTop,
                                lastSelected: !1
                            },
                            sideMenu: [...c, ...u],
                            parent: {
                                name: l.name,
                                link: l.pageUrl
                            },
                            parents: this.getParentsForDeny(e.id),
                            tagsMenu: null != u ? u : []
                        };
                    const d = this.menuByUrl.get(l.pageUrl);
                    return {
                        current: {
                            name: e.name,
                            link: e.url,
                            isTop: e.isTop,
                            lastSelected: !0
                        },
                        sideMenu: c,
                        parent: {
                            name: l.name,
                            link: l.pageUrl
                        },
                        parents: this.getParentsForDeny(e.id),
                        tagsMenu: null != (i = null == (o = d.childs) ? void 0 : o.map((e => ({
                            name: e.name,
                            link: e.url
                        })))) ? i : []
                    }
                }
                getRootNode(e) {
                    let t = e;
                    for (; null != t.parentId; )
                        t = this.menuById.get(t.parentId);
                    return t
                }
                hasItem(e) {
                    return !!e && this.menuById.has(e)
                }
                getCatalogLink(e) {
                    return this.menuById.get(e).url
                }
                getParents(e) {
                    const t = [];
                    let r = this.menuById.get(e).parentId;
                    for (; null != r; ) {
                        const e = this.menuById.get(r);
                        t.push(e.name),
                        r = e.parentId
                    }
                    return t.reverse()
                }
                getParentsForDeny(e) {
                    const t = [];
                    let r = this.menuById.get(e).parentId;
                    for (; null != r; ) {
                        const e = this.menuById.get(r);
                        t.push({
                            name: e.name,
                            link: e.url
                        }),
                        r = e.parentId
                    }
                    return t.reverse()
                }
                _createMenuMap() {
                    this.fullMenu.forEach((e => this._setNode(e, null)))
                }
                _setNode(e, t) {
                    var r;
                    t && (e.parentId = t),
                    this.menuByUrl.has(e.url) && !e.shard || (this.menuByUrl.set(e.url, e),
                    this.menuById.set(e.id, e)),
                    null == (r = e.childs) || r.forEach((t => this._setNode(t, e.id)))
                }
                _fromDynamicMenu(e, t) {
                    return e.map((e => r(e, t.id, t)));
                    function r(e, t, s) {
                        const n = {
                            id: 1e6 * s.id + e.id,
                            parent: null != t ? t : 1e6 * s.id + t,
                            name: e.name,
                            url: s.url + e.url.replace("/catalog", ""),
                            shard: e.shardKey,
                            query: e.query,
                            isDenyLink: e.childrenOnly || "blackhole" == e.shardKey
                        };
                        return e.nodes && (n.childs = e.nodes.map((e => r(e, n.id, s)))),
                        n
                    }
                }
                _prepareDropdownMenu(e, t=null) {
                    const r = {
                        parentItem: t
                    };
                    for (let t in e)
                        e.hasOwnProperty(t) && (Array.isArray(e[t]) ? r[t] = e[t].map((e => this._prepareDropdownMenu(e, r))) : r[t] = e[t]);
                    return r
                }
            }
            ;
            r(24623),
            r(59060);
            wb.xnm = function() {
                const e = [7031, 7032, 3382, 3392, 8332, 5020, 8411, 7018, 8251, 6217, 7019, 6296, 6304, 6302, 5783, 5519, 5948, 5814, 5784, 5789, 5813, 5553, 7015, 5779, 5780, 5292, 5293, 5294, 5297, 5478, 8588, 5132, 5129, 5150, 5121, 5126, 8590, 5361, 5127, 5128, 5158, 5193, 5194, 5159, 5019, 5186, 5021, 5023, 5119, 5122, 5125, 5156, 5065, 5050, 5084, 5025, 5037, 5026, 5086, 5040, 5043, 5045, 5046, 5052, 5064, 5066, 5068, 5070, 5073, 5076, 5085, 5087, 5088, 5091, 8589, 5051, 5090, 7014, 5117, 5118, 7025, 7733, 5069, 5071, 5120, 4256, 3489, 5075, 5080, 5197, 5534, 5482, 5288, 53, 5289, 5039, 2909, 5273, 2603, 2604, 2606, 2611, 3490, 2610, 2612, 7710, 2616, 2609, 2613, 2618, 5360, 2602, 2605, 5630, 7540, 5074, 5067, 2617, 2607, 7571, 6998, 5116, 5042, 5668, 2608, 5083, 2614, 5082, 5047, 8145, 5044, 7016, 5328, 7731, 8256, 5332, 5925, 5340, 5355, 7666, 7655, 5576, 7106, 5593, 5356, 7020, 5812, 400, 5049, 7755, 8110, 7012, 5072, 5048, 3517, 2615, 5325, 6303, 5153, 5359, 7770, 8111, 6315, 8248, 5326, 6246, 880, 5324, 5513, 5624, 5295, 8243, 2596, 5296, 5327, 1354, 7017, 5354, 5406, 6062, 6976, 7013, 7438, 5497, 5353, 5041, 5298, 7732, 5880, 6412, 5484, 5357, 3415, 3452, 3451, 3410, 6975, 6986, 6939, 6972, 6980, 6990, 7030, 6981, 6989, 6974, 6977, 6983, 6979, 6984, 6978, 6987, 6982, 6973, 6985, 5089, 5772];
                let t = [];
                const r = 864e5
                  , s = "adultSubjectIds";
                async function n() {
                    if (t.length > 0)
                        return Promise.resolve();
                    const e = JSON.parse(localStorage.getItem(s));
                    if ((null == e ? void 0 : e.expired) > Date.now() - r)
                        return t = e.info,
                        Promise.resolve();
                    try {
                        const e = "adult-subjects.json"
                          , n = await WbSpaModel.prototype.$httpClient.fetchStaticDataV2(e, 5e3);
                        return n && 0 !== n.length ? (t = n,
                        null == localStorage || localStorage.putObject(s, {
                            info: n,
                            expired: Date.now() + r
                        }),
                        Promise.resolve()) : (console.warn("Getting adult subjects has failed"),
                        Promise.reject())
                    } catch (e) {
                        return console.warn("Getting adult subjects has failed"),
                        console.error(e.message),
                        Promise.resolve()
                    }
                }
                let a = {};
                const o = 36e5
                  , i = "no-return-subjects.json";
                function l(r, s) {
                    const n = t.length > 0 ? t : e;
                    return -1 !== n.indexOf(r) || !!s && -1 !== n.indexOf(s)
                }
                class c {
                    constructor(e) {
                        let t = this;
                        this.width = this.weight = this.length = this.depth = 0,
                        null == e || e.forEach((function(e, r) {
                            "Вес с упаковкой (кг)" === e.name && (t.weight = parseFloat(e.value) || 0),
                            "Ширина упаковки (мм)" === e.name && (t.width = parseInt(e.value, 10) || 0),
                            "Длина упаковки (мм)" === e.name && (t.length = parseInt(e.value, 10) || 0),
                            "Высота упаковки (мм)" === e.name && (t.depth = parseInt(e.value, 10) || 0)
                        }
                        )),
                        this.v = this.width / 1e3 * (this.length / 1e3) * (this.depth / 1e3),
                        this.sum3d = this.width + this.length + this.depth
                    }
                }
                const u = (e, t) => {
                    if (e) {
                        if (wb.currencies.localeWithCoins.includes(t)) {
                            const t = e.toString();
                            return (t.slice(0, -2) || "0") + "." + t.slice(-2)
                        }
                        return e.toString().slice(0, -2)
                    }
                    return e
                }
                ;
                function d(e, t) {
                    if (t && e.pics > 0)
                        return !0;
                    if (!e.price)
                        return !1;
                    if (0 === e.pics || !e.sizes || 0 === e.sizes.length)
                        return !1;
                    for (let t = 0; t < e.sizes.length; t++) {
                        const r = e.sizes[t];
                        if (r.stocks && r.stocks.length > 0)
                            return !0
                    }
                    return !1
                }
                function p(e) {
                    return !!(e.sizes && e.sizes.length > 0)
                }
                function h(e, t) {
                    return !t || !e.isAdult
                }
                async function g(e, t, r) {
                    const s = `${(e => e ? m.XX : m.Aj)(r)}?${e}&nm=${t.join(";")}`;
                    return WbSpaModel.prototype.$httpClient.fetchBasicJSON(s, {
                        xhrFields: {
                            withCredentials: !1
                        },
                        processData: !1,
                        dataType: "json"
                    }, {
                        addAuthHeader: !0,
                        addCatalogCaptcha: !0,
                        retry: 2,
                        nullOnError: !0
                    })
                }
                function y(e, t=!1, r=null) {
                    return new Promise(( (s, a) => {
                        Promise.all([wb.user.getXinfo(), n()]).then(( ([n]) => {
                            var o, i;
                            ~~r && (n = WbSpaModel.prototype.$user._changeXDest(n, r));
                            const c = [];
                            let u = 0
                              , d = 0
                              , p = [];
                            const h = new URLSearchParams;
                            WbSpaModel.prototype.$analitic.appendSplitInfoV2(h, "catalog"),
                            h.size > 0 && (n += `&${h}`),
                            e.forEach((e => {
                                100 === u && (c[d] = g(n, p, t),
                                d += 1,
                                u = 0,
                                p = []),
                                p[u++] = e
                            }
                            )),
                            p.length > 0 && (c[d] = g(n, p, t));
                            const m = {}
                              , y = new URLSearchParams(n)
                              , v = null == (o = y.get("curr")) ? void 0 : o.toUpperCase()
                              , w = +y.get("spp")
                              , S = +y.get("dest")
                              , _ = !(wb.global.settings.switches.showLogisticsInPrice || (null == (i = wb.global.settings.variables.destToShowLogistics) ? void 0 : i.indexOf(S)) >= 0) || "ru" !== WbSpaModel.prototype.$user.getLocale();
                            Promise.all(c).then((e => {
                                e.forEach((e => {
                                    var t;
                                    0 === (t = e).state && t.data.products && t.data.products.forEach((e => {
                                        var t;
                                        e.name = (null == (t = e.name) ? void 0 : t.length) > 0 ? e.name : "Название не указано",
                                        e.isAdult = e.isAdult || l(e.subjectId, e.subjectParentId),
                                        e.currency = v,
                                        e.spp = w,
                                        e.dest = S,
                                        f(e),
                                        b(e, _),
                                        m[e.id] = e
                                    }
                                    ))
                                }
                                )),
                                s(m)
                            }
                            )).catch((e => {
                                console.log(e.statusText + " " + e.responseText),
                                a()
                            }
                            ))
                        }
                        ))
                    }
                    ))
                }
                function b(e, t=!0) {
                    var r;
                    if (!e || !e.sizes)
                        return;
                    let s = {}
                      , n = !1;
                    const a = e.premiumSale > 0 && ((null == (r = WbSpaModel.prototype.$user.getUserGradeFromCache()) ? void 0 : r.isPremium) || (null == e ? void 0 : e.showPremium));
                    a || (e.premiumSale = 0),
                    e.sizes.forEach((r => {
                        if (!r.price)
                            return;
                        let o = t ? r.price.total : r.price.product;
                        r.price.priceForBasket = o,
                        a && (o -= 100 * wb.priceHelper.calculateDiscount(r.price.product / 100, e.premiumSale, e.currency));
                        const i = ~~(100 * (r.price.basic - o) / r.price.basic);
                        r.price.sale = i > 0 ? i : 0,
                        r.price.priceToShow = o,
                        (r.price.basic < o || r.price.basic === o && r.sale > 0 || r.price.sale <= wb.global.settings.variables.pricesDeltaToShowSale) && (r.price.basic = o,
                        r.price.sale = 0),
                        s.priceToShow || (s = r.price),
                        s.priceToShow !== r.price.priceToShow && (n = !0,
                        s.priceToShow > r.price.priceToShow && (s = r.price))
                    }
                    )),
                    e.price = s,
                    n && (e.diffPrice = !0)
                }
                function f(e, t, r) {
                    var s, n, a, o, i;
                    return e ? (t || (t = null != (i = null != (o = null == (n = null == (s = e.sizes) ? void 0 : s.filter((e => e.payload))) ? void 0 : n[0]) ? o : null == (a = e.sizes) ? void 0 : a[0]) ? i : e),
                    t && t.saleConditions ? (1 & t.saleConditions && (e.isUnrefusable = !0),
                    2 & t.saleConditions && (e[1 === r ? "needPrepay" : "isPrepaid"] = !0),
                    4 & t.saleConditions && (e.isUnreturnable = !0),
                    8 & t.saleConditions && (e.isVerificationReturn = !0),
                    128 & t.saleConditions && (e.isWbInstCompliant = !0),
                    1048576 & t.saleConditions && (e.wltSaleBan = !0),
                    e.premiumSale = t.saleConditions >> 22 & 31,
                    e) : e) : e
                }
                function v() {
                    try {
                        return localStorage.getObject("product_colors") || {}
                    } catch (e) {
                        return console.warn("[ProductColorsCache]: failed to read from local storage", e),
                        {}
                    }
                }
                function w(e) {
                    var t;
                    let r = {
                        isOnlyColor: !1,
                        value: ""
                    }
                      , s = null == e ? void 0 : e.map((e => {
                        var t;
                        if (e.is_variable) {
                            let r = /^[\d.,]+$/
                              , s = null == (t = e.variable_values) ? void 0 : t.filter((e => {
                                if (!r.test(e))
                                    return e
                            }
                            )).join(", ");
                            if (!(4 !== e.charc_type && 5 !== e.charc_type || r.test(e.value)))
                                return {
                                    value: e.value,
                                    name: e.name
                                };
                            if (s)
                                return {
                                    value: s,
                                    name: e.name
                                }
                        }
                    }
                    )).filter((e => e)).splice(0, 3);
                    return 1 == (null == s ? void 0 : s.length) && "Цвет" == (null == (t = s[0]) ? void 0 : t.name) ? (r.isOnlyColor = !0,
                    r.value = null == s ? void 0 : s.map((e => e.value)).toString(),
                    r) : (null == s ? void 0 : s.length) >= 1 ? (r.isOnlyColor = !1,
                    r.value = null == s ? void 0 : s.map((e => e.value)).join(" • "),
                    r) : null
                }
                function S(e, t=!1, r=!1) {
                    var s, n, a, o, i, c, d;
                    const p = !(wb.global.settings.switches.showLogisticsInPrice || (null == (s = wb.global.settings.variables.destToShowLogistics) ? void 0 : s.indexOf(e.dest)) >= 0) || "ru" !== WbSpaModel.prototype.$user.getLocale();
                    b(e, p);
                    const h = null != (i = null == (a = null == (n = e.sizes) ? void 0 : n.filter((e => e.payload))) ? void 0 : a[0]) ? i : null == (o = e.sizes) ? void 0 : o[0];
                    f(e, h),
                    b(e, p);
                    const m = null != (c = e.price) ? c : {}
                      , g = 20624 === e.brandId || 30624 === e.siteBrandId;
                    let y = {
                        rcId: e.rcId,
                        nmId: e.id,
                        cod1S: e.id,
                        imtId: e.root,
                        name: e.name,
                        pics: e.pics,
                        subjectId: e.subjectId,
                        subjectParentId: e.subjectParentId,
                        kindId: e.kindId,
                        brand: e.brand,
                        brandId: e.siteBrandId,
                        brandCod: e.brandId,
                        price: u(m.basic, e.currency),
                        salePrice: u(m.priceToShow, e.currency),
                        productSalePrice: u(m.product, e.currency),
                        priceForBasket: u(m.priceForBasket, e.currency),
                        logisticsCost: m.logistics,
                        colorCodes: e.colors.map((e => e.id)),
                        sale: m.sale,
                        priceDiff: e.diffPrice,
                        star: e.rating,
                        reviewRating: e.reviewRating,
                        feedbacks: e.feedbacks,
                        adult: e.isAdult || l(e.subjectId, e.subjectParentId) || !1,
                        isDigitalGood: e.isDigital || !1,
                        sizes: _(e.sizes, t, r, e.currency),
                        panelPromoId: e.panelPromoId,
                        promoTxt: e.promoTextCat,
                        promoTextCard: e.promoTextCard,
                        color: e.colors.map((e => e.name)).join(","),
                        woSize: 1 === (null == (d = e.sizes) ? void 0 : d.length) && "" === h.name,
                        canQuickOrder: !e.isDigital,
                        soldOut: e.soldOut || !1,
                        deliveryHours: (e.time1 || 0) + (e.time2 || 0),
                        fastestStore: e.wh,
                        isPreorder: 5772 === e.brandId && wb.settings.preOrderList.includes(e.id),
                        currency: e.currency,
                        spp: e.spp,
                        dest: e.dest,
                        saleConditions: null == h ? void 0 : h.saleConditions,
                        isUnrefusable: e.isUnrefusable,
                        isPrepaid: e.isPrepaid,
                        isUnreturnable: e.isUnreturnable,
                        isVerificationReturn: e.isVerificationReturn,
                        dist: e.dist,
                        time1: e.time1,
                        time2: e.time2,
                        totalQuantity: e.totalQuantity,
                        payloadV2: null == h ? void 0 : h.payload,
                        optionId: null == h ? void 0 : h.optionId,
                        whDtype: null == h ? void 0 : h.dtype,
                        log: e.log,
                        logs: e.logs,
                        supplierId: e.supplierId,
                        supplier: $.views.helpers.supplierFineName(e.supplier, e.brandId),
                        supplierRating: e.supplierRating,
                        sort: e.sort || 0,
                        viewFlags: e.viewFlags,
                        shouldShowOriginalMark: !g && !!(8 & e.viewFlags),
                        paymentDiscountAmount: wb.settings.b2bMode ? 0 : wb.priceHelper.calcWalletDiscount(m.priceToShow / 100, e.currency, null == h ? void 0 : h.saleConditions),
                        catalogPrice: m,
                        supplierFlags: e.supplierFlags,
                        normQuery: e.normQuery,
                        rs: e.rs,
                        isAdv: e.isAdv,
                        extraAnaliticsCode: e.extraAnaliticsCode,
                        preset_type: e.preset_type,
                        premiumSale: e.premiumSale,
                        isAccentSnippet: wb.global.settings.switches.enablePremiumSellerAccent && !!(8 & e.supplierFlags),
                        isPremiumSeller: !0 & e.supplierFlags
                    };
                    return y.priceWithCouponAndDiscount = y.salePrice,
                    y.productPriceWithCouponAndDiscount = y.productSalePrice,
                    wb.settings.b2bMode && I(y.viewFlags) && (y.isVatRefundable = !0,
                    y.vatPercent = M(y.viewFlags)),
                    C(y.panelPromoId) && (y.showRedPrice = !0),
                    function(e) {
                        if (!WbSpaModel.prototype.$auth.isAuth || !e.totalQuantity || e.totalQuantity > 1e3)
                            return;
                        WbSpaModel.prototype.$promotionsHelper.isThermometerNeeded(e.panelPromoId) && (e.showThermometer = !0)
                    }(y),
                    y
                }
                const _ = (e, t=!1, r=!1, s=null) => {
                    if (null == e)
                        return;
                    e.sort((function(e, t) {
                        return e.rank - t.rank
                    }
                    ));
                    let n = e;
                    return t && (n = e.filter((e => {
                        var t;
                        return (null == (t = e.stocks) ? void 0 : t.length) > 0
                    }
                    ))),
                    n.map((e => {
                        var t, n;
                        const a = {
                            ch: e.optionId,
                            s: 1,
                            nm: e.origName,
                            rusNm: e.name,
                            stocks: null != (t = e.stocks) ? t : [{
                                wh: e.wh,
                                dtype: e.dtype,
                                qty: 1
                            }],
                            unavailable: (null == (n = e.stocks) ? void 0 : n.length) <= 0,
                            payloadV2: e.payload,
                            saleConditions: e.saleConditions,
                            whDtype: e.dtype,
                            deliveryHours: (e.time1 || 0) + (e.time2 || 0)
                        };
                        return r && e.price && (a.price = u(e.price.basic, e.currency || s),
                        a.salePrice = u(e.price.priceToShow, e.currency || s),
                        a.priceForBasket = u(e.price.priceForBasket, e.currency || s),
                        a.catalogPrice = e.price,
                        a.returnCost = e.price.return,
                        a.logisticsCost = e.price.logistics),
                        a
                    }
                    ))
                }
                ;
                function C(e) {
                    return !!WbSpaModel.prototype.$promotionsHelper.isRedPriceNeeded(e)
                }
                function I(e) {
                    return Boolean(e >> 14 & 1)
                }
                function M(e) {
                    switch (e >> 15 & 3) {
                    case 0:
                    case 3:
                        return null;
                    case 1:
                        return 10;
                    case 2:
                        return 20;
                    default:
                        return
                    }
                }
                return {
                    getGoodsForRecommendAndCatalog: function(e, t, r, s) {
                        return new Promise(( (n, a) => {
                            const o = [];
                            if (!e)
                                return o;
                            const i = !t;
                            y(e, i).then((a => {
                                e.forEach((e => {
                                    if (a[e]) {
                                        const n = a[e];
                                        if (i) {
                                            if (n && p(n) && h(n, r)) {
                                                const e = S(n, !1, !0);
                                                e.soldOut = !n.sizes || 0 === n.sizes.length,
                                                o.push(e)
                                            }
                                        } else if (n && d(n, t) && h(n, r)) {
                                            const e = S(n, !s, !0);
                                            e.soldOut = !d(n, !1),
                                            o.push(e)
                                        }
                                    }
                                }
                                )),
                                n(o)
                            }
                            )).catch(( () => {
                                e.forEach((e => {
                                    o.push({
                                        nmId: e,
                                        cod1S: e,
                                        isFail: !0
                                    })
                                }
                                )),
                                n(o)
                            }
                            ))
                        }
                        ))
                    },
                    getXnmProducts: y,
                    getInfoForWbaStat: async function(e, t) {
                        try {
                            const r = e.map((e => e.nmId))
                              , s = t ? await t : await y(r);
                            return e.reduce(( (e, t) => {
                                var r, n;
                                const {nmId: a, size: o} = t;
                                let i = null;
                                if (null == s ? void 0 : s.hasOwnProperty(t.nmId)) {
                                    const e = s[a]
                                      , t = null == (n = null == (r = e.sizes.find((e => e.optionId === o))) ? void 0 : r.price) ? void 0 : n.total
                                      , l = o ? e.sizes.find((e => e.optionId === o)) : _(e.sizes).filter((e => {
                                        var t;
                                        return (null == (t = e.stocks) ? void 0 : t.length) > 0
                                    }
                                    ))[0];
                                    i = {
                                        salePrice: t / 100,
                                        stores: null == l ? void 0 : l.stocks
                                    }
                                }
                                return e.set(a, i),
                                e
                            }
                            ), new Map)
                        } catch (e) {
                            return console.error(e),
                            new Map
                        }
                    },
                    getCatalogCards: function(e, t, r, s=!1) {
                        return new Promise(( (n, a) => {
                            const o = {};
                            e.forEach((e => {
                                o[e] = {}
                            }
                            ));
                            const i = !r;
                            y(e, i).then((e => {
                                Object.keys(e).forEach((n => {
                                    let a = e[n];
                                    const l = o[a.id];
                                    function c(e, t) {
                                        return e.rank > t.rank ? 1 : e.rank === t.rank ? 0 : e.rank < t.rank ? -1 : void 0
                                    }
                                    if (i)
                                        l && p(a) && h(a, t) && (o[a.id] = a,
                                        o[a.id].sizes.sort(c),
                                        a.soldOut = !1);
                                    else if (l && d(a, r) && h(a, t)) {
                                        if (o[a.id] = a,
                                        a.sizes && a.sizes.length > 0) {
                                            const e = s ? a.sizes : a.sizes.filter((e => e.stocks && e.stocks.length > 0));
                                            e.sort(c),
                                            o[a.id].sizes = e
                                        }
                                        a.soldOut = !d(a, !1)
                                    }
                                }
                                ))
                            }
                            )).then(( () => n(o)), ( () => a()))
                        }
                        ))
                    },
                    convertXProductToSpaCatalogProduct: S,
                    getProductNamesMap: v,
                    getProductColorsByNmIdsAsync: function(e) {
                        return new Promise(( (t, r) => {
                            let s = v()
                              , n = {}
                              , a = [];
                            if (e.forEach((e => {
                                let t = s[e];
                                t && t.dims ? n[e] = t : a.push(e)
                            }
                            )),
                            !a.length)
                                return void t(n);
                            let o = a.map((e => WbSpaModel.prototype.$httpClient.fetchStaticV3(wb.helpers.url.urlProductStatic, null, e).then((e => Promise.resolve({
                                options: e.options,
                                nmId: e.nm_id,
                                color: e.nm_colors_names,
                                name: e.imt_name,
                                dims: new c(e.options),
                                specs: w(e.options)
                            }))).catch(( () => Promise.resolve({
                                nmId: e,
                                color: ""
                            })))));
                            return Promise.all(o).then((e => {
                                !function(e, t) {
                                    try {
                                        const r = 255;
                                        t = null != t ? t : v(),
                                        e.forEach((e => t[e.nmId] = {
                                            nmId: e.nmId,
                                            c: e.color,
                                            n: e.name,
                                            dims: e.dims,
                                            specs: e.specs,
                                            ts: Date.now()
                                        }));
                                        let s = Object.values(t);
                                        return s.length > r && (s.sort(( (e, t) => t.ts - e.ts)),
                                        s.splice(r),
                                        t = s.reduce(( (e, t) => (e[t.nmId] = t,
                                        e)), {})),
                                        localStorage.putObject("product_colors", t),
                                        t
                                    } catch (e) {
                                        return console.warn("[ProductColorsCache]: failed to update colors map", e),
                                        {}
                                    }
                                }(e, s),
                                t(s)
                            }
                            ))
                        }
                        ))
                    },
                    fillOtherSellersProducts: function(e) {
                        return new Promise((t => {
                            y(e.map((e => e.nmId))).then((r => {
                                e.forEach((e => {
                                    const t = r[e.nmId];
                                    null != t && d(t) && (Object.assign(e, S(t, !0)),
                                    e.stocks = function(e) {
                                        return Object.keys(e.sizes.reduce(( (e, t) => {
                                            var r;
                                            return (null == (r = t.stocks) ? void 0 : r.length) > 0 && t.stocks.forEach((t => e[t.wh] = !0)),
                                            e
                                        }
                                        ), {}))
                                    }(t),
                                    e.isAvailable = !0)
                                }
                                )),
                                t()
                            }
                            ))
                        }
                        ))
                    },
                    getMiniProductCard: async function(e) {
                        if (isNaN(e))
                            throw new TypeError("nmId at getMiniProductCard is not a number");
                        const t = await y([e]);
                        return t[e] ? S(t[e], !1, !0) : null
                    },
                    proceedPrices: b,
                    waitNoReturnSubjectsInitialized: async function() {
                        if (Object.keys(a).length > 0)
                            return Promise.resolve();
                        const e = JSON.parse(localStorage.getItem(i));
                        if ((null == e ? void 0 : e.expired) > Date.now() - o)
                            return a = e.info,
                            Promise.resolve();
                        try {
                            const e = "no-return-subjects.json"
                              , t = await WbSpaModel.prototype.$httpClient.fetchStaticDataV2(e, 5e3);
                            return t && 0 !== t.length ? (a = t,
                            null == localStorage || localStorage.putObject(i, {
                                info: t,
                                expired: Date.now() + o
                            }),
                            Promise.resolve()) : (console.warn("Getting subjects has failed"),
                            Promise.reject())
                        } catch (e) {
                            return console.warn("Getting adult subjects has failed"),
                            console.error(e.message),
                            Promise.resolve()
                        }
                    },
                    setNoRefund: function(e) {
                        const t = a[e];
                        if (!t)
                            return !1;
                        let r;
                        switch (WbSpaModel.prototype.$user.getLocale()) {
                        case "by":
                            r = 2;
                            break;
                        case "kz":
                            r = 3;
                            break;
                        case "kg":
                            r = 4;
                            break;
                        case "am":
                            r = 5;
                            break;
                        case "uz":
                            r = 13;
                            break;
                        default:
                            r = 1
                        }
                        return !!(t & 1 << r - 1)
                    },
                    expandSaleConditions: f,
                    isRedPrice: C,
                    fillFeedbacksPayment: async function(e) {
                        if (!wb.global.settings.switches.enableFeedbacksForPoints || !(null == e ? void 0 : e.length))
                            return null;
                        await WbSpaModel.prototype.$moduleLoader.loadServiceAsync("feedbacksPaymentService"),
                        await WbSpaModel.prototype.$services.feedbacksPaymentService.fillFeedbacksPayments(e)
                    },
                    fillFeedbacksPaymentByUser: async function(e) {
                        if (!wb.global.settings.switches.enableFeedbacksForPoints || !(null == e ? void 0 : e.length))
                            return null;
                        await WbSpaModel.prototype.$moduleLoader.loadServiceAsync("feedbacksPaymentService"),
                        await WbSpaModel.prototype.$services.feedbacksPaymentService.fillFeedbacksPaymentsByUser(e)
                    },
                    getFeedbacksPaymentByUser: async function() {
                        return wb.global.settings.switches.enableFeedbacksForPoints ? (await WbSpaModel.prototype.$moduleLoader.loadServiceAsync("feedbacksPaymentService"),
                        await WbSpaModel.prototype.$services.feedbacksPaymentService.getFeedbacksPaymentByUser()) : null
                    },
                    convertOptionsToSpecs: w,
                    isAdvert: function(e) {
                        return e && !!(64 & e.viewFlags)
                    },
                    isB2BProduct: function(e) {
                        return Boolean(e >> 13 & 1)
                    },
                    isVatRefundable: I,
                    getVatPercent: M
                }
            }();
            r(28043),
            r(62894),
            r(89612);
            const pn = new RegExp(["www.wildberries.ru", "www.wildberries.by", "www.wildberries.kz", "www.wildberries.kg", "www.wildberries.am", "www.wildberries.tj", "www.wildberries.uz", "localhost", "webapp-*.wbx-site.k8s.dev-el", "webapp-*.wbx-site.k8s.stage-dm", "webapp-*.wbx-site.k8s.prod-el", "webapp-*.wbx-site.k8s.prod-xc", "kg.wildberries.ru", "uz.wildberries.ru", "*.wb.ru", "stage.wildberries.ru"].map((e => e.replace(/\./g, "\\.").replace(/\*/g, ".*"))).join("|"));
            wb.namespace("spa", function() {
                let e = {}
                  , t = new tn.A;
                const r = new Ys
                  , s = {};
                async function n() {
                    var e, t, r;
                    if (!((null == (t = null == (e = wb.global.settings) ? void 0 : e.variables) ? void 0 : t.resourseStatSettings) && "PerformanceObserver"in window && (null == (r = null == PerformanceObserver ? void 0 : PerformanceObserver.supportedEntryTypes) ? void 0 : r.includes("resource"))))
                        return;
                    const s = await wb.user.getShardAsync();
                    for (const e in wb.global.settings.variables.resourseStatSettings) {
                        const [t,r] = wb.global.settings.variables.resourseStatSettings[e].split(";")
                          , n = parseInt(r)
                          , [o,i] = t.split("-")
                          , l = parseInt(o)
                          , c = parseInt(i);
                        if (s >= l && s <= c && n > 0) {
                            let t = 0;
                            new PerformanceObserver((async r => {
                                var s, o, i, l, c;
                                if (r.getEntries) {
                                    const u = r.getEntries();
                                    for (const r of u.filter((t => t.initiatorType === e))) {
                                        if (t % n == 0 && !a(r)) {
                                            const e = {
                                                url: r.name,
                                                ok: r.responseStatus > 300 ? 1 : 0,
                                                error: r.responseStatus >= 300 ? r.responseStatus : 0,
                                                dns: parseInt(r.domainLookupEnd - r.domainLookupStart),
                                                connect: parseInt(r.connectEnd - r.connectStart),
                                                ttfb: parseInt(r.responseStart - r.requestStart),
                                                load: r.responseStart > 0 ? parseInt(r.responseEnd - r.fetchStart) : 0,
                                                full: parseInt(r.duration),
                                                cache: "HIT" === (null == (o = null == (s = r.serverTiming) ? void 0 : s.find((e => "cache" === e.name))) ? void 0 : o.description) ? 1 : 0,
                                                srv: null != (c = null == (l = null == (i = r.serverTiming) ? void 0 : i.find((e => "srv" === e.name))) ? void 0 : l.description) ? c : "",
                                                size: r.transferSize
                                            };
                                            wb.analitics.sendEvent("performance_static_download", e)
                                        }
                                        t++
                                    }
                                }
                            }
                            )).observe({
                                type: "resource",
                                buffered: !0
                            });
                            let r = 0;
                            new PerformanceObserver((e => {
                                if (e.getEntries) {
                                    const t = e.getEntries();
                                    for (const e of t.filter((e => "img-load-error" === e.name)))
                                        r % n == 0 && wb.analitics.sendEvent("performance_static_download", {
                                            url: e.detail.url,
                                            ok: 0
                                        }),
                                        r++
                                }
                            }
                            )).observe({
                                type: "mark",
                                buffered: !0
                            })
                        }
                    }
                }
                function a(e) {
                    return !(e.transferSize > 0) && (e.decodedBodySize > 0 || e.duration < 3)
                }
                return $.views.loadTemplateAsync = async function(e, t="") {
                    var n;
                    if ($.templates[e])
                        return $.templates[e];
                    if (!s[e]) {
                        let a = function(e, r) {
                            return t ? `${t}${o}` : wb.helpers.url.urlForJsTmpl(o, r)
                        };
                        let o;
                        if (window._debug)
                            o = `${e}.json`;
                        else {
                            r.$helper.currentCulture;
                            const t = `${e}.json`
                              , s = null == (n = r.$router.tmplHashes) ? void 0 : n[t];
                            o = t.replace(".json", `.${s}.json`)
                        }
                        s[e] = r.$httpClient.fetchStaticV3(a, {}, o)
                    }
                    try {
                        const t = await s[e]
                          , r = Object.keys(t);
                        return 1 === r.length ? ($.templates(e, t[r[0]]),
                        s[e] = null,
                        $.templates[e]) : ($.templates(t),
                        s[e])
                    } catch (t) {
                        throw s[e] = null,
                        t
                    }
                }
                ,
                $.views.loadWebApiTemplateAsync = async function(e) {
                    const t = `webapi_tmpl_${e}`;
                    if ($.templates[t])
                        return $.templates[t];
                    s[t] || (s[t] = r.$httpClient.fetchText(`/webapi/htmltemplate/${e}`));
                    try {
                        const e = await s[t];
                        try {
                            const t = JSON.parse(e);
                            $.templates(t)
                        } catch (r) {
                            $.templates(t, e)
                        }
                        return s[t] = null,
                        $.templates[t]
                    } catch (e) {
                        throw s[t] = null,
                        e
                    }
                }
                ,
                $.views.loadTemplateDictionaryAsync = function(e) {
                    return $.views.loadTemplateAsync(e)
                }
                ,
                $.views.converters({
                    formatString: function() {
                        let[e,t,r,s] = arguments;
                        if ("string" != typeof e)
                            throw new Error("Template must be a string");
                        return r && (e = e.replace(/\[(\d+)\]/gm, "{$1}")),
                        s && (t = $.views.converters.encode(t)),
                        String.format.apply(null, [e, t])
                    },
                    dateFormat: function(e, t) {
                        return e.format(t)
                    }
                }),
                {
                    init: async function(e) {
                        const {router: s, seoHelper: a, menuLkHelper: o} = e;
                        Object.defineProperty(Ys, "appVersion", {
                            value: s.appVersion,
                            writable: !1
                        }),
                        r.$router.setData(s.routesDictionary, s.tmplHashes),
                        await un.init(),
                        r.$moduleLoader.setModules(s.modules),
                        r.$moduleLoader.setServices(s.services);
                        const i = [];
                        if ("AbortController"in window || i.push(r.$moduleLoader.loadModuleAsync("abortControllerPolyfill", !0)),
                        "FormData"in window && "get"in (null == FormData ? void 0 : FormData.prototype) || i.push(r.$moduleLoader.loadModuleAsync("formDataPolyfill", !0)),
                        "undefined" == typeof navigator || navigator.locks || i.push(r.$moduleLoader.loadModuleAsync("navigatorLocksPolyfill", !0)),
                        i.length > 0 && await Promise.all(i),
                        wb.displayModeSettings.init(),
                        t.preInit(),
                        r.$user.initUser(),
                        await wb.global.loadSettingAsync(),
                        wb.global.periodicBasketConfigUpdate(),
                        r.$seoHelper.init(a.items, a.updateUrl, a.defaultTitle),
                        r.$menuLk.setStatic(o),
                        t.init(),
                        wb.network.init(),
                        function() {
                            const {isEnabled: e, company: t} = localStorage.getObject("b2bMode") || {
                                isEnabled: !1,
                                company: {}
                            };
                            e && r.$moduleLoader.loadModuleAsync("userCompaniesManager").then((e => {
                                const r = new e;
                                wb.user.userInfo.isAuth ? r.restoreState(t) : r.resetB2B()
                            }
                            ))
                        }(),
                        wb.analitics.getSplitInfo(),
                        WbSpaModel.prototype.$user.getBannersClusters(),
                        await r.$router.init(s.ssrModel),
                        !pn.test(window.location.hostname))
                            return wb.spa.logError({
                                message: `fishing from ${document.location}`
                            }, {
                                referrer: wb.spa.getReferrer(),
                                cookie: document.cookie
                            }),
                            wb.popup.renderModalError("Вы находитесь на фишинговом сайте!"),
                            void (wb.spa = null);
                        document.body.addEventListener("load", (e => {
                            var t;
                            "IMG" === e.target.tagName && e.target.complete && (null == (t = e.target.closest(".img-plug")) || t.classList.remove("img-plug--error"))
                        }
                        ), !0),
                        navigator.userAgent.indexOf("MSIE ") > 0 || navigator.userAgent.indexOf("Trident/") > 0 || document.body.addEventListener("error", (e => {
                            var t, r;
                            const s = e.target.closest(".img-plug")
                              , n = e.target.src;
                            return e.target.dataset.srcPb && e.target.dataset.srcPb !== n ? (e.target.src = e.target.dataset.srcPb,
                            delete e.target.dataset.srcPb,
                            void (null == s || s.classList.remove("load"))) : e.target.dataset.srcPc && e.target.dataset.srcPc !== n ? (e.target.src = e.target.dataset.srcPc,
                            void delete e.target.dataset.srcPc) : void ((null == (r = null == (t = wb.global.settings) ? void 0 : t.switches) ? void 0 : r.enableErrorImagePlug) && "IMG" === e.target.tagName && -1 === e.target.src.indexOf("/i/blank.gif") && (null == s || s.classList.add("img-plug--error"),
                            null == s || s.classList.remove("load"),
                            null == performance || performance.mark("img-load-error", {
                                detail: {
                                    url: e.target.src
                                }
                            })))
                        }
                        ), !0),
                        setTimeout(n, 2e3),
                        setTimeout((function() {
                            WbSpaModel.prototype.$helper.loadJsAsync(wb.settings.scripts.performance)
                        }
                        ), 5e3)
                    },
                    registerViewModel: function(t) {
                        const s = Object.getPrototypeOf(t.prototype);
                        s === Object.prototype ? Object.setPrototypeOf(t.prototype, Ys.prototype) : s !== Ys.prototype && Object.setPrototypeOf(s, Ys.prototype),
                        r.$router.getAppliedEntries().forEach((r => {
                            e[r] = t
                        }
                        ))
                    },
                    getViewModelByName: function(t) {
                        return e[t]
                    },
                    redirect: function(e, t, s=!1) {
                        r.$router.moveTo(e, t, !1, s)
                    },
                    setUserStatus: function({userIsAuth: e, userUid: t, userId: s}) {
                        $.observable(r.$router).setProperty({
                            userIsAuth: e,
                            userUid: t,
                            userId: s
                        }),
                        r.$eventBus.dispatchEvent(new CustomEvent(e ? "onUserAuth" : "onUserUnAuth")),
                        r.$services.favsService.setKey(e, t),
                        r.$services.userData.setKey(e, t),
                        r.$getService("orderService").then((e => e.startSync(r.$services.cartService.publicBasketApiUrl))),
                        r.$getService("wbxOrderService").then((e => e.startSync(r.$services.cartService.publicBasketApiUrl))),
                        e && (r.$getService("groupedDeliveriesService").then((e => e.init())),
                        "ru" !== wb.settings.currentLocale && r.$services.userData.migrateProfileFromGlobal())
                    },
                    refresh: function() {
                        r.$router.refresh()
                    },
                    getMainLayout: function() {
                        return t
                    },
                    getCatalogMenu: async function() {
                        return this._catalogMenuTask || (this._catalogMenuTask = new Promise((async (e, t) => {
                            const r = new dn;
                            await r.initMenu(),
                            r.isInited ? e(r) : (t(),
                            this._catalogMenuTask = null)
                        }
                        ))),
                        this._catalogMenuTask
                    },
                    clearCatalogMenu: function() {
                        this._catalogMenuTask = null
                    },
                    getReferrer: function() {
                        return r.$router.referrer
                    },
                    logError: function(e, t=null, r=!1) {
                        if (!window._debug)
                            try {
                                const s = {
                                    msg: e.message
                                };
                                r && (s.stk = e.stack),
                                t && (s.data = t);
                                const n = "/webapi/logging/jserror"
                                  , a = {
                                    method: "POST",
                                    headers: {
                                        "Content-Type": "application/json"
                                    },
                                    body: JSON.stringify(s)
                                };
                                WbSpaModel.prototype.$httpClient.fetch(n, a).catch(( () => {
                                    WbSpaModel.prototype.$services.retryFetchService.saveRequest(n, a)
                                }
                                ))
                            } catch (e) {}
                    },
                    orderMetrics: function(e) {
                        try {
                            WbSpaModel.prototype.$httpClient.fetch(`/webapi/logging/orders/metrics?status=${e}`, {
                                method: "POST"
                            })
                        } catch (e) {}
                    },
                    signIn: function(e, t) {
                        r.$router.moveToSignIn(e, t)
                    },
                    afterSignOut: function() {
                        wb.spa.signIn({
                            query: {
                                returnUrl: window.location.href
                            }
                        }),
                        t.updateAfterLogin()
                    }
                }
            }()),
            wb.namespace("global", function() {
                const e = "user-settings"
                  , t = "global-settings-v2"
                  , r = "cdn-config-v2"
                  , s = 18e4
                  , n = {
                    switches: {},
                    variables: {}
                };
                let a, o, i, l, c = [], u = !0, d = 200, p = 0;
                function h(e) {
                    if (!e || !WbSpaModel.appVersion)
                        return;
                    const t = e.split(".")
                      , r = WbSpaModel.appVersion.split(".");
                    if (t.length < 3 || r.length < 3)
                        return;
                    +((parseInt(r[0]) || 0) + ("000" + (parseInt(r[1]) || 0)).slice(-3) + ("000" + (parseInt(r[2]) || 0)).slice(-3)) < +(t[0] + ("000" + t[1]).slice(-3) + ("000" + t[2]).slice(-3)) && window.location.reload()
                }
                function m() {
                    return o || (o = localStorage.getObject(e),
                    o || (o = {}),
                    o.closed || (o.closed = []),
                    o.colorsHitory || (o.colorsHitory = []),
                    o.confirmed || (o.confirmed = []),
                    o)
                }
                function g(e) {
                    var t;
                    for (const r of ["mediabasket_route_map", "feedback_route_map", "videonme_route_map", "staticbasket_route_map"]) {
                        const s = e.origin[r]
                          , n = null != (t = e.recommend[r]) ? t : s;
                        if (!n || !s)
                            continue;
                        let a = "if (!reserve) {" + y(n[0], r) + "} else {" + y(s[0], r) + "}";
                        const o = new Function("number","reserve",a);
                        o(0),
                        wb.helpers.setImgFunc(r, o)
                    }
                }
                function y(e, t, r) {
                    const s = e => {
                        switch (e) {
                        case "staticbasket_route_map":
                            return "number";
                        case "videonme_route_map":
                            return "number%144";
                        default:
                            return "~~(number/100000)"
                        }
                    }
                    ;
                    let n = "";
                    if ("range" === e.method) {
                        n += `const volId = ${s(t)}; switch (true) {`;
                        for (const t of e.hosts)
                            n += `case volId >= ${t.vol_range_from} && volId <= ${t.vol_range_to}: return \`${t.host}${r ? "fail" : ""}/vol\${volId}\`;`;
                        n += "}"
                    } else if ("mod" === e.method) {
                        const r = e.hosts.length;
                        n += `const volId = ${s(t)}; switch (number % ${r}) {`;
                        for (let t = 0; t < r; t++)
                            n += `case ${t}: return \`${e.hosts[t].host}/vol\${volId}\`;`;
                        n += "}"
                    }
                    return n
                }
                return window.addEventListener("storage", (e => {
                    if (e.key === t)
                        try {
                            const {data: t} = JSON.parse(e.newValue);
                            a = t,
                            h(a.variables.siteMinVersion),
                            c.forEach((e => e(a))),
                            window._debug && console.log("[globalsettings] changed external")
                        } catch (e) {
                            console.error("[globalsettings] changed external failed")
                        }
                    else if (e.key === r) {
                        const t = JSON.parse(e.newValue);
                        t && g(t)
                    }
                }
                )),
                {
                    get settings() {
                        const e = function() {
                            var e, r;
                            return a || (a = null != (r = null == (e = localStorage.getObject(t)) ? void 0 : e.data) ? r : n,
                            a)
                        }();
                        return e.switches.enableWbxOrder = !0,
                        e
                    },
                    get userSettings() {
                        return m()
                    },
                    saveUserSettings: function() {
                        localStorage.putObject(e, m()),
                        Ys.prototype.$eventBus.dispatchEvent(new CustomEvent("UserSettingsSaved"))
                    },
                    subscribe(e) {
                        c.push(e)
                    },
                    loadSettingAsync: function e() {
                        return i || (i = setInterval(e, 12e4)),
                        u ? u = !1 : d = 2e3,
                        (p >= 2 ? Ys.prototype.$httpClient.fetchText("/webapi/settings/global/hash", {
                            method: "GET",
                            cache: "no-cache"
                        }, {
                            noProcessResponse: !0,
                            timeout: d
                        }) : Ys.prototype.$httpClient.fetchStaticV3(wb.helpers.url.urlStaticData, {
                            fetchType: "text",
                            noCache: !0,
                            timeout: d
                        }, "settings-front.json.hash")).then((e => {
                            var r;
                            if (null == e)
                                throw new Error;
                            if (e !== (null == (r = localStorage.getObject(t)) ? void 0 : r.hash)) {
                                return (p >= 2 ? Ys.prototype.$httpClient.fetchJSON("/webapi/settings/global/get", {
                                    method: "GET",
                                    cache: "no-cache",
                                    headers: {
                                        "Content-Type": "application/json"
                                    }
                                }, {
                                    noProcessResponse: !0,
                                    timeout: d
                                }) : Ys.prototype.$httpClient.fetchStaticV3(wb.helpers.url.urlStaticData, {
                                    noCache: !0,
                                    timeout: d
                                }, "settings-front.json")).then((r => (a = r,
                                localStorage.putObject(t, {
                                    hash: e,
                                    data: a
                                }),
                                p = 0,
                                window._debug && console.log("[globalsettings] changed"),
                                c.forEach((e => e(a))),
                                h(a.variables.siteMinVersion),
                                Promise.resolve()))).catch(( () => Promise.resolve()))
                            }
                            return Promise.resolve()
                        }
                        )).catch(( () => (p++,
                        Promise.resolve())))
                    },
                    periodicBasketConfigUpdate: async function e() {
                        if (WbSpaModel.prototype.$isRangeEnabledFor(wb.global.settings.variables.usersRangeCdnConfigV2))
                            if (l)
                                try {
                                    await navigator.locks.request(`lock-${r}`, (async e => {
                                        const t = localStorage.getObject(r);
                                        if (t && t.timestamp + s > Date.now())
                                            return;
                                        const n = await Ys.prototype.$httpClient.fetchBasicJSON(`https://cdn.wbbasket.ru/api/v3/upstreams?t=${Date.now()}`, {
                                            cache: "no-cache"
                                        }, {
                                            nullOnError: !0
                                        });
                                        (null == n ? void 0 : n.recommend) && (null == n ? void 0 : n.origin) && (g(n),
                                        Object.assign(n, {
                                            timestamp: Date.now(),
                                            hash: n.hash
                                        }),
                                        localStorage.putObject(r, n),
                                        localStorage.removeItem("cdn-config"))
                                    }
                                    ))
                                } catch (e) {
                                    wb.spa.logError(e)
                                }
                            else {
                                l = setInterval(e, s);
                                const t = localStorage.getObject(r);
                                t && t.timestamp + s > Date.now() ? g(t) : setTimeout(e, 5e3)
                            }
                    }
                }
            }())
        },
        68982: function(e, t, r) {
            "use strict";
            r.d(t, {
                A: function() {
                    return N
                }
            });
            var s = {};
            r.r(s),
            r.d(s, {
                dataProceeder: function() {
                    return c
                },
                urlCreator: function() {
                    return l
                }
            });
            var n = class {
                constructor(e) {
                    var t;
                    this.layoutModel = e.layoutModel,
                    this.tmpl = "shortBasketInfoTmpl",
                    this.control = document.querySelector("#basketContent"),
                    this.addressesInfo = null,
                    this.eventsModels = this.layoutModel.$services.notifications.eventsModel,
                    this.profileMenu = null,
                    this.lkMenuMouseEnterHandler = this.lkMenuMouseEnterHandler.bind(this),
                    this.deliveriesPreviewEnterHandler = this.deliveriesPreviewEnterHandler.bind(this),
                    this.toggleControl = this.toggleControl.bind(this),
                    this.controlState = {
                        hide: !1
                    },
                    this.basketInfo = {
                        IsAuthenticated: this.layoutModel.$auth.isAuth,
                        BasketQuantity: this.layoutModel.$services.cartService.localCount,
                        UserIsPremium: !!this.layoutModel.$auth.isAuth && (null == (t = this.layoutModel.$user.getUserGradeFromCache()) ? void 0 : t.isPremium)
                    },
                    $.templates[this.tmpl].link(this.control, this, {
                        controlState: this.controlState
                    })
                }
                init() {
                    var e, t, r;
                    this.layoutModel.$eventBus.addEventListener("LocalBasketUpdateCount", this._updateLocalBasketCount.bind(this)),
                    this.layoutModel.$eventBus.addEventListener("UserReset", this.update.bind(this)),
                    this.layoutModel.$eventBus.addEventListener("UserGradeUpdated", this.updatePremiumState.bind(this));
                    const s = this.layoutModel.$services.cartService.currentDeliveryType;
                    s && this.layoutModel.$analitic.setCurrentAddress(s.deliveryType, null != (e = s.officeId) ? e : s.addressId),
                    (null == (r = null == (t = this.layoutModel) ? void 0 : t.menuTop) ? void 0 : r.mobileMenu) && this.layoutModel.menuTop.mobileMenu.updateBasket(this.basketInfo.BasketQuantity),
                    window.addEventListener("spaTransition", (e => {
                        e.detail.isFinished && this.toggleControl(!1)
                    }
                    )),
                    this.basketInfo.IsAuthenticated && this.layoutModel.$services.notifications.checkNotificationCountAsync().then((e => {
                        var t, r;
                        (null == (r = null == (t = this.layoutModel) ? void 0 : t.menuTop) ? void 0 : r.mobileMenu) && this.layoutModel.menuTop.mobileMenu.updateEvents(e),
                        $.observable(this.eventsModel).setAllProperty(e)
                    }
                    ))
                }
                update() {
                    var e;
                    const t = {
                        IsAuthenticated: this.layoutModel.$auth.isAuth,
                        BasketQuantity: this.layoutModel.$services.cartService.localCount,
                        UserIsPremium: null == (e = this.layoutModel.$user.getUserGradeFromCache()) ? void 0 : e.isPremium
                    };
                    $.observable(this.basketInfo).setAllProperty(t),
                    (t.IsAuthenticated ? this.layoutModel.$services.notifications.checkNotificationCountAsync() : Promise.resolve({
                        eventsCount: 0
                    })).then((e => {
                        var t, r;
                        (null == (r = null == (t = this.layoutModel) ? void 0 : t.menuTop) ? void 0 : r.mobileMenu) && this.layoutModel.menuTop.mobileMenu.updateEvents(e),
                        $.observable(this.eventsModel).setAllProperty(e)
                    }
                    ))
                }
                updatePremiumState() {
                    var e;
                    $.observable(this.basketInfo).setProperty({
                        UserIsPremium: null == (e = this.layoutModel.$user.getUserGradeFromCache()) ? void 0 : e.isPremium
                    })
                }
                _updateLocalBasketCount(e) {
                    var t, r, s, n;
                    const a = null != (r = null == (t = e.detail) ? void 0 : t.count) ? r : 0;
                    $.observable(this.basketInfo).setProperty({
                        BasketQuantity: a
                    }),
                    (null == (n = null == (s = this.layoutModel) ? void 0 : s.menuTop) ? void 0 : n.mobileMenu) && this.layoutModel.menuTop.mobileMenu.updateBasket(a)
                }
                deliveriesPreviewEnterHandler() {
                    if (this.deliveriesPreview)
                        return this.toggleControl(!0);
                    this.layoutModel.$moduleLoader.loadModuleAsync("deliveriesPreview").then((e => {
                        const t = this.control.querySelector(".j-tooltip-delivery");
                        this.deliveriesPreview = new e,
                        e.template.link(t, this.deliveriesPreview, {
                            controlState: this.controlState
                        }),
                        this.toggleControl(!0)
                    }
                    ))
                }
                lkMenuMouseEnterHandler() {
                    if (this.lkMenuPreview)
                        return this.toggleControl(!0);
                    const e = WbSpaModel.prototype;
                    Promise.all([e.$moduleLoader.loadModuleAsync("cabinetMenuPreview"), e.$user.getBalance().catch((e => Promise.resolve({
                        isNetworkError: !0
                    }))), e.$services.userData.getUserDataAsync(!0)]).then(( ([e,t]) => {
                        const r = this.control.querySelector(".j-tooltip-profile");
                        this.lkMenuPreview = new e(t),
                        this.lkMenuPreview.template.link(r, this.lkMenuPreview, {
                            controlState: this.controlState
                        }),
                        this.lkMenuPreview.onAfterRender(),
                        this.toggleControl(!0)
                    }
                    ))
                }
                toggleControl(e) {
                    $.observable(this.controlState).setProperty({
                        hide: !e
                    })
                }
            }
              , a = Object.freeze({
                history: 0,
                catalog: 1,
                brands: 2,
                subjects: 3,
                goods: 4,
                grouped: 5,
                tags: 6,
                supplier: 7,
                redirect: 8
            });
            const o = new class {
                constructor() {
                    this.isInited = !1
                }
                async initMenu() {
                    this.menu = await wb.spa.getCatalogMenu(),
                    this.isInited = this.menu.isInited
                }
                hasItem(e) {
                    return !!e && this.menu.menuById.has(e)
                }
                getCatalogLink(e) {
                    return this.menu.menuById.get(e).url
                }
                getParents(e) {
                    const t = [];
                    let r = this.menu.menuById.get(e).parentId;
                    for (; null != r; ) {
                        const e = this.menu.menuById.get(r);
                        t.push(e.name),
                        r = e.parentId
                    }
                    return t.reverse()
                }
            }
              , i = Object.freeze(new Map([["home", "/"], ["faq", "/services/voprosy-i-otvety"], ["lk", "/lk"], ["notifications", "/lk#notifications"], ["basket", "/lk/basket"], ["delivery", "/lk/myorders/delivery"], ["orders", "/lk/myorders/archive"], ["favorites", "/lk/favorites"], ["favorite_brands", "/lk/favoritebrands"], ["communications", "/lk/communications"], ["claims", "/lk/claims"], ["feedback", "/lk/discussion/feedback"], ["cards", "/lk#bankCard"], ["sessions", "/lk#personal-safety"], ["balance", "/lk/mywallet/purchases"], ["refunds", "/lk/myrefunds"], ["receipts", "/lk/receipts/get"], ["pickups", "/services/besplatnaya-dostavka"], ["make_refund", "/lk/refund"], ["make_order", "/services/kak-sdelat-zakaz"], ["payment_options", "/services/sposoby-oplaty"], ["goods_refund", "/services/vozvrat-tovara"], ["money_refund", "/services/vozvrat-denezhnyh-sredstv"], ["sale_rules", "/services/pravila-prodazhi"], ["market_rules", "/services/pravila-polzovaniya-torgovoy-ploshchadkoy"], ["about_us", "/services/o-nas"], ["requisites", "/services/rekvizity"], ["press", "/presservice"], ["contacts", "/services/kontakty"], ["bug_bounty", "/services/bug-bounty"]]))
              , l = async () => "https://suggests.wb.ru/suggests/api/v7/hint"
              , c = async (e, t) => {
                const r = e.suggests
                  , s = e.max_tags_rows
                  , n = [];
                if (!Array.isArray(r) && !t)
                    return n;
                if ((!Array.isArray(r) || Array.isArray(r) && 0 === r.length) && t.trim())
                    return [{
                        type: a.catalog,
                        suggestions: [{
                            name: t,
                            search: t,
                            type: 1,
                            typedText: t
                        }]
                    }];
                if (o.isInited || await o.initMenu(),
                0 !== s) {
                    const e = r.filter((e => "tag" === e.type)).map((e => ({
                        name: e.name,
                        type: a.catalog,
                        typeStr: e.type,
                        pos: e.pos,
                        maxTagsRows: s
                    })));
                    n.push({
                        type: a.tags,
                        suggestions: e
                    })
                }
                const l = r.filter((e => "category" === e.type || "brand" === e.type || "supplier" === e.type || "redirect" === e.type || "external_redirect" === e.type)).map((e => {
                    switch (e.type) {
                    case "category":
                        const r = parseInt(e.menu_id);
                        if (o.hasItem(r)) {
                            const s = o.menu.menuById.get(r);
                            return {
                                typeStr: e.type,
                                name: s.name,
                                search: s.name,
                                typedText: t,
                                type: a.subjects,
                                xParams: s.query,
                                xShard: s.shard,
                                url: o.getCatalogLink(r),
                                breadCrumbs: o.getParents(r),
                                src: $.views.converters.imgForPromoCategory(r, !0),
                                imgWidth: 36,
                                imgHeight: 48
                            }
                        }
                        break;
                    case "brand":
                        return {
                            typeStr: e.type,
                            typeName: "Бренд",
                            name: e.brand_name,
                            search: e.brand_name,
                            brandId: e.brand_id,
                            brandHash: e.brand_hash,
                            typedText: t,
                            type: a.brands,
                            src: $.views.helpers.forBrandLogoFromId(e.brand_hash),
                            srcReserve: $.views.helpers.forBrandLogoFromId(e.brand_hash, !0),
                            imgOnError: $.views.converters.urlSiteStatic("i/v3/broken-img/brands.jpg"),
                            imgWidth: 32,
                            imgHeight: 13
                        };
                    case "supplier":
                        return {
                            typeStr: e.type,
                            typeName: "Магазин",
                            name: $.views.converters.trimWord(e.supplier_name, $.views.helpers.suppliersOrgForms),
                            search: e.supplier_name,
                            supplierId: e.supplier_id,
                            typedText: t,
                            type: a.supplier,
                            url: `/seller/${e.supplier_id}`,
                            src: $.views.helpers.forSellerLogo(e.supplier_id),
                            svrReserve: $.views.helpers.forSellerLogoPb(e.supplier_id),
                            imgOnError: $.views.converters.urlSiteStatic("i/v3/catalog/seller-logo-new.jpg"),
                            imgWidth: 67,
                            imgHeight: 28
                        };
                    case "redirect":
                    case "external_redirect":
                        return {
                            typeStr: e.type,
                            typeName: "Раздел",
                            name: e.name,
                            search: e.name,
                            id: e.id,
                            typedText: t,
                            type: a.redirect,
                            url: "external_redirect" === e.type ? e.url : i.get(e.id),
                            src: $.views.converters.urlSiteStatic("i/v3/shops/wb.webp"),
                            imgWidth: 67,
                            imgHeight: 28
                        }
                    }
                }
                )).filter((e => e));
                n.push({
                    type: a.grouped,
                    suggestions: l
                });
                const c = r.filter((e => "suggest" === e.type)).map((e => ({
                    name: e.name,
                    search: e.name,
                    type: a.catalog,
                    typedText: t,
                    typeStr: e.type,
                    xParams: e.query,
                    xShard: e.shard_key
                }))).slice(0, 7);
                return 0 === c.length && 0 === tagsSuggests.length && t.trim() && c.push({
                    name: t,
                    search: t,
                    type: a.catalog,
                    typedText: t,
                    typeStr: "self"
                }),
                n.push({
                    type: a.catalog,
                    suggestions: c
                }),
                n
            }
              , u = [34, 42]
              , d = [38, 40]
              , p = Object.freeze({
                6: 0,
                0: 1,
                1: 2,
                5: 3
            });
            class h extends WbSpaModel {
                constructor() {
                    super(),
                    this.searchText = "",
                    this.searchQueryText = "",
                    this.showImageSearch = !1,
                    this.uploadingPhoto = !1,
                    this.suggestions = [],
                    this.allSuggestions = [],
                    this.suggestionsQueue = [],
                    this.prohibitSuggestions = !0,
                    this.searchTagClick = !1,
                    this.onlyTags = !1,
                    this.showSuggestionsDebouncer = this.showSuggestionsDebouncer(),
                    this.showSuggestionsDebounced = this.showSuggestionsDebouncer.debounce(this.showSuggestionsOuter.bind(this), 100),
                    this._hideSuggestionsByClick = this._hideSuggestionsByClick.bind(this)
                }
                get allSuggestionsAnalitics() {
                    return this.allSuggestions.map((e => e.name)).join("|")
                }
                get suggestionsJsonString() {
                    const e = {}
                      , t = this.allSuggestions.map((t => {
                        t.typeStr in e || (e[t.typeStr] = 0);
                        const r = e[t.typeStr];
                        return e[t.typeStr] += 1,
                        {
                            type: "history" === t.typeStr ? "hist" : t.typeStr,
                            value: t.name,
                            index: r
                        }
                    }
                    ));
                    return this.$analitic.saveLastSearchAnalyticsDataForSuggest(JSON.stringify(t)),
                    JSON.stringify(t)
                }
                get location() {
                    return {
                        SpaActiveOrdersEntrypoint: "Delivery",
                        SpaCatalogEntrypoint: "Catalog",
                        SpaSearchEntrypoint: "Catalog",
                        SpaBrandsEntrypoint: "Brand",
                        SpaSellerCatalogEntrypoint: "Supplier",
                        SpaArchivePositionsEntrypoint: "Purchases",
                        SpaFavoritesEntrypoint: "Favorites",
                        SpaBasketEntrypoint: "Cart",
                        SpaPersonalCabinetEntrypoint: "LK",
                        SpaHomeEntrypoint: "Main"
                    }[WbSpaModel.prototype.$router.currentRoute.name]
                }
                clearSearch() {
                    this.searchTagClick = !1,
                    this.onlyTags = !1,
                    $.observable(this).setProperty({
                        searchText: ""
                    }),
                    this.inputEl.focus()
                }
                onSearchInputKeypress(e) {
                    var t;
                    if (u.indexOf(e.which) > -1)
                        return !1;
                    if (13 === e.which)
                        return this.showSuggestionsDebouncer.stop(),
                        this.applySearch(),
                        !1;
                    if (this.onlyTags) {
                        const e = this.allSuggestionsAnalitics;
                        this.$analitic.saveLastSearchAnaliticsData("Tag_Suggest", this.searchText, e),
                        this.onlyTags = !1
                    }
                    if (this.$isDesktop && d.indexOf(e.which) > -1 && this.allSuggestions.length) {
                        e.preventDefault();
                        const r = 38 === e.which
                          , s = this.allSuggestions.filter((e => 1 !== e.type || 1 === e.type && !e.hasOwnProperty("pos")));
                        let n = s.findIndex((e => e.selected));
                        r && -1 === n && (n = 0),
                        n += r ? -1 : 1,
                        n %= s.length,
                        n < 0 && (n += s.length);
                        const a = s[n];
                        null != a && ($.observable(this).setProperty({
                            searchText: a.name
                        }),
                        null == (t = this._markSuggestAsSelected) || t.call(this, a))
                    }
                }
                onSearchSubmit(e) {
                    e.preventDefault()
                }
                applySearch() {
                    this.searchText.length && (this.inputEl.blur(),
                    this._hideSuggestionsByClick(),
                    this._loadSearchPage())
                }
                async searchByImage(e) {
                    const [t] = await Promise.all([this.$moduleLoader.loadModuleAsync("imageChip"), this.$moduleLoader.loadServiceAsync("searchByImageService")])
                      , r = new t;
                    r.uploading = !0,
                    $.observable(this).setProperty({
                        imageChipData: r
                    });
                    try {
                        this.$analitic.saveState({
                            l: "SPA"
                        });
                        const t = e.currentTarget.files[0]
                          , r = await this.$services.searchByImageService.searchByImage(t)
                          , s = this.$analitic.getTermByTermName("qid");
                        this.$analitic.saveQueryIdForSearch(s),
                        this.$analitic.sendEvent("Search_Request_Send", {
                            type: "Photo",
                            query_id: s
                        }),
                        this.$router.moveTo(r)
                    } catch (e) {
                        console.error(e)
                    } finally {
                        $.observable(this).setProperty({
                            showImageSearch: !1
                        })
                    }
                }
                enableSuggestions(e) {
                    if (!this.imageChipData)
                        return "focus" === e.type && (this.focusSearchTime = Date.now().toString(),
                        this.focusSearchText = this.searchText),
                        $.observable(this).setProperty({
                            prohibitSuggestions: !1
                        }),
                        this.showSuggestions(e);
                    e.preventDefault()
                }
                showSuggestionsDebouncer() {
                    let e = null;
                    function t() {
                        e && clearTimeout(e)
                    }
                    return {
                        debounce: (r, s) => (...n) => {
                            t(),
                            e = setTimeout(( () => {
                                r.apply(this, n),
                                e = null
                            }
                            ), s)
                        }
                        ,
                        stop: t
                    }
                }
                showSuggestionsOuter(e) {
                    return this.prohibitSuggestions ? this.enableSuggestions(e) : this.showSuggestions(e)
                }
                showSuggestions(e) {
                    if (this.imageChipData)
                        return void (null == e || e.preventDefault());
                    clearTimeout(this._hideSuggestionsTimer);
                    const t = this.suggestionsHelper.loadSuggestionsAsync(this.searchText, null)
                      , r = this.$isDesktop ? $.views.loadTemplateDictionaryAsync("searchSuggestionsTmpl") : Promise.resolve();
                    this.suggestionsQueue.push(t),
                    Promise.all([t, r]).then(( ([e]) => {
                        var r;
                        if (this.prohibitSuggestions)
                            return void $.observable(this.suggestions).refresh([]);
                        const s = this.suggestionsQueue.findIndex((e => e == t));
                        if (s < 0)
                            return;
                        this.suggestionsQueue = this.suggestionsQueue.slice(s + 1);
                        const n = JSON.parse(JSON.stringify(e));
                        this._removeRepeats(n),
                        this._sortSuggests(n),
                        $.observable(this.suggestions).refresh(n);
                        const a = null == (r = n.find((e => 6 === e.type))) ? void 0 : r.suggestions;
                        if (a) {
                            const e = a[0].maxTagsRows;
                            if (e > 0) {
                                const t = document.querySelector(".j-unmark-suggests");
                                document.documentElement.style.setProperty("--row-on-tags", e),
                                t.classList.add("autocomplete__list--row")
                            }
                        }
                        this.allSuggestions = n.reduce(( (e, t) => e.concat(t.suggestions)), []),
                        document.removeEventListener("click", this._hideSuggestionsByClick),
                        document.addEventListener("click", this._hideSuggestionsByClick),
                        this.toggleBackgroundBlur(!0)
                    }
                    )).catch((e => {
                        console.error(e)
                    }
                    ))
                }
                toggleBackgroundBlur(e) {
                    var t;
                    if (e && this.$isDesktop) {
                        if (!document.querySelector(".overlay--search")) {
                            const e = document.createElement("div");
                            e.classList.add("overlay", "overlay--search", "hide-mobile"),
                            document.querySelector("body").appendChild(e)
                        }
                    } else
                        null == (t = document.querySelector(".overlay--search")) || t.remove()
                }
                _hideSuggestionsByClick(e) {
                    if ("m" == wb.settings.displayMode || (null == e ? void 0 : e.target.closest(".search-catalog__btn--clear")))
                        return;
                    (e ? !e.target.closest(".j-menu-burger-btn") && this.inputEl == document.activeElement || e.target.closest(".j-clear-history") || e.target.closest(".j-clear-history-all") || e.target.closest(".j-suggest-tag") : null) ? this.inputEl.focus() : (clearTimeout(this._hideSuggestionsTimer),
                    $.observable(this).setProperty({
                        prohibitSuggestions: !0
                    }),
                    this._hideSuggestionsTimer = setTimeout(( () => {
                        $.observable(this.suggestions).refresh([]),
                        document.removeEventListener("click", this._hideSuggestionsByClick),
                        this.toggleBackgroundBlur(!1)
                    }
                    ), 150))
                }
                clearAllSearchHistories(e) {
                    this._clearSearchHistory(null, !0),
                    this.$analitic.sendEvent("Search_History_Delete")
                }
                clearSearchHistory(e) {
                    const {data: t} = $.view(e.currentTarget);
                    this._clearSearchHistory(t.name)
                }
                _clearSearchHistory(e, t) {
                    this.suggestionsHelper.removeFromHistorySearch(e, t),
                    "m" === wb.settings.displayMode && this.showSuggestions(),
                    this.inputEl.focus()
                }
                fillWithTag(e) {
                    var t, r, s;
                    if (this.searchTagClick = !0,
                    e.target.closest(".j-clear-history"))
                        return;
                    const {data: n} = $.view(e.currentTarget);
                    if (!n)
                        return;
                    const a = null != (t = n.name) ? t : ""
                      , o = (this.searchText,
                    this.searchText.trimLeft().split(/\s+/));
                    o[n.pos] = a,
                    this.onlyTags = !0,
                    this.$analitic.sendEvent("Search_Tag_Suggest_T", {
                        text: a,
                        text_typed: null != (r = this.searchText) ? r : ""
                    }),
                    $.observable(this).setProperty({
                        searchText: o.join(" ") + " "
                    }),
                    null == (s = this.inputEl) || s.focus()
                }
                _setTextInSearchInput(e) {
                    console.log("_setTextInSearchInput"),
                    $.observable(this).setProperty({
                        searchText: e
                    }),
                    !this.$isDesktop && this.parentBlock && $.observable(this.parentBlock).setProperty({
                        searchText: e
                    })
                }
                followSuggest(e) {
                    var t, r, s;
                    if (e.target.closest(".j-clear-history"))
                        return;
                    this.onlyTags = !1;
                    const {data: n} = $.view(e.currentTarget);
                    if (null == n)
                        return;
                    const a = this.allSuggestionsAnalitics;
                    this._setTextInSearchInput(n.name),
                    this.suggestionsHelper.saveHistorySearch(n.name);
                    const o = this._getAnalyticsFromSuggest(n)
                      , i = {
                        type: o.type,
                        l: o.location,
                        t: this.searchText,
                        t1: null == (t = n.searchParams) ? void 0 : t.get("xParams"),
                        t2: null == (r = n.searchParams) ? void 0 : r.get("xShard"),
                        t3: n.typedText,
                        t4: this.searchTagClick
                    }
                      , l = o.type;
                    this.$analitic.saveLastSearchAnaliticsData("Suggest", this.searchText, a);
                    const c = this.$analitic.getTermByTermName("qid");
                    this.$analitic.saveQueryIdForSearch(c),
                    this.$analitic.saveState(i);
                    const u = {
                        type: l,
                        text: n.search,
                        text_typed: n.typedText,
                        text_suggest: a,
                        query_id: c,
                        suggests: this.suggestionsJsonString,
                        start_inputed_at: this.focusSearchTime,
                        start_inputed_text: this.focusSearchText,
                        location: null != (s = this.location) ? s : ""
                    };
                    n.isBrand || n.isHistory || (u.group = "new"),
                    this.$analitic.sendEvent("Search_Request_Send", u),
                    this._getUrlToFollow(n).then((e => {
                        if (null != wb.spa)
                            return wb.spa.redirect(e);
                        window.location.href = e
                    }
                    ))
                }
                removeImageChip() {
                    $.observable(this).setProperty({
                        imageChipData: null
                    })
                }
                _loadSearchPage() {
                    var e, t, r, s;
                    if (/^\s+$/.test(this.searchText)) {
                        switch (wb.analitics.getState().l) {
                        case "SNT":
                        case "STA":
                            this.typeSearch = "Text";
                            break;
                        case "SNS":
                            this.typeSearch = "Suggest";
                            break;
                        case "SNH":
                        case "SHS":
                            this.typeSearch = "Hist";
                            break;
                        case "STC":
                            this.typeSearch = "Category";
                            break;
                        case "STB":
                            this.typeSearch = "Brand";
                            break;
                        case "SPA":
                            this.typeSearch = "Photo";
                            break;
                        case "AST":
                        case "SST":
                        case "SIS":
                            this.typeSearch = "Tag_Suggest"
                        }
                        let t = {
                            type: null != (e = this.typeSearch) ? e : "",
                            text: this.searchText,
                            text_typed: this.searchText,
                            reason: "search",
                            query: "",
                            shardKey: "",
                            text_suggest: "",
                            suggests: this.suggestionsJsonString,
                            query_id: wb.analitics.retrieveQueryIdForSearch()
                        };
                        wb.analitics.sendEvent("Search_Empty_Respon", t)
                    }
                    this.suggestionsHelper.saveHistorySearch(this.searchText);
                    const n = this.allSuggestionsAnalitics;
                    this.$analitic.saveState({
                        l: this.onlyTags ? "SST" : "SNT",
                        t: this.searchText,
                        t1: null == (t = this.xData) ? void 0 : t.xcatalogQuery,
                        t2: null == (r = this.xData) ? void 0 : r.xcatalogShard,
                        t4: this.searchTagClick
                    });
                    const a = this.$analitic.getTermByTermName("qid");
                    this.$analitic.saveQueryIdForSearch(a),
                    this.$analitic.sendEvent("Search_Request_Send", {
                        text: this.searchText,
                        type: this.onlyTags ? "Tag_Suggest" : "Text",
                        group: "new",
                        text_typed: this.searchText,
                        text_suggest: n,
                        query_id: a,
                        suggests: this.suggestionsJsonString,
                        start_inputed_at: this.focusSearchTime,
                        start_inputed_text: this.focusSearchText,
                        location: null != (s = this.location) ? s : ""
                    }),
                    $.observable(this).setProperty({
                        searchQueryText: this.searchText
                    });
                    let o = this._makeSafeString(this.searchText);
                    const i = `${wb.urlHelper.xSearchBase}?search=${o}`;
                    if (null != wb.spa)
                        return wb.spa.redirect(i);
                    window.location.href = i
                }
                _makeSafeString(e) {
                    return e.toSafeString()
                }
                async _getUrlToFollow(e) {
                    if (e.url)
                        return Promise.resolve(e.url);
                    if (2 === e.type) {
                        const t = await $.views.helpers.brandUrlById(e.brandId);
                        if (t)
                            return t
                    }
                    return Promise.resolve(`${wb.urlHelper.xSearchBase}?search=${this._makeSafeString(e.search)}`)
                }
                markSelected(e, t) {
                    let r = e.trim();
                    if (t) {
                        const e = t.trim().replace(wb.settings.regexp.escapingRegExp, "\\$&")
                          , s = $.views.converters.encode(r.replace(new RegExp(e,"i"), "")).replace(wb.settings.regexp.escapingRegExp, "\\$&");
                        return r = $.views.converters.encode(r.replace(new RegExp(`(${s})$`,"i"), "[b]$&[/b]")),
                        r.replace(new RegExp("\\[b\\](" + $.views.converters.encode(s) + ")\\[\\/b\\]","gi"), "<b>$1</b>")
                    }
                    return $.views.converters.encode(r)
                }
                _removeRepeats(e) {
                    const {history: t, common: r} = e.reduce(( (e, t) => {
                        switch (t.type) {
                        case 0:
                            e.history = t;
                            break;
                        case 1:
                            e.common = t
                        }
                        return e
                    }
                    ), {
                        history: null,
                        common: null
                    });
                    if (!t || !r)
                        return;
                    const s = t.suggestions.reduce(( (e, t) => (e.add(t.name),
                    e)), new Set);
                    r.suggestions = r.suggestions.filter((e => !s.has(e.name)))
                }
                _sortSuggests(e) {
                    e.sort(( (e, t) => p[e.type] - p[t.type]))
                }
                _getAnalyticsFromSuggest(e) {
                    switch (e.type) {
                    case 0:
                        return {
                            location: "SNH",
                            type: "Hist"
                        };
                    case 1:
                        return {
                            location: "SNS",
                            type: "Suggest"
                        };
                    case 2:
                        return {
                            location: "STB",
                            type: "Brand"
                        };
                    case 3:
                        return {
                            location: "STC",
                            type: "Category"
                        };
                    case 4:
                        return {
                            location: "SIS",
                            type: "Item"
                        };
                    case 7:
                        return {
                            location: "STS",
                            type: "Supplier"
                        };
                    default:
                        return {
                            location: "",
                            type: "Unknown"
                        }
                    }
                }
            }
            class m extends h {
                constructor(e) {
                    super(),
                    this.suggestionsHelper = e.suggestionsHelper,
                    this.searchText = e.searchText,
                    this.parentBlock = e
                }
                onAfterShown() {
                    this.inputEl = document.getElementById("mobileSearchInput"),
                    this.inputElFullPage = document.getElementById("searchInput"),
                    this.inputEl.focus()
                }
            }
            var g = class extends h {
                constructor() {
                    super(),
                    this.imageChipData = null,
                    this._hideSuggestionsTimer = null,
                    this.inputEl = document.getElementById("searchInput"),
                    this.applySearchEl = document.getElementById("applySearchBtn"),
                    this.searchByImageBtnEl = document.getElementById("searchByImageBtn"),
                    this.searchByImageContainerEl = document.getElementById("searchByImageContainer"),
                    this.searchInputMobileEl = document.querySelector(".j-search-input-mobile"),
                    this._checkImageFormClick = this._checkImageFormClick.bind(this),
                    this.hasAnySuggestions.depends = ["suggestions"]
                }
                async init() {
                    await this._prepareSuggestionsHelper(),
                    this._observeProperties(),
                    this._bindEvents(),
                    $.link(!0, "#searchBlock", this)
                }
                hasAnySuggestions() {
                    return this.suggestions.some((e => e.suggestions.length > 0))
                }
                toggleImageSearch() {
                    this.toggleProperty("showImageSearch")
                }
                markSuggest(e) {
                    const {data: t} = $.view(e.currentTarget);
                    null != t && this._markSuggestAsSelected(t)
                }
                unmarkSuggests() {
                    this.allSuggestions.forEach((e => {
                        $.observable(e).setProperty({
                            selected: !1
                        })
                    }
                    ))
                }
                _markSuggestAsSelected(e) {
                    this.allSuggestions.forEach((t => {
                        $.observable(t).setProperty({
                            selected: t == e
                        })
                    }
                    ))
                }
                _observeProperties() {
                    $.observe(this, "showImageSearch", ( (e, {value: t}) => {
                        t ? this._addImageSearchHandlers() : this._removeImageSearchHandlers()
                    }
                    ))
                }
                _bindEvents() {
                    window.addEventListener("spaTransition", (e => {
                        var t;
                        "SpaSearchEntrypoint" !== (null == (t = e.detail.dest) ? void 0 : t.name) && ($.observable(this).setProperty({
                            searchText: ""
                        }),
                        $.observable(this).setProperty({
                            searchQueryText: ""
                        }))
                    }
                    )),
                    this.inputEl.addEventListener("focus", ( () => {
                        this.$isDesktop || this._showMobileSearchPopup()
                    }
                    )),
                    this.$eventBus.addEventListener("NeedSearchUpdate", (e => {
                        const {searchText: t} = e.detail;
                        $.observable(this).setProperty({
                            searchText: t
                        }),
                        $.observable(this).setProperty({
                            searchQueryText: t
                        })
                    }
                    )),
                    this.$eventBus.addEventListener("RenderImageChip", (e => {
                        const {imageChipData: t} = e.detail;
                        $.observable(this).setProperty({
                            imageChipData: t
                        })
                    }
                    )),
                    this._bindDisplayEvents()
                }
                _bindDisplayEvents() {
                    var e;
                    const t = this
                      , r = this._showMobileSearchPopup.bind(this);
                    function s() {
                        var e, s;
                        "m" == wb.settings.displayMode ? null == (e = t.searchInputMobileEl) || e.addEventListener("click", r) : null == (s = t.searchInputMobileEl) || s.removeEventListener("click", r)
                    }
                    s(),
                    null == (e = wb.displayModeSettings) || e.addObserver(( () => {
                        s()
                    }
                    ))
                }
                _addImageSearchHandlers() {
                    document.documentElement.addEventListener("click", this._checkImageFormClick)
                }
                _removeImageSearchHandlers() {
                    document.documentElement.removeEventListener("click", this._checkImageFormClick)
                }
                _checkImageFormClick(e) {
                    e.target == this.searchByImageBtnEl || this.searchByImageContainerEl.contains(e.target) || $.observable(this).setProperty({
                        showImageSearch: !1
                    })
                }
                async _showMobileSearchPopup() {
                    await $.views.loadTemplateDictionaryAsync("searchSuggestionsTmpl");
                    const e = wb.popup.showCustomPopup({
                        showCross: !1,
                        useCenteredFunction: !0,
                        useHtml: !0,
                        lockScroll: !0,
                        popupClassesList: ["popup-search", "shown"],
                        contentClasses: ["popup__content", "popup-search__content"],
                        onShow: async (t, r) => {
                            const s = new m(this);
                            s.searchByImage = t => {
                                this.searchByImage(t),
                                e.close()
                            }
                            ,
                            $.templates.searchMobilePopupTmpl.link(t.querySelector(".popup__content"), s, {
                                close: () => e.close()
                            }),
                            await r,
                            s.onAfterShown()
                        }
                    })
                }
                async _prepareSuggestionsHelper() {
                    const e = await this.$moduleLoader.loadModuleAsync("suggestionsHelper");
                    let t = [[{
                        cacheKey: "historySearch",
                        historiesLimit: 20
                    }, e.suggestionsTypes.history]];
                    t.push([s, e.suggestionsTypes.grouped]),
                    this.suggestionsHelper = e.createSuggestionsHelper(t)
                }
            }
            ;
            var y = class {
                constructor(e) {
                    var t;
                    this.layoutModel = e,
                    this.container = document.getElementById("balanceBlock"),
                    this.updateBalance = this.updateBalance.bind(this),
                    this.model = {
                        balance: 0
                    },
                    this._setWalletInfo(null == (t = e.$user.balance) ? void 0 : t.walletTypeCode)
                }
                async init(e) {
                    e && await this._fetchBalanceAndLink().catch((e => Promise.resolve())),
                    this.layoutModel.$eventBus.addEventListener("BalanceReset", this._fetchBalanceAndLink.bind(this)),
                    this.layoutModel.$eventBus.addEventListener("CurrencyChanged", this._fetchBalanceAndLink.bind(this)),
                    this.layoutModel.$eventBus.addEventListener("BalanceUpdated", this.updateBalance.bind(this))
                }
                async _fetchBalanceAndLink() {
                    if (!this.layoutModel.$auth.isAuth)
                        return;
                    let e = await this.layoutModel.$user.getBalance();
                    this._link(e.totalBalance || 0, (null == e ? void 0 : e.balanceCurrency) || "RUB")
                }
                _link(e, t) {
                    void 0 !== e && null != e && this.layoutModel.$auth.isAuth && !this._isLinked && (this._isLinked = !0,
                    this.model.balance = e,
                    this.model.balanceCurrency = t,
                    $.link(!0, this.container, this.model),
                    $.observable(this.layoutModel.$userEnv).setProperty({
                        balance: e,
                        balanceCurrency: t
                    }))
                }
                updateBalance(e) {
                    const {totalBalance: t, balanceCurrency: r, walletTypeCode: s} = e.detail;
                    this._isLinked ? ($.observable(this.model).setProperty({
                        balance: t,
                        balanceCurrency: r
                    }),
                    $.observable(this.layoutModel.$userEnv).setProperty({
                        balance: t,
                        balanceCurrency: r
                    })) : this._link(t),
                    this._setWalletInfo(s)
                }
                _setWalletInfo(e) {
                    $.observable(wb.settings).setProperty({
                        balanceTitle: this._getBalanceTitle(e),
                        walletTypeCode: e
                    })
                }
                _getBalanceTitle(e=0) {
                    return e > 0 ? "WB Кошелёк" : "Баланс"
                }
            }
            ;
            var b = class {
                constructor(e) {
                    this.mainLayout = e;
                    const t = document.querySelector(".j-b-header-country")
                      , r = t.querySelector(".j-b-change-currency");
                    this.tooltip = document.querySelector(".j-tooltip-country"),
                    $.observable(e.$userEnv).setProperty({
                        currency: e.$user.getCurrency()
                    }),
                    this.currentCurrency = e.$user.getCurrency(),
                    this.changeCurrency = this.changeCurrency.bind(this),
                    $.templates({
                        changeCurrencyTmpl: '\n               <h2 class="popup__header">Выберите валюту</h2>\n                <div class="country">\n                    <div class="country__wrap" data-link="{on \'click\' \'.j-currency-item\' changeCurrency}">\n                    {^{radiogroup currentCurrency}}\n                        {^{props ~wbCurrencies sort=sort ^~current=currentCurrency}}\n                            <label class="radio-with-text{{if key == ~current}} radio-with-text--current{{/if}}">\n                                <input class="j-currency-item" type="radio" name="currency" value=\'{{:key}}\' ">\n                                <span class="radio-with-text__text radio-with-text__text--flag">\n                                    <span class="radio-with-text__language"><span class="radio-with-text__flag flag-{{:prop.locale}}"></span>{{:key}}</span>\n                                    <span class="radio-with-text__name">{{:prop.name}}</span>\n                                </span>\n                            </label>\n                        {{/props}}\n                    {{/radiogroup}}\n                    </div>\n                </div>\n        '
                    }),
                    $.templates.changeCurrencyTmpl.link(r, this),
                    $.link(!0, t, this),
                    $.link(!0, document.querySelector(".nav-element__currency"), this),
                    document.addEventListener("click", e.$helper.delegator(".j-currency-show-popup", ( (e, t) => this.showPopup())))
                }
                showPopup() {
                    this.currentPopup = wb.popup.showCustomPopup({
                        useHtml: !0,
                        popupClassesList: ["popup-country", "j-popup-country", "shown"],
                        contentClasses: ["popup__content"],
                        useCenteredFunction: !0,
                        modal: !0,
                        closeClass: ["j-close", "popup__close"],
                        closeSelector: ".j-close",
                        onShow: e => $.templates.changeCurrencyTmpl.link(e.querySelector(".popup__content"), this)
                    })
                }
                sort(e, t) {
                    return e.key === this.view.data.currentCurrency ? -1 : t.key === this.view.data.currentCurrency ? 1 : 0
                }
                changeCurrency(e) {
                    const t = e.target.value;
                    this.mainLayout.$user.setCurrency(t).then(( () => {
                        var e;
                        $.observable(this.mainLayout.$userEnv).setProperty({
                            currency: t
                        }),
                        this.mainLayout.$eventBus.dispatchEvent(new CustomEvent("CurrencyChanged",{
                            detail: {
                                currency: t
                            }
                        })),
                        null == (e = this.currentPopup) || e.close()
                    }
                    )),
                    this.tooltip || (this.tooltip = document.querySelector(".j-tooltip-country")),
                    this._closeTooltip()
                }
                refresh(e) {
                    wb.currencies.info[e] && $.observable(this).setProperty("currentCurrency", e)
                }
                _closeTooltip() {
                    if (this.tooltip)
                        return this.tooltip.style.pointerEvents = "none",
                        setTimeout(( () => this.tooltip.style.pointerEvents = "auto"), 100)
                }
            }
            ;
            var f = class {
                constructor(e) {
                    this.layoutModel = e.layoutModel,
                    this.shortBasketInfo = new n(e),
                    this.search = new g,
                    this.chatStartedRefunds = new this.layoutModel.$helper.Deferred
                }
                _initOnlineChat(e) {
                    setTimeout(( () => {
                        this.layoutModel.$moduleLoader.loadModuleAsync("onlineChatPopup").then((t => {
                            var r, s;
                            this.onlineChat = new t({
                                auth: e.isAuth,
                                uid: e.isAuth ? e.uid : e.basketUid,
                                startedRefunds: this.chatStartedRefunds
                            }).init(),
                            wb.displayModeSettings.removeObserver(this.onlineChat.onBreakpoint),
                            (null == (s = null == (r = wb.global.settings) ? void 0 : r.switches) ? void 0 : s.enableOnlineChat) ? (wb.displayModeSettings.addObserver(this.onlineChat.onBreakpoint, !0),
                            this.layoutModel.$eventBus.dispatchEvent(new CustomEvent("OnlineChatInited"))) : wb.global.subscribe(( () => {
                                !this.onlineChat.inited && wb.global.settings.switches.enableOnlineChat && (wb.displayModeSettings.addObserver(this.onlineChat.onBreakpoint, !0),
                                this.layoutModel.$eventBus.dispatchEvent(new CustomEvent("OnlineChatInited")))
                            }
                            )),
                            wb.global.subscribe((e => {
                                const t = e.switches.enableSellersChat;
                                this.layoutModel.$eventBus.dispatchEvent(new CustomEvent("SellersChatSwitched",{
                                    detail: t
                                }))
                            }
                            ))
                        }
                        ))
                    }
                    ), 5e3)
                }
                async init() {
                    this.userBalance = new y(this.layoutModel),
                    this.changeCurrency = new b(this.layoutModel),
                    this.shortBasketInfo.init();
                    const e = WbSpaModel.prototype.$geoLocation.initPreferredLocation()
                      , t = this.search.init();
                    this.bindSignOut(),
                    this.bindStat();
                    const r = this.layoutModel.$user.getUserInfo();
                    return this._initOnlineChat(r),
                    this.userBalance.init(r.isAuth),
                    Promise.all([e, t])
                }
                bindSignOut() {
                    document.addEventListener("click", (e => {
                        const t = e.target.closest("a");
                        null != t && t.href.endsWith("/security/exit") && (e.preventDefault(),
                        this.signOut())
                    }
                    ))
                }
                signOut(e) {
                    this.layoutModel.$eventBus.dispatchEvent(new CustomEvent("onBeforeSignOut")),
                    this.layoutModel.$user.clearLocalUserData(),
                    this.layoutModel.$auth.signOut(e)
                }
                bindStat() {
                    const e = this.layoutModel.$analitic;
                    const t = document.querySelector(".j-header");
                    null == t || t.addEventListener("click", this.layoutModel.$helper.delegator(".j-wba-header-item", (function(t) {
                        const r = t.target.closest(".j-wba-header-item");
                        r && e.sendEvent("Header_T", {
                            name: r.dataset.wbaHeaderName
                        })
                    }
                    )));
                    const r = document.querySelector(".j-country");
                    null == r || r.addEventListener("click", this.layoutModel.$helper.delegator(".j-country-item input", (function(t) {
                        const r = t.target.closest(".j-country-item input");
                        r && e.sendEvent("Header_Country_Apl", {
                            name: r.value
                        })
                    }
                    )))
                }
            }
              , v = Object.defineProperty
              , w = (e, t, r) => ( (e, t, r) => t in e ? v(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
            class S extends WbSpaModel {
                constructor() {
                    super(),
                    w(this, "bannersLoaded", !1),
                    w(this, "footerBanners", []),
                    w(this, "showFooterObserver", null),
                    w(this, "userLocale", null),
                    w(this, "banners", {
                        mobileBanners: [],
                        desktopBanners: []
                    }),
                    this._onChangeDisplayMode = this._onChangeDisplayMode.bind(this),
                    this._loadBanners = this._loadBanners.bind(this),
                    this.$eventBus.addEventListener("GeoUpdated", ( () => {
                        "ru" !== wb.settings.currentLocale && this.$observable.setProperty({
                            userLocale: this.$user.getLocale()
                        }),
                        this._loadBanners(!0)
                    }
                    ))
                }
                async init() {
                    await this.$helper.loadJsAsync(wb.settings.scripts.bannersTag),
                    this.userLocale = "ru" !== wb.settings.currentLocale && this.$user.getLocale() || "ru";
                    const e = document.querySelector(".j-footer");
                    $.link(!0, e, this),
                    this.showFooterObserver = WbSpaModel.prototype.$observerHelper.getVerticalObserver(e),
                    e.addEventListener(this.showFooterObserver.elementInViewportEventName, ( () => {
                        this._loadBanners(),
                        WbSpaModel.prototype.$analitic.sendEvent("Footer_S")
                    }
                    )),
                    this.showFooterObserver.observe()
                }
                onMenuSelected(e) {
                    if ("m" !== wb.settings.displayMode)
                        return;
                    e.currentTarget.parentNode.classList.toggle("dropdown-open")
                }
                sendStatEvent(e) {
                    const t = e.currentTarget;
                    t && WbSpaModel.prototype.$analitic.sendEvent("Footer_T", {
                        name: t.dataset.wbaFooterName
                    })
                }
                _onChangeDisplayMode() {
                    this._setBanners()
                }
                _setBanners() {
                    if (!this.banners)
                        return;
                    const e = "phone" == wb.settings.displayType;
                    $.observable(this).setProperty({
                        footerBanners: e ? this.banners.mobileBanners : this.banners.desktopBanners
                    })
                }
                async _loadBanners(e) {
                    if (this.bannersLoaded && !e)
                        return;
                    this.bannersLoaded = !0;
                    const [t] = await Promise.all([this.$services.bannersService.getBannersForFooterAsync(), this.$helper.loadJsAsync(wb.settings.scripts.swiper)]);
                    this.banners = t,
                    this._onChangeDisplayMode(),
                    !e && $.observe(wb.settings, "displayType", this._onChangeDisplayMode)
                }
            }
            var _ = S;
            const C = Object.freeze({
                UNKNOWN: "unknown",
                HOME: "home",
                CATALOG: "catalog",
                PRODUCTCARD: "product-card",
                SECURITY: "security",
                BASKET: "basket",
                PONED: "poned",
                PROFILE: "profile",
                ARCHIVE: "archive",
                ORDERS: "orders",
                SERVICES: "services",
                CLAIMS: "claims",
                COMMUNICATIONS: "communications",
                SUBSCRIPTION: "subscription"
            });
            var I = class {
                static get types() {
                    return C
                }
                static getType() {
                    const e = location.pathname.toLowerCase();
                    return "/" == e ? C.HOME : /\/catalog\/\d+\/detail\.aspx/.test(e) ? C.PRODUCTCARD : e.startsWith("/catalog") ? C.CATALOG : e.startsWith("/subscription") ? C.SUBSCRIPTION : e.startsWith("/security") ? C.SECURITY : e.startsWith("/lk/basket") ? C.BASKET : e.startsWith("/lk/favorites") ? C.PONED : e.startsWith("/lk/myorders/archive") ? C.ARCHIVE : e.startsWith("/lk/myorders/delivery") ? C.ORDERS : e.startsWith("/lk/claims") || e.startsWith("/lk/refund") ? C.CLAIMS : e.startsWith("/lk/communications") ? C.COMMUNICATIONS : e.startsWith("/lk") ? C.PROFILE : e.startsWith("/services/") || e.startsWith("/promo/") || e.startsWith("/presservice") ? C.SERVICES : C.UNKNOWN
                }
            }
            ;
            class M extends WbSpaModel {
                constructor() {
                    var e, t;
                    super(),
                    this.navbarContainer = document.querySelector(".j-navbar-mobile"),
                    this.navbarMenuLink = null == (e = this.navbarContainer) ? void 0 : e.querySelector("#catalogNavbarLink"),
                    this.currentType = I.getType(),
                    this.menuModel = {
                        type: this.currentType,
                        catalogState: !1,
                        router: this.$router,
                        isPremium: !!this.$auth.isAuth && (null == (t = this.$user.getUserGradeFromCache()) ? void 0 : t.isPremium)
                    },
                    this.catalogState = !1
                }
                get menuLink() {
                    return this.navbarMenuLink
                }
                get types() {
                    return I.types
                }
                init() {
                    this._bindEvents(),
                    $.link(!0, this.navbarContainer, this.menuModel, {
                        sendAnalytics: e => {
                            const t = e.target.closest(".navbar-mobile__link");
                            t && this.$analitic.sendEvent("Header_T", {
                                name: t.dataset.wbaHeaderName
                            })
                        }
                        ,
                        showPopupLoginMobile: e => {
                            !1 === this.$auth.isAuth && (e.preventDefault(),
                            wb.popup.showCustomPopup({
                                useHtml: !0,
                                popupClassesList: ["popup-login-mobile", "shown"],
                                contentClasses: ["popup__content"],
                                useCenteredFunction: !0,
                                onShow: e => {
                                    $.views.templates.popupLoginMobile.link(e.querySelector(".popup__content"), this)
                                }
                            }))
                        }
                    })
                }
                setType(e) {
                    this.catalogState = e == this.types.CATALOG,
                    this.catalogState ? e = null : this.currentType = e,
                    $.observable(this.menuModel).setProperty({
                        catalogState: this.catalogState,
                        type: e
                    })
                }
                setCatalog() {
                    this.setType("catalog")
                }
                isCatalog() {
                    return this.catalogState
                }
                isNavbarLink(e) {
                    return !!e.closest(".navbar-mobile__link")
                }
                revertActive() {
                    this.setType(this.currentType)
                }
                updatePremiumState() {
                    var e;
                    $.observable(this.menuModel).setProperty({
                        isPremium: null == (e = this.$user.getUserGradeFromCache()) ? void 0 : e.isPremium
                    })
                }
                updateBasket(e) {
                    $.observable(this.menuModel).setProperty({
                        basketCount: e
                    })
                }
                updateEvents(e) {
                    $.observable(this.menuModel).setProperty({
                        eventsModel: e
                    })
                }
                _bindEvents() {
                    window.addEventListener("spaTransition", (e => {
                        e.detail.isFinished || (this.currentType = I.getType(),
                        this.$eventBus.dispatchEvent(new CustomEvent("MobileMenuTypeChange",{
                            detail: {
                                currentType: this.currentType
                            }
                        })))
                    }
                    )),
                    this.$eventBus.addEventListener("OnlineChatInited", (e => {
                        this.$eventBus.dispatchEvent(new CustomEvent("MobileMenuTypeChange",{
                            detail: {
                                currentType: this.currentType,
                                isInit: !0
                            }
                        }))
                    }
                    )),
                    this.$eventBus.addEventListener("MobileMenuTypeChange", (e => {
                        const {currentType: t} = e.detail;
                        let r = "";
                        switch (t) {
                        case I.types.HOME:
                        case I.types.BASKET:
                        case I.types.PONED:
                        case I.types.ARCHIVE:
                        case I.types.ORDERS:
                        case I.types.PROFILE:
                        case I.types.SUBSCRIPTION:
                            r = t;
                            break;
                        case I.types.SECURITY:
                            r = I.types.PROFILE
                        }
                        this.setType(r)
                    }
                    )),
                    this.$eventBus.addEventListener("UserGradeUpdated", this.updatePremiumState.bind(this))
                }
            }
            var k = M;
            var P = class {
                constructor(e) {
                    this.delay = e.delay,
                    this.menuContainer = e.menuContainer,
                    this.timerId = null,
                    this.updateFirstLvlMenuTask = null,
                    this.success = !1,
                    this.menuItemsUpdated = null,
                    this.getFullEcomInfo = e.getFullEcomInfo
                }
                lazyUpdateMenu() {
                    this.timerId = setTimeout(this._setUpdateFirstLvlMenuTask.bind(this), this.delay)
                }
                async forceUpdateMenu() {
                    this._setUpdateFirstLvlMenuTask();
                    try {
                        const e = await this.updateFirstLvlMenuTask;
                        return Promise.resolve(e)
                    } catch (e) {
                        return Promise.reject(null)
                    }
                }
                reloadMenu() {
                    this.updateFirstLvlMenuTask = null,
                    this.forceUpdateMenu()
                }
                _stopUpdatingMenu() {
                    this.timerId && clearTimeout(this.timerId)
                }
                _setUpdateFirstLvlMenuTask() {
                    this.updateFirstLvlMenuTask && this.success || (this.updateFirstLvlMenuTask = this._updateFirstLvlMenu()),
                    this._stopUpdatingMenu()
                }
                async _updateFirstLvlMenu() {
                    const [e] = await Promise.all([wb.spa.getCatalogMenu(), $.views.loadTemplateDictionaryAsync("menuTopTmpl")])
                      , t = e.fullMenu;
                    return this.menuItemsUpdated = await this._addMenuItemsFirstLvl(t, this.menuContainer),
                    this.menuContainer.addEventListener("click", (e => {
                        e.target.closest('a[href="/subscription"]') && this.setEntryPointWBClub()
                    }
                    )),
                    this.success = !0,
                    Promise.resolve(e)
                }
                setEntryPointWBClub() {
                    window.localStorage.setItem("entryPointWBClub", "Catalog")
                }
                async _addMenuItemsFirstLvl(e, t) {
                    var r;
                    const s = t.querySelector(".menu-burger__main-list");
                    let n = s.querySelectorAll(".j-menu-main-item")
                      , a = null
                      , o = !0
                      , i = 0;
                    for (let t = 0; t < e.length; t++) {
                        const l = e[t];
                        if (o && (a = null == n ? void 0 : n[i]),
                        l.id == (null == (r = null == a ? void 0 : a.dataset) ? void 0 : r.menuId)) {
                            o = !0,
                            i++;
                            continue
                        }
                        o = !1;
                        const c = $.templates.menuFirstLvlTmpl.render(l);
                        a ? a.insertAdjacentHTML("beforebegin", c) : s.insertAdjacentHTML("beforeend", c)
                    }
                    if (n = t.querySelectorAll(".j-menu-main-item"),
                    e.length < n.length)
                        for (let t = e.length; t < n.length; t++)
                            n[t].remove();
                    return Promise.resolve(n)
                }
            }
            ;
            class T extends WbSpaModel {
                constructor(e) {
                    super(),
                    this.mobileMenu = new k,
                    this.layoutModel = e.layoutModel,
                    this.menuBtn = document.querySelector(".j-menu-burger-btn"),
                    this.menuContainer = document.querySelector(".j-menu-burger"),
                    this.mainMenuContainer = this.menuContainer.querySelector(".j-menu-burger-main"),
                    this.header = document.querySelector(".j-header"),
                    this.widthScrollbar = Math.abs(window.innerWidth - document.documentElement.clientWidth),
                    this.bodyOverflowClass = "body--overflow",
                    this.menuContainerActiveClass = "menu-burger--active",
                    this.innerMenuContainerActiveClass = "menu-burger__drop--active",
                    this.innerMenuItemActiveClass = "menu-burger__drop-list-item--active",
                    this.menuActiveClass = "j-menu-active",
                    this.mainMenuItemActiveClass = "menu-burger__main-list-item--active",
                    this.headerFixedClass = "header--fixed",
                    this.headerFixedAnimateClass = "header--fixed-animate",
                    this.menuItemActiveClass = "menu-burger__drop-list-item--active",
                    this.menuBtnCloseClass = "nav-element__burger--close",
                    this.menuOverlay = this._getMenuOverlay(document.body.querySelector(".j-menu-burger")),
                    this._menuOpenHandler = this._menuOpenHandler.bind(this),
                    this._menuCloseHandler = this._menuCloseHandler.bind(this),
                    this.firstLvlMenuUpdater = new P({
                        menuContainer: this.menuContainer,
                        delay: 12e3
                    }),
                    this.firstLvlMenuUpdater.lazyUpdateMenu()
                }
                get headerFixedScrollTop() {
                    return this.$isDesktop ? 24 : 400
                }
                get mainMenuItems() {
                    var e;
                    return (null == (e = this.firstLvlMenuUpdater) ? void 0 : e.menuItemsUpdated) ? this.firstLvlMenuUpdater.menuItemsUpdated : this.menuContainer.querySelectorAll(".menu-burger__main-list-item")
                }
                isMenuOpened() {
                    return this.menuContainer.classList.contains(this.menuContainerActiveClass)
                }
                init() {
                    this.mobileMenu.init(),
                    this._bindEvents(),
                    this._initMobileSearchbar(!this.$isDesktop)
                }
                _initMobileSearchbar(e) {
                    const t = this.mobileMenu.types;
                    let r = 0
                      , s = !1
                      , n = "";
                    function a() {
                        s || (window.requestAnimationFrame(i.bind(this)),
                        s = !0)
                    }
                    a = a.bind(this);
                    const o = (e, t) => {
                        e ? (this.header.classList.add(this.headerFixedClass),
                        window.requestAnimationFrame(( () => this.header.classList.add(this.headerFixedAnimateClass)))) : (t && this.header.classList.remove(this.headerFixedClass),
                        window.requestAnimationFrame(( () => this.header.classList.remove(this.headerFixedAnimateClass))))
                    }
                    ;
                    function i() {
                        const e = window.scrollY;
                        if (Math.abs(e - r) < 0)
                            return void (s = !1);
                        if (e <= this.headerFixedScrollTop)
                            return o(!1, !0),
                            void (s = !1);
                        const t = e > r;
                        t && "down" != n ? (this.$isDesktop ? o(!0) : o(!1),
                        n = "down") : t || "up" == n || (o(!0),
                        n = "up"),
                        r = e > 0 ? e : 0,
                        s = !1
                    }
                    const l = e => {
                        const {currentType: r} = e.detail;
                        r == t.PRODUCTCARD ? this.header.classList.add("hide-mobile") : this.header.classList.remove("hide-mobile"),
                        r == t.HOME || r == t.SERVICES ? window.addEventListener("scroll", a) : (this.header.classList.remove(this.headerFixedClass, this.headerFixedAnimateClass),
                        window.removeEventListener("scroll", a))
                    }
                    ;
                    this.$eventBus.addEventListener("MobileMenuTypeChange", l);
                    l({
                        detail: {
                            currentType: I.getType()
                        }
                    })
                }
                async _renderInnerMenu() {
                    var e, t;
                    const [r,s] = await Promise.all([this.layoutModel.$moduleLoader.loadModuleAsync("sideMenu"), this.firstLvlMenuUpdater.forceUpdateMenu()])
                      , n = this.layoutModel.$services.bannersService.getMenuBanners()
                      , a = new r(this.menuContainer,s,n);
                    return a.checkMenuItemForHide(a.menuItems, null == (t = null == (e = this.$geoLocation) ? void 0 : e.location) ? void 0 : t.destinations),
                    a.relinkModel(),
                    a.onSearchImage = () => this._onMenuHide(),
                    a
                }
                _bindEvents() {
                    var e, t, r;
                    this.menuBtn.addEventListener("mousedown", this._menuOpenHandler),
                    null == (t = null == (e = this.mobileMenu) ? void 0 : e.menuLink) || t.addEventListener("mousedown", this._menuOpenHandler),
                    null == (r = wb.displayModeSettings) || r.addObserver(( () => {
                        this._onMenuHide(),
                        this._initMobileSearchbar(!this.$isDesktop)
                    }
                    )),
                    window.addEventListener("spaTransition", (e => {
                        e.detail.isFinished && this._onMenuHide()
                    }
                    )),
                    this.$eventBus.addEventListener("HideSideMenu", ( () => {
                        this.isMenuOpened() && (document.body.classList.remove(this.bodyOverflowClass),
                        document.body.style.paddingRight = "")
                    }
                    )),
                    this.$eventBus.addEventListener("SelectedSideMenuItemUpdated", (e => {
                        const {menuId: t} = e.detail;
                        this.mainMenuItems.forEach((e => e.classList.toggle(this.mainMenuItemActiveClass, e.dataset.menuId == t)))
                    }
                    )),
                    this.$eventBus.addEventListener("B2BModeToggled", ( () => {
                        this.header.classList.toggle("is-b2b-mode", wb.settings.b2bMode)
                    }
                    ))
                }
                _bindMenuCloseHandlers() {
                    document.addEventListener("mousedown", this._menuCloseHandler)
                }
                _unbindMenuCloseHandlers() {
                    document.removeEventListener("mousedown", this._menuCloseHandler)
                }
                _menuOpenHandler(e) {
                    if (this.isMenuOpened() || !this.$isDesktop && this.mobileMenu.isCatalog())
                        return;
                    e.stopPropagation(),
                    e.preventDefault();
                    const t = e.currentTarget;
                    let r = "touchstart" === e.type ? "touchend" : "mouseup";
                    const s = () => {
                        t.removeEventListener(r, s),
                        this.layoutModel.$helper.loadCssAsync(wb.settings.styles.menuBurger).then(( () => this._onMenuShow()))
                    }
                    ;
                    t.addEventListener(r, s),
                    this.visibleCertItemMenu && wb.analitics.sendEvent("Certificate_S", {
                        location: "Catalog"
                    })
                }
                _menuCloseHandler(e) {
                    var t;
                    const r = e.target
                      , s = this;
                    if (!(this.$isDesktop && r.closest(`.${this.menuActiveClass}`) || !this.$isDesktop && !this.mobileMenu.isNavbarLink(r) && !this.menuBtn.contains(r)))
                        if (this.$isDesktop) {
                            let t = function() {
                                r.removeEventListener(s, t),
                                n()
                            };
                            const r = e.currentTarget
                              , s = "touchstart" === e.type ? "touchend" : "mouseup";
                            r.addEventListener(s, t)
                        } else
                            null == (t = this.sideMenu) || t.touchHandlerHelper(e, n);
                    function n() {
                        s._onMenuHide()
                    }
                }
                refreshMenu(e) {
                    e && (wb.spa.clearCatalogMenu(),
                    this.firstLvlMenuUpdater.reloadMenu()),
                    this.isSubMenuShowerActivated = !1,
                    this.menuRendered = !1,
                    !this.$isDesktop && this.isMenuOpened() && this._onMenuShow()
                }
                async _onMenuShow() {
                    var e;
                    if (document.body.classList.add(this.bodyOverflowClass),
                    document.body.style.paddingRight = `${this.widthScrollbar}px`,
                    "d" === wb.settings.displayMode && scrollY <= this.header.offsetHeight && document.documentElement.style.setProperty("--scroll-top", window.scrollY + "px"),
                    this.menuContainer.classList.add(this.menuContainerActiveClass),
                    this.mainMenuContainer.classList.add(this.menuActiveClass),
                    this.menuBtn.classList.add(this.menuBtnCloseClass),
                    this.menuOverlay.show(),
                    !this.$isDesktop && this.mobileMenu.setCatalog(),
                    this._bindMenuCloseHandlers(),
                    this.menuRendered)
                        null == (e = this.sideMenu) || e.clearShownBanners();
                    else {
                        const e = await this._renderInnerMenu();
                        this.sideMenu = e,
                        this.mainMenuItems.forEach((e => {
                            var t, r, s;
                            if (!this.$isDesktop && ("2192" === e.dataset.id || "4853" === e.dataset.id))
                                return;
                            const n = this.sideMenu.findItem(e.dataset.menuId);
                            n && (((null == (t = n.childs) ? void 0 : t.length) > 0 || (null == (r = n.banners) ? void 0 : r.length) > 0) && e.classList.add("menu-burger__main-list-item--subcategory"),
                            e.classList.toggle("hide", null != (s = n.hide) && s),
                            1234 === n.id && (this.visibleCertItemMenu = !0,
                            wb.analitics.sendEvent("Certificate_S", {
                                location: "Catalog"
                            })))
                        }
                        )),
                        this.menuRendered = !0
                    }
                    this._menuMainHoverHandler()
                }
                _onMenuHide() {
                    var e, t;
                    null == (e = this.sideMenu) || e.changeSelectedMenuItem(null),
                    null == (t = this.sideMenu) || t.innerMenuHide(),
                    document.body.classList.remove(this.bodyOverflowClass),
                    document.body.style.paddingRight = "",
                    this.menuContainer.classList.remove(this.menuContainerActiveClass),
                    this.mainMenuContainer.classList.remove(this.menuActiveClass),
                    this.menuBtn.classList.remove(this.menuBtnCloseClass),
                    this.menuOverlay.hide(),
                    !this.$isDesktop && this.mobileMenu.revertActive(),
                    this._unbindMenuCloseHandlers()
                }
                _menuMainHoverHandler() {
                    !this.isSubMenuShowerActivated && this.$isDesktop && (this.layoutModel.$moduleLoader.loadModuleAsync("subMenuShower").then((e => new e(this.mainMenuItems,{
                        over: e => {
                            this.$isDesktop && this.sideMenu.onMenuSelected(e)
                        }
                        ,
                        out: () => {}
                        ,
                        timeout: 30,
                        interval: 40,
                        sensitivity: 4
                    }))),
                    this.isSubMenuShowerActivated = !0)
                }
                _getMenuOverlay(e) {
                    const t = e;
                    let r;
                    function s() {
                        r && r.remove(),
                        r = null
                    }
                    return {
                        show: function() {
                            "m" != wb.settings.displayMode ? r || (t.insertAdjacentHTML("beforebegin", '<div class="overlay overlay--menu-burger j-overlay"></div>'),
                            r = e.parentElement.querySelector(".j-overlay")) : s()
                        },
                        hide: s
                    }
                }
            }
            var A = T
              , D = Object.defineProperty
              , E = (e, t, r) => ( (e, t, r) => t in e ? D(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
            const B = "cookie_accepted"
              , O = "_cp";
            var x = class {
                constructor(e) {
                    E(this, "layoutModel"),
                    E(this, "cookiesWrapper"),
                    E(this, "channel"),
                    this.layoutModel = e.layoutModel,
                    this.cookiesWrapper = document.querySelector(".j-fixed-block .fixed-block__cookies"),
                    this.check()
                }
                disable() {
                    wb.cookieHelper.deleteCookie(O),
                    window.location.reload()
                }
                _show() {
                    var e;
                    (null == (e = this.cookiesWrapper) ? void 0 : e.classList.contains("hide")) && ($.link(!0, this.cookiesWrapper, this),
                    this.cookiesWrapper.classList.remove("hide"),
                    this.layoutModel.$analitic.sendEvent("Alert_S", {
                        name: "cookies_alert"
                    }),
                    window.BroadcastChannel && (this.channel = new BroadcastChannel("_cookiePolicy"),
                    this.channel.addEventListener("message", this._hide.bind(this))))
                }
                _hide() {
                    var e, t, r;
                    (null == (e = this.cookiesWrapper) ? void 0 : e.classList.contains("hide")) || (null == (t = this.cookiesWrapper) || t.classList.add("hide"),
                    $.unlink(this.cookiesWrapper),
                    null == (r = this.channel) || r.close(),
                    this.channel = null,
                    this.layoutModel.$eventBus.dispatchEvent(new CustomEvent("CookiePolicyHide")))
                }
                check() {
                    const e = "1" === wb.cookieHelper.getCookie(O) || "true" === localStorage.getItem("wbx__cookieAccepted");
                    return e ? this._hide() : "false" !== sessionStorage.getItem(B) && this._show(),
                    e
                }
                ok() {
                    var e;
                    const t = this.check();
                    t || wb.cookieHelper.setCookie(O, "1", {
                        "max-age": 7776e3
                    }),
                    this.cookiesWrapper && (null == (e = this.channel) || e.postMessage("hide"),
                    this._hide(),
                    t || this.layoutModel.$analitic.sendEvent("Alert_T", {
                        name: "cookies_alert",
                        type: "ok"
                    }))
                }
                no() {
                    sessionStorage.setItem(B, "false"),
                    this._hide(),
                    this.layoutModel.$analitic.sendEvent("Alert_T", {
                        name: "cookies_alert",
                        type: "no"
                    })
                }
                cookies() {
                    this.layoutModel.$analitic.sendEvent("Alert_T", {
                        name: "cookies_alert",
                        type: "cookies"
                    })
                }
            }
            ;
            var L = class {
                constructor(e) {
                    this.$base = e.layoutModel,
                    this.$base.$auth.isAuth ? window.addEventListener("spaTransition", (e => {
                        e.detail.isFinished && this._onAuthLogin()
                    }
                    ), {
                        once: !0
                    }) : this.$base.$eventBus.addEventListener("onUserAuth", this._onAuthLogin.bind(this), {
                        single: !0
                    })
                }
                _loadResources() {
                    return this.$base.$moduleLoader.loadModuleAsync("offer0724").then((e => {
                        this.oferta || (this.oferta = new e)
                    }
                    ))
                }
                _onAuthLogin() {
                    this._loadResources().then((e => {
                        this.oferta.show()
                    }
                    ))
                }
                async confirm() {
                    var e;
                    this.$base.$auth.isAuth && (await this._loadResources(),
                    null == (e = this.oferta) || e.confirm())
                }
                async promise() {
                    var e;
                    if (this.$base.$auth.isAuth)
                        return await this._loadResources(),
                        (null == (e = this.oferta) ? void 0 : e.promise()) || new Promise((e => e()))
                }
            }
              , F = Object.defineProperty
              , W = (e, t, r) => ( (e, t, r) => t in e ? F(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
            class j extends WbSpaModel {
                constructor() {
                    super(),
                    W(this, "initTask", null),
                    W(this, "header", null),
                    W(this, "oferta", null),
                    W(this, "cookiePolicy", null),
                    W(this, "footer", null),
                    W(this, "menuTop", null),
                    this.initTask = new this.$helper.Deferred,
                    this._initWba = this._initWba.bind(this)
                }
                preInit() {
                    const e = {
                        layoutModel: this
                    };
                    "tj" !== wb.settings.currentLocale && delete wb.currencies.info.TJS,
                    this.header = new f(e),
                    this.oferta = new L(e),
                    this.cookiePolicy = new x(e),
                    ["by"].includes(wb.settings.currentLocale) ? this.cookiePolicy.check() ? this._initWba() : (this._initWba(!0),
                    this.$eventBus.addEventListener("CookiePolicyHide", ( () => {
                        var e;
                        (null == (e = this.cookiePolicy) ? void 0 : e.check()) ? this._initWba() : window.wba = function() {}
                    }
                    ), {
                        once: !0
                    })) : this._initWba()
                }
                init() {
                    var e;
                    const t = {
                        layoutModel: this
                    };
                    this.footer = new _,
                    this.menuTop = new A(t),
                    this.menuTop.init();
                    const r = this.footer.init()
                      , s = null == (e = this.header) ? void 0 : e.init();
                    Promise.all([r, s]).then(( () => {
                        var e;
                        return null == (e = this.initTask) ? void 0 : e.resolve(void 0)
                    }
                    ))
                }
                _initWba(e=!1) {
                    var t, r, s, n, a, o;
                    t = window,
                    r = document,
                    s = "script",
                    t[n = "wba"] = t[n] || function() {
                        (t[n].q = t[n].q || []).push(arguments)
                    }
                    ,
                    t[n].l = Date.now(),
                    e || (a = r.createElement(s),
                    o = r.getElementsByTagName(s)[0],
                    a.async = 1,
                    a.src = "https://a.wb.ru/sdk/sdk.js",
                    o.parentNode.insertBefore(a, o)),
                    wba("init", {
                        counterId: 4
                    })
                }
                updateAfterLogin() {
                    var e;
                    this.$user.reset(),
                    null == (e = this.header) || e.shortBasketInfo.update(),
                    this.$geoLocation.updateLocation(),
                    this.$router.clearNotActiveContainer()
                }
            }
            Object.defineProperties(window, {
                MainLayoutSpa: {
                    value: j
                }
            });
            var N = j
        },
        89612: function() {
            "use strict";
            let e = null;
            const t = new class {
                constructor() {
                    this.body = document.body,
                    this.scrollY = 0
                }
                enable() {
                    this.body && (this.scrollY = window.scrollY,
                    this.addStyles())
                }
                disable() {
                    this.body && (this.removeStyles(),
                    window.scrollTo(0, this.scrollY))
                }
                addStyles() {
                    this.body && (this.body.style.position = "fixed",
                    this.body.style.top = -1 * this.scrollY + "px",
                    this.body.style.right = "0px",
                    this.body.style.bottom = "0px",
                    this.body.style.left = "0px")
                }
                removeStyles() {
                    this.body && (this.body.style.removeProperty("position"),
                    this.body.style.removeProperty("top"),
                    this.body.style.removeProperty("right"),
                    this.body.style.removeProperty("bottom"),
                    this.body.style.removeProperty("left"))
                }
            }
            ;
            function r(e) {
                return () => {
                    e.style.top = Math.max(document.documentElement.clientHeight / 2 + window.scrollY - e.clientHeight / 2, window.scrollY) + "px",
                    e.style.left = Math.max(document.documentElement.clientWidth / 2 - e.clientWidth / 2, 0) + "px"
                }
            }
            function s(e) {
                const t = document.createElement("div");
                return t.classList.addMany(e),
                t
            }
            function n(e, t) {
                const r = document.createElement("a");
                r.href = "#",
                t.push("close"),
                r.classList.addMany(t),
                e.appendChild(r)
            }
            function a(e, t, r, s, n, a) {
                const o = document.createElement("div");
                if (null != s && Array.isArray(s) && o.classList.addMany(s),
                r)
                    o.innerHTML = t;
                else if (a) {
                    let t = document.querySelector(a)
                      , r = document.createElement("span");
                    r.id = "popup_pc",
                    t.parentElement.insertBefore(r, t),
                    e.placeholder = document.getElementById(r.id),
                    o.appendChild(t)
                } else
                    o.textContent = t;
                null != n && Object.entries(n).forEach(( ([e,t]) => o.setAttribute(e, t))),
                e.appendChild(o)
            }
            function o(e, t, r) {
                const s = document.createElement("button");
                s.classList.addMany(r || []),
                s.textContent = t,
                e.appendChild(s)
            }
            function i(t, r, s, n) {
                var a, o, i;
                let l;
                const c = e => {
                    var t;
                    null == e || e.preventDefault(),
                    (null == (t = n.onBeforeHide) ? void 0 : t.call(n)) || (r.classList.remove("shown"),
                    !n.keepOpenOnTransition && window.removeEventListener("spaTransition", l),
                    Promise.resolve().then(( () => {
                        var t;
                        null == (t = n.onHide) || t.call(n, e)
                    }
                    )))
                }
                ;
                l = () => {
                    c()
                }
                ,
                !n.keepOpenOnTransition && window.addEventListener("spaTransition", l);
                const u = e => {
                    27 == e.keyCode && (c(e),
                    window.removeEventListener("keydown", u, !0))
                }
                ;
                (n.modal || null == n.modal) && (window.addEventListener("keydown", u, !0),
                setTimeout(( () => null == s ? void 0 : s.addEventListener("click", c)))),
                (null == (a = n.closeSelector) ? void 0 : a.length) > 0 && r.addEventListener("click", this.$helper.delegator(n.closeSelector, c)),
                null != e && (e.close(),
                e = null);
                const d = function(e) {
                    if (!e)
                        return 0;
                    const t = document.querySelectorAll(".j-custom-overlay");
                    let r = 0;
                    return t.forEach((e => {
                        r = Math.max(r, e.style.zIndex)
                    }
                    )),
                    r
                }(s);
                s && (s.style.zIndex = d + 300),
                r.style.zIndex = d + 300 + 1,
                t.appendChild(r),
                s && t.appendChild(s),
                null == (o = n.onBeforeShow) || o.call(n, r),
                document.body.insertBefore(t, document.body.firstChild),
                null == (i = n.onShow) || i.call(n, r);
                const p = {
                    popup: r,
                    overlay: s,
                    close: e => {
                        var t;
                        return null == (t = n.onHide) ? void 0 : t.call(n, r, e)
                    }
                    ,
                    centered: n.centeredFunction
                };
                return n.onlyOne && (e = p),
                p
            }
            function l(e, t, l, c=!0, u=!1) {
                e instanceof Error ? e = e.isCustomError && !e.isCancelled && e.message ? e.message : this.$localziation.serverError : e || (e = this.$localziation.serverError);
                const d = document.createDocumentFragment();
                let p = ["popup", "popup-alert", "shown"];
                t && (Array.isArray(t) ? p = p.concat(t) : p.push(t));
                const h = s(p);
                d.appendChild(h),
                u && n(h, ["popup__close"]),
                a(h, e, !0),
                null !== l && o(h, l || this.$localziation.close, ["popup__btn-main", "popup-alert__close"]);
                const m = document.createElement("div");
                m.classList.addMany(["overlay", "initially-hidden", "j-custom-overlay"]);
                const g = r(h);
                window.addEventListener("resize", g),
                i.call(this, d, h, m, {
                    onlyOne: !0,
                    closeSelector: ".popup-alert__close, .popup__close",
                    modal: c,
                    onShow: function() {
                        h.style.display = "block",
                        g()
                    },
                    onHide: function() {
                        window.removeEventListener("resize", g),
                        h.remove(),
                        m.remove()
                    }
                })
            }
            function c(e, t={}) {
                const r = {
                    msg: e,
                    lockScroll: !0,
                    modal: !1,
                    showCloseBtn: !0,
                    useHtml: !0,
                    contentClasses: ["content"],
                    popupClassesList: ["shown", "tooltip", "tooltip--mobile", ...(null == t ? void 0 : t.classes) || []],
                    useCenteredFunction: !0,
                    onShow: e => e.classList.remove("popup")
                };
                return wb.popup.showCustomPopup(r)
            }
            function u(e, t, o, l) {
                const c = document.createDocumentFragment()
                  , u = s(t);
                n(u, ["j-close"]),
                a(u, e, !0, ["content", "quick-order-popup-content", "j-sizepicker-content"], null);
                const d = document.createElement("div");
                d.classList.addMany(["overlay", "initially-hidden", "j-custom-overlay"]),
                u.id = "size-picker-popup",
                u.style.opacity = "0";
                const p = r(u);
                window.addEventListener("resize", p),
                i.call(this, c, u, d, {
                    closeSelector: ".j-close",
                    onHide: function() {
                        window.removeEventListener("resize", p),
                        u.remove(),
                        d.remove(),
                        null == l || l()
                    },
                    onShow: function() {
                        u.style.display = "block",
                        p(),
                        u.style.opacity = "1",
                        null == o || o(u)
                    }
                })
            }
            function d(e) {
                const o = this.$helper.deepMerge({}, {
                    overlay: !0,
                    showCross: !0,
                    useHtml: !1,
                    popupClassesList: [],
                    contentClasses: [],
                    overlayClasses: [],
                    contentAttributeDictionary: {},
                    msg: "",
                    closeClass: ["j-close", "popup__close"],
                    modal: !0,
                    closeSelector: ".j-close",
                    useCenteredFunction: !1,
                    lockScroll: !1,
                    lockScrollMobile: !1,
                    lockScrollPreviewProduct: !1,
                    onlyOne: !1
                }, e)
                  , l = document.createDocumentFragment()
                  , c = s(["popup"].concat(o.popupClassesList));
                o.showCross && n(c, o.closeClass),
                a(c, o.msg, o.useHtml, o.contentClasses, o.contentAttributeDictionary, o.srcElem),
                o.showCloseBtn && function(e, t) {
                    const r = document.createElement("button");
                    r.innerText = "Закрыть",
                    !t.length && t.push("close"),
                    r.classList.addMany(t),
                    e.appendChild(r)
                }(c, o.closeClass);
                const u = o.overlay ? document.createElement("div") : null;
                if (u) {
                    const e = ["overlay", "initially-hidden", "j-custom-overlay"].concat(o.overlayClasses);
                    u.classList.addMany(e)
                }
                let d;
                return o.useCenteredFunction && (d = r(c),
                window.addEventListener("resize", d)),
                i.call(this, l, c, u, {
                    onBeforeHide: () => {
                        var e;
                        return null == (e = o.onBeforeHide) ? void 0 : e.call(o)
                    }
                    ,
                    onHide: function(e, r) {
                        var s, n, a, i, l;
                        (null == (s = o.onBeforeHide) ? void 0 : s.call(o)) || (!o.lockScroll || (null == r ? void 0 : r.keepLockScroll) || o.keepLockScroll || (document.body.classList.remove("body--overflow"),
                        document.body.style.paddingRight = ""),
                        o.lockScrollPreviewProduct && document.body.classList.remove("body--overflow-preview-kt"),
                        !o.lockScrollMobile || (null == r ? void 0 : r.keepLockScroll) || o.keepLockScroll || (document.body.classList.remove("body--overflow-mobile"),
                        WbSpaModel.prototype.$isDesktop || t.disable()),
                        o.useCenteredFunction && window.removeEventListener("resize", d),
                        o.srcElem && (null == (a = null == (n = c.placeholder) ? void 0 : n.parentElement) || a.insertBefore(document.querySelector(o.srcElem), c.placeholder),
                        null == (i = c.placeholder) || i.remove()),
                        null == (l = o.onHide) || l.call(o, c, e),
                        c.remove(),
                        null == u || u.remove(),
                        document.querySelector("body").classList.remove("no-scroll"))
                    },
                    onShow: () => {
                        var e;
                        if (document.activeElement.blur(),
                        o.lockScroll && !document.body.classList.contains("body--overflow")) {
                            const e = Math.abs(window.innerWidth - document.documentElement.clientWidth);
                            document.body.classList.add("body--overflow"),
                            document.body.style.paddingRight = `${e}px`
                        }
                        o.lockScrollPreviewProduct && !document.body.classList.contains("body--overflow-preview-kt") && document.body.classList.add("body--overflow-preview-kt"),
                        o.lockScrollMobile && !document.body.classList.contains("body--overflow-mobile") && (document.body.classList.add("body--overflow-mobile"),
                        WbSpaModel.prototype.$isDesktop || t.enable());
                        const r = () => {
                            c.style.opacity = 1,
                            o.useCenteredFunction && d()
                        }
                          , s = this.$helper.nextTick().then(( () => (r(),
                        Promise.resolve())));
                        Object.defineProperty(c, "contentEl", {
                            get() {
                                return c.querySelector(".popup__content")
                            }
                        }),
                        o.onShowAsync ? o.onShowAsync(c).then(r) : null == (e = o.onShow) || e.call(o, c, s)
                    }
                    ,
                    onBeforeShow: function() {
                        var e;
                        c.style.opacity = 0,
                        c.style.display = "block",
                        null == (e = o.onBeforeShow) || e.call(o, c)
                    },
                    modal: o.modal,
                    closeSelector: o.closeSelector,
                    centeredFunction: d,
                    onlyOne: o.onlyOne,
                    keepOpenOnTransition: o.keepOpenOnTransition
                })
            }
            function p(e, t) {
                let r;
                const s = this.$helper
                  , n = wb.popup.showCustomPopup({
                    useHtml: !0,
                    popupClassesList: ["popup-video", "shown"],
                    contentClasses: ["content"],
                    useCenteredFunction: !0,
                    msg: $.templates('<h2 class="popup__header">{{>title}}</h2><div class="video"><video id="videoPlayer" class="video-js vjs-default-skin vjs-big-play-centered vjs-waiting" width="855" controls autoplay preload></video></div>')({
                        title: t
                    }),
                    onBeforeShow: e => {
                        e.style.opacity = 0,
                        e.style.display = "block"
                    }
                    ,
                    onShow: t => {
                        r = videojs("videoPlayer", {
                            html5: {
                                nativeAudioTracks: !1,
                                nativeVideoTracks: !1,
                                hls: {
                                    overrideNative: !0
                                }
                            }
                        }),
                        r.ready((function() {
                            this.src({
                                src: e,
                                type: "application/x-mpegURL",
                                withCredentials: !0
                            })
                        }
                        )),
                        s.nextTick().then(( () => {
                            t.style.opacity = 1,
                            n.centered()
                        }
                        ))
                    }
                    ,
                    onHide: () => {
                        r.isDisposed() || (r.isInPictureInPicture() && r.exitPictureInPicture(),
                        r.dispose())
                    }
                })
            }
            function h(e, t={}) {
                return new Promise((l => {
                    var c, u, d;
                    document.activeElement.blur();
                    const p = document.createDocumentFragment();
                    let h = ["popup", "popup-confirm", "shown"];
                    t.classList && (h = h.concat(t.classList));
                    let m = ["popup__btn-main", "j-yes"]
                      , g = ["popup__btn-base", "j-no"];
                    t.yesBtnClassList && (m = t.yesBtnClassList),
                    t.noBtnClassList && (g = t.noBtnClassList);
                    const y = s(h);
                    y.style.display = "block",
                    t.contentClasses = t.contentClasses || [],
                    t.contentClasses.push("popup__msg"),
                    a(y, e, !0, t.contentClasses);
                    let b = document.createElement("div");
                    b.classList.add("popup__btn", "btn-block"),
                    y.appendChild(b);
                    const f = [];
                    if ((null == (c = t.showYesBtn) || c) && f.push(( () => o(b, t.yes || $.localize("Да"), m))),
                    (null == (u = t.showNoBtn) || u) && f.push(( () => o(b, t.no || $.localize("Нет"), g))),
                    t.inverseBtns && f.reverse(),
                    f.forEach((e => e())),
                    t.showCross && n(y, ["popup__close"]),
                    t.lockScroll && !document.body.classList.contains("body--overflow")) {
                        const e = Math.abs(window.innerWidth - document.documentElement.clientWidth);
                        document.body.classList.add("body--overflow"),
                        document.body.style.paddingRight = `${e}px`
                    }
                    const v = document.createElement("div");
                    v.classList.addMany(["overlay", "initially-hidden", "j-custom-overlay"]);
                    const w = i.call(this, p, y, v, {
                        onHide: function() {
                            y.remove(),
                            v.remove(),
                            l(!1),
                            t.lockScroll && (document.body.classList.remove("body--overflow"),
                            document.body.style.paddingRight = "")
                        },
                        onShow: function() {
                            var e;
                            const s = y.querySelector(".popup__back");
                            r(y)(),
                            y.querySelector(m.map((e => "." + e)).join("")).addEventListener("click", (e => {
                                l(!0),
                                w.close()
                            }
                            )),
                            null == (e = y.querySelector(g.map((e => "." + e)).join(""))) || e.addEventListener("click", (e => {
                                l(!1),
                                w.close()
                            }
                            )),
                            s && s.addEventListener("click", ( () => {
                                t.backBtnCallback(),
                                w.close()
                            }
                            ))
                        },
                        modal: null != (d = t.modal) && d,
                        closeSelector: t.showCross ? ".popup__close" : null
                    })
                }
                ))
            }
            function m(e, {width: t=600, height: r=500}={}) {
                const s = [`top=${Math.floor((window.screenY || window.screenTop || 0) + (window.outerHeight - r) / 2) || 0}`, `left=${Math.floor((window.screenX || window.screenLeft || 0) + (window.outerWidth - t) / 2) || 0}`, `width=${t}`, `height=${r}`, "status=0", "toolbar=0"];
                return null != window.open(e, "", s.join(","))
            }
            class g extends WbSpaModel {
                renderModalError() {
                    return l.apply(this, arguments)
                }
                renderModalAdaptive() {
                    return c.apply(this, arguments)
                }
                showCustomPopup() {
                    return d.apply(this, arguments)
                }
                confirm() {
                    return h.apply(this, arguments)
                }
                videoPlayer() {
                    return p.apply(this, arguments)
                }
                showSizePickerPopup() {
                    return u.apply(this, arguments)
                }
                browserPopup() {
                    return m.apply(this, arguments)
                }
                showFeedbackError(e) {
                    return $.views.loadTemplateAsync("popupErrorUnbuy").then((t => {
                        wb.popup.showCustomPopup({
                            useHtml: !0,
                            msg: t.render({
                                errorMessage: e.isCancelled ? null : e.message
                            }),
                            popupClassesList: ["popup-error-unbuy", "shown"],
                            contentClasses: ["popup__content"],
                            useCenteredFunction: !0,
                            modal: !0
                        })
                    }
                    ))
                }
            }
            wb.popup = new g
        },
        64169: function() {
            "use strict";
            Array.prototype.findLast || (Array.prototype.findLast = function(e, t) {
                for (let r = this.length - 1; r >= 0; r--)
                    if (e.call(t, this[r], r, this))
                        return this[r]
            }
            ),
            String.prototype.replaceAll || (String.prototype.replaceAll = function(e, t) {
                return "[object regexp]" === Object.prototype.toString.call(e).toLowerCase() ? this.replace(e, t) : this.replace(new RegExp(e,"g"), t)
            }
            ),
            Array.prototype.flatMap || (Array.prototype.flatMap = function(e, t) {
                const r = t || this;
                if (null == r)
                    throw new TypeError("Array.prototype.flatMap called on null or undefined");
                if ("function" != typeof e)
                    throw new TypeError(e + " is not a function");
                let s = [];
                const n = Object(r)
                  , a = n.length >>> 0;
                for (let t = 0; t < a; t++)
                    if (t in n) {
                        const a = e.call(r, n[t], t, n);
                        s = s.concat(a)
                    }
                return s
            }
            )
        },
        52167: function(e, t) {
            "use strict";
            const r = "spa_history";
            class s {
                constructor() {
                    this.head = null,
                    this.current = null
                }
                push(e) {
                    const t = new n(e,this.current);
                    null == this.head || null == this.current ? this.head = t : this.current.updateNext(t),
                    this.current = t
                }
                tryUpdateCurrrent(e) {
                    return null != this.current && (this.current.update(e),
                    !0)
                }
                findCurrent(e) {
                    const {id: t} = e;
                    let r = this.head;
                    for (; r; ) {
                        if (r.state.id == t) {
                            this.current = r;
                            break
                        }
                        r = r.next
                    }
                }
                tryRevokeFromCache(e) {
                    const t = e.reduce(( (e, t) => (e.set(t.state, new n(t.state)),
                    e)), new Map);
                    e.forEach((e => {
                        const r = t.get(e.state);
                        if (e.next) {
                            const s = t.find((t => t.state.id == e.next));
                            r.updateNext(s)
                        }
                        if (e.previous) {
                            const s = t.find((t => t.state.id == e.previous));
                            r.updatePrevious(s)
                        }
                    }
                    ));
                    const r = t.find((e => null == e.previous));
                    return !!r && (this.head = r,
                    !0)
                }
                toJSON() {
                    var e, t;
                    let r = this.head;
                    const s = [];
                    for (; r; )
                        s.push({
                            state: r.state,
                            next: null == (e = r.next) ? void 0 : e.state.id,
                            previous: null == (t = r.previous) ? void 0 : t.state.id
                        }),
                        r = r.next;
                    return s
                }
                canMove(e) {
                    let t = this.current
                      , r = e > 0 ? -1 : 1
                      , s = e > 0 ? "next" : "previous"
                      , n = e;
                    for (; 0 != n; )
                        if (t = t[s],
                        n += r,
                        null == t)
                            return;
                    return !0
                }
            }
            class n {
                constructor(e, t) {
                    this.state = e,
                    this.previous = t,
                    this.next = null
                }
                updateNext(e) {
                    this.next = e
                }
                updatePrevious(e) {
                    this.previous = e
                }
                update(e) {
                    this.state = e
                }
            }
            t.A = class {
                constructor() {
                    this.history = new s
                }
                addItem(e) {
                    this.history.push(e),
                    this._updateCache()
                }
                tryInitFromCache(e) {
                    const t = sessionStorage.getObject(r);
                    return t && e && this.history.tryRevokeFromCache(t) && this.history.findCurrent(e),
                    this
                }
                updateCurrent(e) {
                    this.history.findCurrent(e)
                }
                updateCurrentItem(e) {
                    this.history.tryUpdateCurrrent(e) || this.history.push(e),
                    this._updateCache()
                }
                canMove(e) {
                    return this.history.canMove(e)
                }
                _updateCache() {
                    sessionStorage.putObject(r, this.history)
                }
                static generateId() {
                    return WbSpaModel.prototype.$generateGuid()
                }
            }
        },
        73539: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
            "use strict";
            var _customHistory_customHistory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52167)
              , _utils_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71595)
              , features_core_Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(92254)
              , __defProp = Object.defineProperty
              , __getOwnPropSymbols = Object.getOwnPropertySymbols
              , __hasOwnProp = Object.prototype.hasOwnProperty
              , __propIsEnum = Object.prototype.propertyIsEnumerable
              , __defNormalProp = (e, t, r) => t in e ? __defProp(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }) : e[t] = r
              , __spreadValues = (e, t) => {
                for (var r in t || (t = {}))
                    __hasOwnProp.call(t, r) && __defNormalProp(e, r, t[r]);
                if (__getOwnPropSymbols)
                    for (var r of __getOwnPropSymbols(t))
                        __propIsEnum.call(t, r) && __defNormalProp(e, r, t[r]);
                return e
            }
              , __objRest = (e, t) => {
                var r = {};
                for (var s in e)
                    __hasOwnProp.call(e, s) && t.indexOf(s) < 0 && (r[s] = e[s]);
                if (null != e && __getOwnPropSymbols)
                    for (var s of __getOwnPropSymbols(e))
                        t.indexOf(s) < 0 && __propIsEnum.call(e, s) && (r[s] = e[s]);
                return r
            }
              , __publicField = (e, t, r) => __defNormalProp(e, "symbol" != typeof t ? t + "" : t, r);
            const DEFAULT_PREVIEW = "preview_General"
              , APP_CONTAINERS = Object.freeze([{
                containerId: 0,
                viewModel: null
            }, {
                containerId: 1,
                viewModel: null
            }, {
                containerId: 2,
                viewModel: null
            }])
              , VIEW_MODEL_STATUSES = Object.freeze({
                prepearing: 0,
                readyToInstall: 1,
                installed: 2,
                destroyed: 3
            })
              , VALID_EXTERNAL_DOMAINS = Object.freeze(["vmeste.wildberries.ru", "vmeste-stage.wildberries.ru", "digital.wildberries.ru", "vsemrabota.ru", "guru.wildberries.ru", "guru-stage.wildberries.ru", "travel.wildberries.ru", "digital.wb.ru", "seller.wildberries.ru", "career.wb.ru"]);
            class RouterState extends features_core_Observable__WEBPACK_IMPORTED_MODULE_2__.c {
                constructor() {
                    super(...arguments),
                    __publicField(this, "showPreview", !1)
                }
            }
            class Router {
                constructor() {
                    __publicField(this, "state", new RouterState),
                    __publicField(this, "initTask", new _utils_core__WEBPACK_IMPORTED_MODULE_1__.Deferred)
                }
                async init(e) {
                    var t, r, s, n;
                    this.customHistory = (new _customHistory_customHistory__WEBPACK_IMPORTED_MODULE_0__.A).tryInitFromCache(window.history.state),
                    this.abortController = new AbortController,
                    this.routeParameters = {},
                    this.clientRenderInited = !1,
                    this.referrer = document.referrer,
                    Object.defineProperty(document, "referrer", {
                        get: function() {
                            return WbSpaModel.prototype.$router.referrer
                        }
                    });
                    let a = null == (t = this._findRoute(window.location.pathname)) ? void 0 : t.name;
                    if (!a) {
                        try {
                            const e = await this.$httpClient.fetchJSON(`/webapi/check-redirect${window.location.pathname}${window.location.search}`);
                            (null == e ? void 0 : e.redirect) && (a = null == (r = this._findRoute(window.location.pathname)) ? void 0 : r.name)
                        } catch (e) {}
                        if (!a)
                            return this._bindEvents(),
                            this.moveTo404Async()
                    }
                    this.currentRoute = this.routesDictionary[a],
                    this.targetRoute = a,
                    this._bindEvents();
                    const o = this.routesDictionary[a].useSSR;
                    return o || (this.current = $.templates["preview_" + a] ? "preview_" + a : DEFAULT_PREVIEW),
                    (null == (s = window.history.state) ? void 0 : s.name) || this._replaceState({
                        name: a
                    }, document.title, window.location.href),
                    this.loadingTemplate = a,
                    null == (n = this.initTask) || n.resolve(),
                    o && null != e ? this._initSSR(e, a) : this._routerTransitionAsync(a, window.location, !0).then(( ({needStateUpdate: e}) => Promise.resolve(e))).catch((e => {
                        var t;
                        return console.log(e),
                        e.isCancelled || this.moveTo500Async(),
                        null == (t = this.initTask) || t.resolve(),
                        Promise.resolve()
                    }
                    ))
                }
                setData(e, t) {
                    this.routesDictionary = e,
                    this.tmplHashes = t
                }
                get appContainers() {
                    return APP_CONTAINERS
                }
                get previewTemplate() {
                    return DEFAULT_PREVIEW
                }
                get viewModel() {
                    var e;
                    return null == (e = this.appContainers.find((e => e.containerId == this.activeContainer))) ? void 0 : e.viewModel
                }
                refresh() {
                    const e = this.currentRoute;
                    this.clearNotActiveContainer(),
                    this.goToRoute(e, window.location, !0)
                }
                clearNotActiveContainer() {
                    this.appContainers.filter((e => e.containerId !== this.activeContainer)).forEach((e => {
                        var t, r;
                        null !== e.viewModel && ((null == (t = e.viewModel) ? void 0 : t.__modelStatus__) != VIEW_MODEL_STATUSES.destroyed && (null == (r = e.viewModel) || r.onBeforeUnrender()),
                        e.viewModel = null)
                    }
                    ))
                }
                move(e, t) {
                    var r;
                    null == (null == (r = null == t ? void 0 : t.currentTarget) ? void 0 : r.href) ? window.history.go(e) : this.customHistory.canMove(e) && (t.preventDefault(),
                    window.history.go(e))
                }
                moveTo(e, t=!1, r=!1, s=!1) {
                    var n, a, o;
                    let i;
                    try {
                        i = new URL(e,window.location.origin)
                    } catch (e) {
                        return !1
                    }
                    if ("javascript:" === i.protocol)
                        return !1;
                    if (VALID_EXTERNAL_DOMAINS.includes(i.host))
                        return window.location = i.toString(),
                        !1;
                    const l = this._findRoute(i.pathname);
                    return null == l || null == this.routesDictionary[l.name] || i.hostname !== window.location.hostname ? (this.isLeaving = !0,
                    t ? window.location.replace(encodeURIComponent(e)) : window.location = e) : (this.isLeaving = !1,
                    (null == (n = this.currentRoute) ? void 0 : n.name) === l.name && window.dispatchEvent(new CustomEvent("spaTransition",{
                        detail: {
                            isFinished: !0,
                            dest: l
                        }
                    })),
                    i.pathname !== window.location.pathname || window.location.search !== i.search || r ? (this.targetRoute = l.name,
                    this.referrer = window.location.href,
                    t ? this._replaceState({
                        name: l.name
                    }, document.title, i.href) : this._pushState({
                        name: l.name
                    }, document.title, i.href),
                    void this.goToRoute(l, i, s).then((e => {
                        e && this._replaceState({
                            name: l.name
                        }, document.title, i.href)
                    }
                    )).catch(( () => {}
                    ))) : (null == (o = null == (a = this.viewModel) ? void 0 : a.onSamePageNavigation) || o.call(a, e),
                    void window.dispatchEvent(new CustomEvent("samePageNavigation",{
                        detail: {
                            targetLink: e
                        }
                    }))))
                }
                goToRoute(e, t, r=!1) {
                    return window.dispatchEvent(new CustomEvent("spaTransition",{
                        detail: {
                            isFinished: !1,
                            dest: e
                        }
                    })),
                    this._routerTransitionAsync(e.name, t, !1, r, !0)
                }
                getAppliedEntries() {
                    var e;
                    const t = document && (null == (e = document.currentScript) ? void 0 : e.src);
                    let r;
                    return r = "currentScript"in document ? t.includes("static-basket") ? t.replace(/https?:/, "") : t.replace(window.origin, "") : this.routesDictionary[this.loadingTemplate].requiredModel,
                    Object.keys(this.routesDictionary).filter((e => this.routesDictionary[e].requiredModel === r))
                }
                prepareUrl(e) {
                    if (null == e.routePathSegments)
                        return e.path;
                    const t = e.routePathSegments.reduce(( (e, t) => (e += "/",
                    t.isParameter ? (!t.isOptional || t.isOptional && null != this.routeParameters[t.name]) && (e += this.routeParameters[t.name]) : e += t.content,
                    e)), "").replace(/[\/\?]$/, "");
                    return e.externalPath ? e.externalPath + t : t
                }
                addState(e, t, r) {
                    var s;
                    this._pushState(__spreadValues({
                        isLocalHandler: !0,
                        name: (null == (s = this.currentRoute) ? void 0 : s.name) || ""
                    }, e), t, r)
                }
                replaceState(e, t, r) {
                    var s;
                    this._replaceState(__spreadValues({
                        isLocalHandler: !0,
                        name: (null == (s = this.currentRoute) ? void 0 : s.name) || ""
                    }, e), t, r)
                }
                _pushState(e, t, r) {
                    const s = _customHistory_customHistory__WEBPACK_IMPORTED_MODULE_0__.A.generateId();
                    e.id = s,
                    window.history.pushState(e, t, r),
                    this.customHistory.addItem(e)
                }
                _replaceState(e, t, r) {
                    e.id = _customHistory_customHistory__WEBPACK_IMPORTED_MODULE_0__.A.generateId(),
                    e.title = t,
                    window.history.replaceState(e, "", r),
                    this.customHistory.updateCurrentItem(e)
                }
                initCSR() {
                    const e = Object.create(WbSpaModel.prototype, {
                        router: {
                            value: this
                        }
                    });
                    $.link.appTemplate("#app", e),
                    this.clientRenderInited = !0
                }
                async updateRouteDataExternal(e, t) {
                    var r;
                    t = t || (null == (r = this.currentRoute) ? void 0 : r.name) || "",
                    await this._updateRouteData(t, e)
                }
                async moveTo404Async() {
                    try {
                        const e = await this.$moduleLoader.loadModuleAsync("error404")
                          , t = new e(e.data,e.template);
                        await t.showErrorPage(),
                        window.dispatchEvent(new CustomEvent("spaTransition",{
                            detail: {
                                isFinished: !0
                            }
                        }))
                    } catch (e) {
                        console.error(e),
                        $.link.criticalError("#app")
                    }
                }
                async moveTo500Async(e, t) {
                    try {
                        await Promise.all([this.$helper.loadCssAsync(wb.settings.styles.error500), this.$helper.loadJsAsync(wb.settings.scripts.spaRecommendationCarousel)]),
                        this._updateRouteData("criticalError")
                    } catch (e) {
                        console.error(e),
                        this._updateRouteData("absoluteCriticalError")
                    } finally {
                        wb.spa.logError(e, t, !0)
                    }
                }
                async loadRouteDataAsync(e, t=0, r=!1, s=!1) {
                    var n, a, o, i, l;
                    const c = this.$routeExtensions.extend(null == e ? void 0 : e.name);
                    let u;
                    try {
                        if (!e)
                            return {
                                viewData: {},
                                needStateUpdate: !1
                            };
                        u = {
                            url: new URL(`${this.prepareUrl(e)}?${this.queryParams.toString()}`,window.location.origin),
                            params: {
                                method: "POST"
                            },
                            options: {
                                redirectUnauth: !0,
                                replaceState: !0,
                                includeResponse: !0
                            }
                        },
                        await Promise.all((null != (n = null == c ? void 0 : c.pipelines) ? n : []).map((e => {
                            var r;
                            return null == (r = e.onBeforeActionExecuting) ? void 0 : r.call(e, u.url, u.params, u.options, s, t)
                        }
                        )));
                        const r = [];
                        u.options.cancelRequest || u.options.redirected ? r.push(Promise.resolve({})) : r.push(this.$httpClient.fetchJSON(u.url.toString(), u.params, u.options)),
                        r.push(...(null != (a = null == c ? void 0 : c.pipelines) ? a : []).map((e => {
                            var r;
                            return null == (r = e.onActionExecuting) ? void 0 : r.call(e, u.url, u.params, u.options, s, t)
                        }
                        )));
                        const [l] = await Promise.all(r);
                        u.options.redirected || await Promise.all((null != (o = null == c ? void 0 : c.pipelines) ? o : []).map((e => {
                            var t;
                            return null == (t = e.onActionExecuted) ? void 0 : t.call(e, l, s)
                        }
                        )));
                        let d = l.responseData;
                        return u.options.cancelRequest && (null == c ? void 0 : c.fallback) && (d = null == c ? void 0 : c.fallback(u)),
                        {
                            viewData: d,
                            needStateUpdate: !1,
                            needRouteUpdate: !(null != (i = u.options.redirected) && i)
                        }
                    } catch (s) {
                        const n = null != (l = c.maxTriesCount) ? l : 3;
                        if (s.isNotFound || s.isUnauthorize || s.isCancelled || t >= n || r) {
                            if ((null == c ? void 0 : c.fallback) && (s.isCancelled || t >= n))
                                return {
                                    viewData: null == c ? void 0 : c.fallback(u),
                                    needStateUpdate: !1
                                };
                            throw s
                        }
                        return await this.loadRouteDataAsync(e, ++t)
                    }
                }
                moveToSignIn(e, t) {
                    let r = $.views.helpers.urlSignIn(e && e.query && e.query.returnUrl);
                    this.moveTo(new URL(r,window.location.href).href, t)
                }
                _bindEvents() {
                    window.addEventListener("popstate", (e => {
                        var t, r, s;
                        this.$analitic.updateStatInfo(!1);
                        const {name: n, isLocalHandler: a, title: o} = history.state;
                        if (o && (document.title = o),
                        null != this.routesDictionary[n]) {
                            if (this.customHistory.updateCurrent(history.state),
                            window.dispatchEvent(new CustomEvent("spaTransition",{
                                detail: {
                                    isFinished: !1,
                                    dest: {
                                        name: n
                                    }
                                }
                            })),
                            a && (null == (t = this.currentRoute) ? void 0 : t.name) == n)
                                return this._updateRouteParametres(window.location.pathname.substring(1), this.currentRoute),
                                this._updateQueryModel(),
                                null == (s = null == (r = this.viewModel) ? void 0 : r.onHistoryChange) || s.call(r, history.state, null, {
                                    fromPopstate: !0
                                }, this.abortController.signal),
                                void window.dispatchEvent(new CustomEvent("spaTransition",{
                                    detail: {
                                        isFinished: !0,
                                        dest: {
                                            name: n
                                        }
                                    }
                                }));
                            this.targetRoute = n,
                            this._routerTransitionAsync(n)
                        } else
                            window.location.reload()
                    }
                    )),
                    window.addEventListener("mouseup", (e => {
                        const t = e.target.closest("a");
                        if (!t)
                            return !1;
                        0 == e.button || 1 == e.which || (this.$analitic.saveEcomInfo(t),
                        this.$analitic.updateStatInfo(!0))
                    }
                    )),
                    window.addEventListener("click", (e => {
                        const t = e.target.closest("a");
                        if ((null == t ? void 0 : t.classList.contains("BDC_ReloadLink")) || e.defaultPrevented || e.ctrlKey || e.metaKey)
                            return !1;
                        this.$analitic.saveEcomInfo(t),
                        null != t && (t.hasAttribute("target") && "_blank" === t.getAttribute("target") ? this.$analitic.updateStatInfo(!0) : (this.$analitic.updateStatInfo(!1),
                        e.preventDefault(),
                        this.moveTo(t.href)))
                    }
                    ))
                }
                async _routerTransitionAsync(e, t=window.location, r=!1, s=!1, n=!1) {
                    this.abortController.abort(),
                    this.abortController = new AbortController;
                    const a = this.abortController.signal
                      , o = this.currentRoute;
                    if (this.currentRoute = this.routesDictionary[e],
                    (null == o ? void 0 : o.useReact) && !this.currentRoute.useReact) {
                        const {unmountReactPage: e} = await Promise.all([__webpack_require__.e(89362), __webpack_require__.e(48829), __webpack_require__.e(53214), __webpack_require__.e(64210)]).then(__webpack_require__.bind(__webpack_require__, 83019));
                        e();
                        const t = document.getElementById("app");
                        t && (t.style.display = "")
                    }
                    wb.stat.sendPageView(),
                    this.$analitic.sendEvent("pageview", {
                        cookies_alert: wb.spa.getMainLayout().cookiePolicy.check() ? 1 : 0
                    });
                    try {
                        const {viewData: o, needStateUpdate: i, needRouteUpdate: l} = await this._loadRouteData(e, t, r, s, a);
                        return l && this._updateRouteData(e, o, a, n),
                        window.dispatchEvent(new CustomEvent("spaTransition",{
                            detail: {
                                isFinished: !0,
                                dest: this.currentRoute
                            }
                        })),
                        window.scrollTo(0, 0),
                        i
                    } catch (t) {
                        if (t.isNotFound)
                            return this.moveTo404Async(),
                            !1;
                        if (!t.isCancelled && !t.isUnauthorize && null != t.message && "" != t.message)
                            return console.log(t.message),
                            this.moveTo500Async(t, {
                                method: "_routerTransitionAsync",
                                destRoute: e,
                                current: window.location.toString(),
                                initial: r,
                                forced: s
                            }),
                            !1;
                        throw t
                    }
                }
                _findRoute(e) {
                    var t;
                    const r = e.substring(1).split("/")
                      , s = e.substring(1);
                    let n = null != (t = Object.keys(this.routesDictionary).filter((e => {
                        const t = this.routesDictionary[e];
                        return null == t.routePathSegments ? t.path === s : ("SpaCatalogEntrypoint" !== t.name || ".aspx" !== s.slice(-5)) && t.routePathSegments.every(( (e, t) => {
                            var s;
                            return e.isParameter ? !(null != (s = null == e ? void 0 : e.isOptional) && !s) || r[t] : e.content === r[t]
                        }
                        ))
                    }
                    )).map((e => this.routesDictionary[e]))) ? t : [];
                    if (n.length > 1) {
                        const e = e => {
                            var t, r;
                            return null != (r = null == (t = e.routePathSegments) ? void 0 : t.some((e => e.isCatchAll))) && r
                        }
                        ;
                        n.sort(( (t, r) => e(t) - e(r))),
                        n = n.filter((e => "SpaCatalogEntrypoint" !== e.name))
                    }
                    return n[0]
                }
                async _initSSR(e, t) {
                    var r, s, n, a, o, i, l, c;
                    this.currentRoute = this.routesDictionary[t];
                    const u = this.currentRoute.requiredModel ? this.$helper.loadJsAsync(this.currentRoute.requiredModel) : Promise.resolve()
                      , d = this._loadTemplateAsync(t);
                    this._updateQueryModel(),
                    this._updateRouteParametres(window.location.pathname.substring(1), this.routesDictionary[t]);
                    try {
                        await Promise.all([d, u]);
                        const p = wb.spa.getViewModelByName(t)
                          , h = p ? new p(e,t) : Object.create(WbSpaModel.prototype, {});
                        h.fromSSR = !0;
                        const m = null != (s = null == (r = this.currentRoute) ? void 0 : r.targetContainer) ? s : 0
                          , g = this.appContainers.find((e => e.containerId == m));
                        $.observable(g).setProperty({
                            viewModel: h
                        }),
                        $.observable(this).setProperty({
                            activeContainer: m
                        });
                        const y = new this.$helper.Deferred;
                        await (null == (a = (n = this.viewModel).onBeforeRender) ? void 0 : a.call(n, e, y.promise)),
                        $.link(!0, "#app", this.viewModel),
                        await this.$helper.nextTick(),
                        null == (i = (o = this.viewModel).onAfterRender) || i.call(o, {
                            data: e
                        }),
                        wb.stat.sendPageView();
                        const b = null == (c = (l = this.viewModel).getScreenName) ? void 0 : c.call(l);
                        b && this.$analitic.sendEvent("Screen_V", {
                            name: b
                        })
                    } catch (e) {
                        console.error(e.message)
                    }
                }
                async _loadRouteData(e, t, r, s, n) {
                    var a, o, i, l, c, u;
                    this._updateRouteParametres(t.pathname.substring(1), this.routesDictionary[e]),
                    this._updateQueryModel(t);
                    const d = this.prepareUrl(this.currentRoute);
                    this.$menuLk.updateMenu(d, this.currentRoute.lkMenuOptions, this.userIsAuth);
                    const p = null != (o = null == (a = this.currentRoute) ? void 0 : a.targetContainer) ? o : 0
                      , h = null == (i = this.appContainers.find((e => e.containerId == p))) ? void 0 : i.viewModel
                      , m = !s && null != h && h.__modelStatus__ != VIEW_MODEL_STATUSES.destroyed && h.__routeName__ == e && null != h.onHistoryChange;
                    if (this.clientRenderInited || m)
                        if (m || r) {
                            if (m) {
                                const e = this.activeContainer == p;
                                return e || ($.observable(this).setProperty({
                                    showPreview: !0
                                }),
                                this.state.showPreview = !0),
                                null == (c = null == (l = this.viewModel) ? void 0 : l.onActiveViewChanged) || c.call(l, !1, {
                                    sameContainer: e
                                }),
                                await (null == (u = h.onHistoryChange) ? void 0 : u.call(h, window.history.state, s, {}, n)),
                                n.aborted || ($.observable(this).setProperty({
                                    activeContainer: p,
                                    showPreview: !1
                                }),
                                this.state.showPreview = !1),
                                {
                                    viewData: null,
                                    needStateUpdate: !1,
                                    needRouteUpdate: !1
                                }
                            }
                        } else
                            $.observable(this).setProperty({
                                showPreview: !0
                            }),
                            this.state.showPreview = !0;
                    else
                        !r && (this.current = $.templates["preview_" + e] ? "preview_" + e : DEFAULT_PREVIEW);
                    !this.currentRoute.metaTagsUrl && this.$seoHelper.update(d, null);
                    const g = await this._loadRequiredResoursesAsync(e);
                    return __spreadValues({
                        needRouteUpdate: !n.aborted
                    }, g)
                }
                _loadRequiredResoursesAsync(e, t=0) {
                    this.loadingTemplate = e;
                    const r = this.routesDictionary[e]
                      , s = null == $.templates[e] && r.tmpl ? this._loadTemplateAsync(e, r.tmpl) : Promise.resolve()
                      , n = this.loadRouteDataAsync(r.requiredData, t, !0)
                      , a = r.requiredCss ? Promise.all(r.requiredCss.map(this.$helper.loadCssAsync)) : Promise.resolve()
                      , o = r.requiredJs ? Promise.all(r.requiredJs.map(this.$helper.loadJsAsync)) : Promise.resolve()
                      , i = r.requiredModel ? this.$helper.loadJsAsync(r.requiredModel) : Promise.resolve();
                    return Promise.all([n, o, a, i, s]).then(( ([e]) => Promise.resolve(e))).catch((r => r.isNotFound || r.isUnauthorize || r.isCancelled || t >= 3 ? Promise.reject(r) : this._loadRequiredResoursesAsync(e, ++t)))
                }
                async _updateRouteData(e, t, r=this.abortController.signal, s=!1) {
                    var n, a, o, i, l, c, u, d, p, h, m, g;
                    if (r.aborted)
                        return;
                    const y = this.routesDictionary[e];
                    if (null == y ? void 0 : y.useReact) {
                        const e = y.reactPageName
                          , {renderReactPage: r} = await Promise.all([__webpack_require__.e(89362), __webpack_require__.e(48829), __webpack_require__.e(53214), __webpack_require__.e(64210)]).then(__webpack_require__.bind(__webpack_require__, 83019));
                        await r({
                            reactPageName: e,
                            viewData: t,
                            routerState: this.state
                        });
                        const s = document.getElementById("app");
                        s && (s.style.display = "none")
                    }
                    if (e.indexOf("preview_") > -1)
                        return this.state.showPreview = !0,
                        $.observable(this).setProperty({
                            showPreview: !0
                        });
                    const b = wb.spa.getViewModelByName(e)
                      , f = b ? new b(t,e) : Object.assign(Object.create(WbSpaModel.prototype), null != t ? t : {})
                      , v = null != (a = null == (n = this.currentRoute) ? void 0 : n.targetContainer) ? a : 0
                      , w = f.onBeforeRender
                      , S = f.onAfterRender
                      , _ = f.onBeforeUnrender;
                    Object.defineProperties(f, {
                        __routeName__: {
                            value: e
                        },
                        __targetContainer__: {
                            value: v
                        },
                        __modelStatus__: {
                            value: VIEW_MODEL_STATUSES.prepearing,
                            writable: !0
                        },
                        routeTemplate: {
                            value: e
                        },
                        onBeforeRender: {
                            value: async function(e, t) {
                                r.aborted || (await (null == w ? void 0 : w.call(f, e, t)),
                                this.__modelStatus__ = VIEW_MODEL_STATUSES.readyToInstall)
                            }
                        },
                        onAfterRender: {
                            value: async function(e, t) {
                                r.aborted || (await (null == S ? void 0 : S.call(f, e, r, t)),
                                this.__modelStatus__ = VIEW_MODEL_STATUSES.installed)
                            }
                        },
                        onBeforeUnrender: {
                            value: async function(e) {
                                await (null == _ ? void 0 : _.call(f, e)),
                                this.__modelStatus__ = VIEW_MODEL_STATUSES.destroyed
                            }
                        }
                    });
                    const C = null == this ? void 0 : this.viewModel;
                    if (null == C || C.__targetContainer__ != v && null != C.onHistoryChange ? null == (c = null == (l = null == this ? void 0 : this.viewModel) ? void 0 : l.onActiveViewChanged) || c.call(l, !1) : await (null == (i = null == (o = null == this ? void 0 : this.viewModel) ? void 0 : o.onBeforeUnrender) ? void 0 : i.call(o)),
                    r.aborted)
                        return;
                    const I = new this.$helper.Deferred;
                    await (null == (u = f.onBeforeRender) ? void 0 : u.call(f, t, I.promise));
                    let M = window._debug && performance.now();
                    const k = this.appContainers.find((e => e.containerId == v));
                    (null == (d = k.viewModel) ? void 0 : d.__modelStatus__) != VIEW_MODEL_STATUSES.destroyed && (null == (p = k.viewModel) || p.onBeforeUnrender(t)),
                    r.aborted || ($.observable(k).setProperty({
                        viewModel: f
                    }),
                    $.observable(this).setProperty({
                        showPreview: !1,
                        activeContainer: v
                    }),
                    this.state.showPreview = !1),
                    this.clientRenderInited || this.initCSR(),
                    M && console.log("[INITIAL MODEL RENDER]: ", performance.now() - M, e),
                    await this.$helper.nextTick(),
                    I.resolve(),
                    null == (h = f.onAfterRender) || h.call(f, t, r),
                    s && (null == (m = f.onSpaTransition) || m.call(f));
                    const P = null == (g = f.getScreenName) ? void 0 : g.call(f);
                    P && this.$analitic.sendEvent("Screen_V", {
                        name: P
                    })
                }
                _updateRouteParametres(e, t) {
                    if (null == t.routePathSegments)
                        return void (this.routeParameters = {});
                    const r = e.split("/")
                      , s = t.routePathSegments.reduce(( (e, t, s) => (t.isParameter && (t.isCatchAll ? e[t.name] = r.slice(s).join("/") : e[t.name] = r[s]),
                    e)), {});
                    this.routeParameters = s
                }
                _updateQueryModel(e) {
                    this.queryParams = new URLSearchParams((null != e ? e : window.location).search)
                }
                _loadTemplateAsync(routeName, tmplNameInput) {
                    const tmplName = ("string" == typeof tmplNameInput ? tmplNameInput : `${routeName.replace("Entrypoint", "")}`).toLowerCase()
                      , tmplFullName = (window._debug,
                    `${tmplName}.json`)
                      , hash = this.tmplHashes[tmplFullName]
                      , path = window._debug ? `${tmplFullName}?${hash}` : tmplFullName.replace(".json", `.${hash}.json`);
                    return this.$httpClient.fetchStaticV3(wb.helpers.url.urlForJsTmpl, {}, path).then((tmpl => {
                        const _a = tmpl
                          , {main: main, localization: localization} = _a
                          , templates = __objRest(_a, ["main", "localization"]);
                        if (localization)
                            try {
                                Object.assign(this.$localziation, {
                                    [routeName]: eval(localization)
                                })
                            } catch (e) {}
                        return $.templates(__spreadValues({
                            [routeName]: main
                        }, templates)),
                        Promise.resolve()
                    }
                    )).catch((e => Promise.reject(e)))
                }
                _hardReload() {
                    return location.reload()
                }
            }
            __webpack_exports__.A = Router
        },
        97929: function(e, t, r) {
            "use strict";
            var s = r(33036);
            const n = "wb_delivery-points-"
              , a = "wb_allpickups_hash"
              , o = 36e4
              , i = [{
                dtype: 86,
                min: 1e7,
                max: 11e6
            }]
              , l = s.Ho;
            t.A = class {
                constructor() {
                    this._startJobSyncPickups(),
                    this.checkInterval = null
                }
                _startJobSyncPickups() {
                    this._pickupDbName = "wb_allpickups",
                    this._objectStoreName = "pickups_active",
                    this._version = 1,
                    setTimeout(this._syncPickups.bind(this), 15e3)
                }
                _openPickupDb() {
                    return this.$storageHelper.openDb(this._pickupDbName, {
                        onupgradeneeded: e => e.createObjectStore(this._objectStoreName, {
                            keyPath: "id"
                        }),
                        version: this._version
                    })
                }
                restoreOriginalId(e) {
                    for (const {min: t, max: r, dtype: s} of i)
                        if (t <= e && e < r)
                            return {
                                id: e - t,
                                dtype: s
                            };
                    return {
                        id: e
                    }
                }
                async _syncPickups() {
                    const e = await WbSpaModel.prototype.$httpClient.fetchStaticDataV2("all-poo-v9.json.hash", 5e3, "text").catch((e => null));
                    if (null !== e)
                        if (e !== localStorage.getItem(a)) {
                            const t = await WbSpaModel.prototype.$httpClient.fetchStaticDataV2("all-poo-fr-v9.json", 6e4)
                              , r = null == t ? void 0 : t.selectMany((e => (e.items.forEach((t => {
                                t.country = e.country
                            }
                            )),
                            e.items)));
                            if (!(r && r.length || this.checkInterval))
                                return void setTimeout(this._syncPickups.bind(this), 15e3);
                            if ((!r || !r.length) && this.checkInterval)
                                return;
                            this.checkInterval || (this.checkInterval = setInterval(this._syncPickups.bind(this), o)),
                            this._openPickupDb().then((t => {
                                window._debug && console.time("transaction pickups");
                                let s = t.transaction([this._objectStoreName], "readwrite").objectStore(this._objectStoreName);
                                s.clear();
                                for (let e = 0; e < r.length; e++)
                                    s.add(r[e]);
                                window._debug && console.timeEnd("transaction pickups"),
                                localStorage.setItem(a, e)
                            }
                            ))
                        } else
                            this.checkInterval || (this.checkInterval = setInterval(this._syncPickups.bind(this), o));
                    else
                        this.checkInterval || setTimeout(this._syncPickups.bind(this), 15e3)
                }
                getPickupAsync(e) {
                    return this._openPickupDb().then((t => this.$storageHelper.getItem(t, this._objectStoreName, e)))
                }
                async getActivePickupsAsync(e={}) {
                    const [t,r] = await Promise.all([this._openPickupDb().then((e => this.$storageHelper.getAll(e, this._objectStoreName))), this.$auth.jwtData.user ? this.$services.userData.getUserDataAsync() : Promise.resolve({})]);
                    return [...this._filterPickups(t, null == r ? void 0 : r.userInfo, e)]
                }
                *_filterPickups(e, {isEmployeeSynced: t, houseKeeping: r, isPickupPointOwner: s}={}, n={}) {
                    for (const a of e) {
                        a.isHkn && !r || a.emp && !t || a.isSortCenter && !(s || t) || (null == n ? void 0 : n.dest) && a.dest3 != n.dest || "changeOffice" === (null == n ? void 0 : n.source) && (2 === a.status || a.isExternalPostamat || 31 == (null == a ? void 0 : a.typePoint)) || (yield a)
                    }
                }
                get removeUrl() {
                    return this.$services.cartService.publicBasketApiUrl + "/spa/removeaddress"
                }
                get editPooUrl() {
                    return this.$services.cartService.publicBasketApiUrl + "/spa/poos/create?version=1"
                }
                get editCourierAddressUrl() {
                    return this.$services.cartService.publicBasketApiUrl + "/spa/yandexaddress/editajax?version=2"
                }
                get deliveryPointsUrl() {
                    return this.$services.cartService.publicBasketApiUrl + "/spa/deliverypoints"
                }
                getDeliveryPointsAsync(e, t) {
                    return new Promise(( (r, s) => {
                        const n = Object.assign({
                            deliveryWay: e,
                            currency: WbSpaModel.prototype.$user.getCurrency()
                        }, t);
                        this.$httpClient.fetchJSON(this.deliveryPointsUrl, {
                            method: "POST",
                            body: this.$helper.objectSerializer(n),
                            credentials: "include"
                        }, {
                            timeout: 2e3
                        }).then((t => {
                            const s = this._updateDeliveryPoints(t, e);
                            r(s)
                        }
                        )).catch((t => {
                            console.log(t.message);
                            let s = this.restoreDeliveryPoints(e);
                            s && r(s)
                        }
                        ))
                    }
                    ))
                }
                _updateDeliveryPoints(e, t) {
                    const r = [...e, ...this.restoreDeliveryPoints(t).filter((e => e._local))].reduce(( (e, t) => {
                        const r = e.findIndex((e => e.addressId === t.addressId));
                        return -1 === r ? e.push(t) : e[r]._local = e[r]._local && t._local,
                        e
                    }
                    ), []);
                    return this.backupDeliveryPoints(r, t),
                    this._syncDeliveryPoints(r.filter((e => e._local)).reverse(), t),
                    r
                }
                async _syncDeliveryPoints(e, t) {
                    for (let r = 0; r < e.length; r++)
                        await this._saveAddressAsync(e[r], t)
                }
                get(e, t) {
                    var r;
                    const s = null == (r = this.restoreDeliveryPoints(t)) ? void 0 : r.find((t => t.addressId == e));
                    return s && s._local && this._syncDeliveryPoints([s], t),
                    s
                }
                getByCoordinates(e, t, r) {
                    return ["self", "courier"].forEach((s => {
                        var n;
                        const a = null == (n = this.restoreDeliveryPoints(s)) ? void 0 : n.find((s => s.lat == e && s.lon == t && s.address === r));
                        if (a && a._local && this._syncDeliveryPoints([a], s),
                        a)
                            return a
                    }
                    )),
                    null
                }
                get _key() {
                    const e = this.$services.sessionService.getUserUid();
                    return `${n}_${e}`
                }
                backupDeliveryPoints(e, t) {
                    this.deliveryPoints[t] = e;
                    const r = this._key;
                    localStorage.putObject(r, this.deliveryPoints),
                    Object.entries(localStorage).filter((e => e[0].startsWith(n) && e[0] !== r)).forEach((e => {
                        localStorage.removeItem(e[0])
                    }
                    ))
                }
                restoreDeliveryPoints(e) {
                    var t, r;
                    return this.deliveryPoints = null != (t = localStorage.getObject(this._key)) ? t : {},
                    this.deliveryPoints.self || (this.deliveryPoints.self = []),
                    this.deliveryPoints.courier || (this.deliveryPoints.courier = []),
                    [...this.deliveryPoints.courier, ...this.deliveryPoints.self].forEach((e => {
                        e.latitude && e.longitude || !e.lat || !e.lon || (e.latitude = e.lat,
                        e.longitude = e.lon)
                    }
                    )),
                    null != (r = this.deliveryPoints[e]) ? r : []
                }
                async add(e, t) {
                    let r = this.restoreDeliveryPoints(t);
                    const s = this._convertModel(e, t);
                    if (!r.find((e => (null == e ? void 0 : e.addressId) == s.addressId))) {
                        if ("courier" === t) {
                            const e = await WbSpaModel.prototype.$httpClient.fetchBasicJSON(`${l}get-office?latitude=${s.lat}&longitude=${s.lon}`, {}, {
                                timeout: 3e3,
                                nullOnError: !0
                            });
                            e && Object.assign(s, e)
                        }
                        r.unshift(s),
                        this.backupDeliveryPoints(r, t)
                    }
                    return this._saveAddressAsync(s, t),
                    r
                }
                remove(e, t) {
                    let r = this.restoreDeliveryPoints(t);
                    return r = r.filter((t => t.addressId != e)),
                    this.backupDeliveryPoints(r, t),
                    this._removeAddressAsync(e, t),
                    r
                }
                _removeAddressAsync(e, t) {
                    this.$httpClient.fetchJSON(this.removeUrl, {
                        method: "POST",
                        body: this.$helper.objectSerializer({
                            addressId: e,
                            deliveryWay: t
                        }),
                        credentials: "include"
                    }).then((e => {
                        this.backupDeliveryPoints(e, t)
                    }
                    ))
                }
                _saveAddressAsync(e, t) {
                    const r = "self" === t ? {
                        "Item.AddressId": e.addressId
                    } : e;
                    return this.$httpClient.fetchJSON(this._dataUrl(t), {
                        method: "POST",
                        credentials: "include",
                        body: this.$helper.objectSerializer(r, new URLSearchParams, !0)
                    }).then((e => (this.backupDeliveryPoints(e, t),
                    e)))
                }
                _dataUrl(e) {
                    return "self" === e ? this.editPooUrl : this.editCourierAddressUrl
                }
                _convertModel(e, t) {
                    if ("courier" === t) {
                        let r = Object.assign({}, e);
                        return r._local = !0,
                        r.deliveryType = t,
                        r.addressId = btoa(wb.helpers.generateGuid().slice(12)),
                        r.address = `${r.city ? r.city : r.province}, `,
                        r.area && !r.city && (r.address += `${r.area}, `),
                        r.street && (r.address += `${r.street}, `),
                        r.home && (r.address += `д. ${r.home}, `),
                        r.flat && !r.isPrivateHouse && (r.address += `кв. ${r.flat}, `),
                        r.entrance && (r.address += `под. ${r.entrance}, `),
                        r.doorCode && (r.address += `дмф. ${r.doorCode}, `),
                        r.floor && (r.address += `этаж ${r.floor}, `),
                        r.address = r.address.slice(0, -2),
                        r.lat || (r.lat = r.latitude),
                        r.lon || (r.lon = r.longitude),
                        r
                    }
                    if ("self" === t)
                        return {
                            _local: !0,
                            address: e.address,
                            addressId: e.id,
                            lat: e.coordinates[0],
                            lon: e.coordinates[1],
                            workTime: e.workTime,
                            deliveryType: t,
                            pointTypeName: this._getPointTypeName(e.dtype),
                            IsSortCenter: 63 === t,
                            status: e.status,
                            rate: e.rate,
                            deliveryPrice: $.views.helpers.priceFromRub(e.deliveryPrice, !0),
                            country: e.country,
                            dest: e.dest,
                            sign: e.sign
                        }
                }
                _getPointTypeName(e) {
                    switch (e) {
                    case 63:
                        return wb.i18n.t("userAddress.scWarehouse");
                    case 31:
                        return "Киоск";
                    default:
                        return wb.i18n.t("userAddress.pickUpPoint")
                    }
                }
            }
        },
        48586: function() {
            "use strict";
            var e = Object.defineProperty
              , t = Object.getOwnPropertySymbols
              , r = Object.prototype.hasOwnProperty
              , s = Object.prototype.propertyIsEnumerable
              , n = (t, r, s) => r in t ? e(t, r, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: s
            }) : t[r] = s
              , a = (e, a) => {
                for (var o in a || (a = {}))
                    r.call(a, o) && n(e, o, a[o]);
                if (t)
                    for (var o of t(a))
                        s.call(a, o) && n(e, o, a[o]);
                return e
            }
            ;
            class o {
                static getCookie(e) {
                    const t = document.cookie.split(";").find((t => {
                        const [r] = t.trim().split("=");
                        return r == e
                    }
                    ));
                    return t ? decodeURIComponent(t.trim().split("=")[1]) : null
                }
                static setCookie(e, t, r={}) {
                    r = a({
                        path: "/",
                        "max-age": 31536e3
                    }, r);
                    let s = encodeURIComponent(e) + "=" + encodeURIComponent(t);
                    Object.keys(r).forEach((e => {
                        s += `; ${e}`,
                        1 != r[e] && (s += `=${r[e]}`)
                    }
                    )),
                    document.cookie = s
                }
                static deleteCookie(e, t={}) {
                    o.setCookie(e, "", a({
                        "max-age": -1
                    }, t))
                }
            }
            wb.cookieHelper = o
        },
        71595: function(e, t, r) {
            "use strict";
            r.r(t),
            r.d(t, {
                Deferred: function() {
                    return k
                },
                animationFrameWithMinDelay: function() {
                    return A
                },
                base64: function() {
                    return D
                },
                currentCulture: function() {
                    return d
                },
                debounce: function() {
                    return m
                },
                debounceLead: function() {
                    return g
                },
                debounceTrail: function() {
                    return y
                },
                deepMerge: function() {
                    return p
                },
                deepMerge_v2: function() {
                    return h
                },
                delay: function() {
                    return I
                },
                delegator: function() {
                    return S
                },
                getClientDt: function() {
                    return P
                },
                isElementInViewport: function() {
                    return M
                },
                isMobileBrowser: function() {
                    return T
                },
                isNumber: function() {
                    return $
                },
                loadCssAsync: function() {
                    return B
                },
                loadJsAsync: function() {
                    return E
                },
                lockPromise: function() {
                    return w
                },
                nextTick: function() {
                    return _
                },
                objectSerializer: function() {
                    return c
                },
                once: function() {
                    return v
                },
                repeat: function() {
                    return f
                },
                serializeToFormData: function() {
                    return u
                },
                sleep: function() {
                    return C
                },
                throttle: function() {
                    return b
                }
            });
            r(48586),
            r(6127);
            function s(e) {
                return e < 26 ? e + 65 : e < 52 ? e + 71 : e < 62 ? e - 4 : 62 === e ? 43 : 63 === e ? 47 : 65
            }
            function n(e) {
                for (var t = 2, r = "", n = e.length, a = 0, o = 0; o < n; o++)
                    t = o % 3,
                    a |= e[o] << (16 >>> t & 24),
                    2 !== t && e.length - o != 1 || (r += String.fromCodePoint(s(a >>> 18 & 63), s(a >>> 12 & 63), s(a >>> 6 & 63), s(63 & a)),
                    a = 0);
                return r.substr(0, r.length - 2 + t) + (2 === t ? "" : 1 === t ? "=" : "==")
            }
            var a = class {
                static decode(e) {
                    return e ? function(e) {
                        for (var t, r = "", s = e.length, n = 0; n < s; n++)
                            t = e[n],
                            r += String.fromCodePoint(t > 251 && t < 254 && n + 5 < s ? 1073741824 * (t - 252) + (e[++n] - 128 << 24) + (e[++n] - 128 << 18) + (e[++n] - 128 << 12) + (e[++n] - 128 << 6) + e[++n] - 128 : t > 247 && t < 252 && n + 4 < s ? (t - 248 << 24) + (e[++n] - 128 << 18) + (e[++n] - 128 << 12) + (e[++n] - 128 << 6) + e[++n] - 128 : t > 239 && t < 248 && n + 3 < s ? (t - 240 << 18) + (e[++n] - 128 << 12) + (e[++n] - 128 << 6) + e[++n] - 128 : t > 223 && t < 240 && n + 2 < s ? (t - 224 << 12) + (e[++n] - 128 << 6) + e[++n] - 128 : t > 191 && t < 224 && n + 1 < s ? (t - 192 << 6) + e[++n] - 128 : t);
                        return r
                    }(function(e, t) {
                        for (var r, s, n, a = e.replace(/[^A-Za-z0-9\+\/]/g, ""), o = a.length, i = t ? Math.ceil((3 * o + 1 >> 2) / t) * t : 3 * o + 1 >> 2, l = new Uint8Array(i), c = 0, u = 0, d = 0; d < o; d++)
                            if (s = 3 & d,
                            c |= ((n = a.charCodeAt(d)) > 64 && n < 91 ? n - 65 : n > 96 && n < 123 ? n - 71 : n > 47 && n < 58 ? n + 4 : 43 === n ? 62 : 47 === n ? 63 : 0) << 6 * (3 - s),
                            3 === s || o - d == 1) {
                                for (r = 0; r < 3 && u < i; r++,
                                u++)
                                    l[u] = c >>> (16 >>> r & 24) & 255;
                                c = 0
                            }
                        return l
                    }(e)) : null
                }
                static encode(e) {
                    return e ? n(function(e) {
                        for (var t, r, s = e.length, n = 0, a = 0; a < s; a++)
                            (r = e.codePointAt(a)) > 65536 && a++,
                            n += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : r < 2097152 ? 4 : r < 67108864 ? 5 : 6;
                        t = new Uint8Array(n);
                        for (var o = 0, i = 0; o < n; i++)
                            (r = e.codePointAt(i)) < 128 ? t[o++] = r : r < 2048 ? (t[o++] = 192 + (r >>> 6),
                            t[o++] = 128 + (63 & r)) : r < 65536 ? (t[o++] = 224 + (r >>> 12),
                            t[o++] = 128 + (r >>> 6 & 63),
                            t[o++] = 128 + (63 & r)) : r < 2097152 ? (t[o++] = 240 + (r >>> 18),
                            t[o++] = 128 + (r >>> 12 & 63),
                            t[o++] = 128 + (r >>> 6 & 63),
                            t[o++] = 128 + (63 & r),
                            i++) : r < 67108864 ? (t[o++] = 248 + (r >>> 24),
                            t[o++] = 128 + (r >>> 18 & 63),
                            t[o++] = 128 + (r >>> 12 & 63),
                            t[o++] = 128 + (r >>> 6 & 63),
                            t[o++] = 128 + (63 & r),
                            i++) : (t[o++] = 252 + (r >>> 30),
                            t[o++] = 128 + (r >>> 24 & 63),
                            t[o++] = 128 + (r >>> 18 & 63),
                            t[o++] = 128 + (r >>> 12 & 63),
                            t[o++] = 128 + (r >>> 6 & 63),
                            t[o++] = 128 + (63 & r),
                            i++);
                        return t
                    }(e)) : ""
                }
                static encodeBytesArr(e) {
                    return n(e)
                }
            }
            ;
            const o = {
                cache: {},
                onFirstExecution() {
                    0 === Object.keys(this.cache).length && document.querySelectorAll("script[type='text/javascript']").forEach((e => {
                        "" !== e.src && (this.cache[e.src.replace(/https?:/, "")] = Promise.resolve())
                    }
                    ))
                },
                require(e) {
                    let t = this.cache[e];
                    return null == t && (this.onFirstExecution(),
                    t = this.cache[e],
                    null == t && (t = this.cache[e] = l(e, this.loadScriptAsync))),
                    t.catch((t => (this.cache[e] = null,
                    Promise.reject(t))))
                },
                loadScriptAsync(e) {
                    return new Promise(( (t, r) => {
                        try {
                            const s = document.createElement("script");
                            s.type = "text/javascript",
                            s.src = e,
                            s.readyState ? s.onreadystatechange = function() {
                                "loaded" !== s.readyState && "complete" !== s.readyState || (s.onreadystatechange = null,
                                t())
                            }
                            : s.onload = t,
                            s.onerror = r,
                            document.body.appendChild(s)
                        } catch (e) {
                            r(e)
                        }
                    }
                    ))
                }
            }
              , i = {
                cashe: {},
                orinalStylesIncluded: !1,
                require(e) {
                    return new Promise(( (t, r) => {
                        this.orinalStylesIncluded || this.addOrinalStyles(),
                        null == this.cashe[e] && (this.cashe[e] = l(e, this.loadCssAsync)),
                        this.cashe[e].then(t).catch((t => {
                            this.cashe[e] = null,
                            r(t)
                        }
                        ))
                    }
                    ))
                },
                addOrinalStyles() {
                    this.orinalStylesIncluded = !0,
                    document.querySelectorAll("link[type='text/css']").forEach((e => this.cashe[e.href.replace(/https?:/, "")] = Promise.resolve()))
                },
                loadCssAsync(e) {
                    return new Promise(( (t, r) => {
                        let s;
                        if (navigator.userAgent.indexOf("MSIE ") > 0 || navigator.userAgent.indexOf("Trident/") > 0) {
                            const n = document.createElement("link");
                            n.href = e,
                            n.type = "text/css",
                            n.rel = "stylesheet",
                            n.onload = t,
                            n.onerror = r,
                            s = n
                        } else {
                            const n = document.createElement("style");
                            n.onload = t,
                            n.textContent = `@import "${e}"`,
                            n.onload = t,
                            n.onerror = r,
                            s = n
                        }
                        document.querySelector("head").appendChild(s)
                    }
                    ))
                }
            };
            async function l(e, t) {
                return new Promise(( (r, s) => {
                    t(e).then((e => r())).catch((s => t(wb.helpers.url.urlSiteStatic(e, !0)).then((e => r()))))
                }
                ))
            }
            function c(e, t=new URLSearchParams, r=!1, s=!1) {
                const n = (e, a) => {
                    s && "boolean" == typeof a ? t.append(e, a.toString()) : "object" == typeof a && null != a ? Object.entries(a).forEach(( ([r,s]) => {
                        n(`${e}[${r}]`, s, t)
                    }
                    )) : r && null == a || t.append(e, a)
                }
                ;
                return Object.entries(e).forEach(( ([e,t]) => n(e, t))),
                t
            }
            function u(e, t=new FormData) {
                const r = (e, s="") => {
                    for (let n in e) {
                        const a = e[n];
                        let o = n;
                        s && (o = Array.isArray(e) ? `${s}[${n}]` : `${s}.${n}`),
                        "boolean" == typeof a ? t.append(o, a.toString()) : "string" == typeof a || "number" == typeof a ? t.append(o, a) : "object" == typeof a && r(a, o)
                    }
                }
                ;
                return r(e),
                t
            }
            const d = function() {
                const e = wb.cookieHelper.getCookie(".AspNetCore.Culture");
                if (e) {
                    const t = e.match(/^c=([a-z]{2})(-[A-Z]{2})?\|uic=([a-z]{2})(-[A-Z]{2})?$/);
                    if (t)
                        return t[1]
                }
                return document.documentElement.getAttribute("lang")
            }();
            function p() {
                let e = arguments[0]
                  , t = t => {
                    for (let r in t)
                        t.hasOwnProperty(r) && ("[object Object]" === Object.prototype.toString.call(t[r]) && null != e[r] ? e[r] = p(e[r], t[r]) : e[r] = t[r])
                }
                ;
                for (let e = 1; e < arguments.length; e++)
                    t(arguments[e]);
                return e
            }
            function h() {
                let e = arguments[0]
                  , t = t => {
                    for (let r in t)
                        t.hasOwnProperty(r) && ("[object Object]" === Object.prototype.toString.call(t[r]) && null != e[r] ? e[r] = h(e[r], t[r]) : void 0 !== t[r] && (e[r] = t[r]))
                }
                ;
                for (let e = 1; e < arguments.length; e++)
                    t(arguments[e]);
                return e
            }
            const m = (e, t) => {
                let r = null;
                return (...s) => {
                    r && clearTimeout(r),
                    r = setTimeout(( () => {
                        e.apply(void 0, s),
                        r = null
                    }
                    ), t)
                }
            }
              , g = (e, t=300) => {
                let r;
                return function(...s) {
                    r || e.apply(this, s),
                    clearTimeout(r),
                    r = setTimeout(( () => r = null), t)
                }
            }
              , y = (e, t=300) => {
                let r;
                return function(...s) {
                    clearTimeout(r),
                    r = setTimeout(( () => {
                        e.apply(this, s)
                    }
                    ), t)
                }
            }
              , b = (e, t) => {
                let r, s, n = !1;
                return function a() {
                    if (n)
                        return r = arguments,
                        void (s = this);
                    e.apply(this, arguments),
                    n = !0,
                    setTimeout((function() {
                        n = !1,
                        r && (a.apply(s, r),
                        r = s = null)
                    }
                    ), t)
                }
            }
              , f = (e, t, r, s) => {
                let n = 0
                  , a = setInterval((function() {
                    if (n > t)
                        return clearInterval(a),
                        void (s && s());
                    e(a) && clearInterval(a),
                    n++
                }
                ), r);
                return a
            }
              , v = e => {
                let t;
                return function() {
                    return v.done || (t = e.apply(this, arguments),
                    v.done = !0),
                    t
                }
            }
              , w = e => {
                let t = null;
                return function() {
                    return t || (t = e.apply(this, arguments).then((e => e)).finally(( () => t = null))),
                    t
                }
            }
              , S = (e, t) => function(r) {
                const s = r.target.closest(e);
                null != s && t(r, s)
            }
              , _ = () => Promise.resolve().then(( () => Promise.resolve()))
              , C = e => new Promise((t => setTimeout(t, e)))
              , I = (e, t) => new Promise(( (r, s) => setTimeout((e => {
                try {
                    t() && r()
                } catch (e) {
                    s(e)
                }
            }
            ), e)));
            function M(e, t, r) {
                var s;
                const n = e.getBoundingClientRect();
                return r && (r.threshold = null != (s = r.threshold) ? s : 10,
                $(r.top)) ? n.top >= r.top - r.threshold && n.top <= r.top + r.threshold : n.top >= 0 && (t || n.left >= 0) && n.bottom <= (window.innerHeight || document.documentElement.clientHeight) && (t || n.right <= (window.innerWidth || document.documentElement.clientWidth))
            }
            function k() {
                this.promise = new Promise(( (e, t) => {
                    this.reject = t,
                    this.resolve = e
                }
                )),
                this.then = this.promise.then.bind(this.promise)
            }
            function P() {
                const e = new Date
                  , t = new Date(e.getTime() - 6e4 * e.getTimezoneOffset()).toISOString();
                return t.slice(0, t.length - 1)
            }
            function T() {
                if (void 0 !== window._isMobileBrowser)
                    return window._isMobileBrowser;
                let e = !1;
                var t;
                return t = navigator.userAgent || navigator.vendor || window.opera,
                (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0),
                window._isMobileBrowser = e,
                window._isMobileBrowser
            }
            function $(e) {
                return !isNaN(parseFloat(e)) && isFinite(e)
            }
            function A(e, t) {
                const r = performance.now()
                  , s = () => performance.now() - r > e ? t() : window.requestAnimationFrame(s);
                window.requestAnimationFrame(s)
            }
            const D = a
              , E = o.require.bind(o)
              , B = i.require.bind(i)
        },
        28043: function() {
            "use strict";
            class e extends Error {
                constructor(t) {
                    const {message: r, payload: s} = e.parsePayload(t);
                    super(r),
                    this.isCustomError = !0,
                    this.payload = s
                }
                static parsePayload(e) {
                    var t;
                    return "string" == typeof e ? {
                        message: e,
                        payload: null
                    } : {
                        message: null != (t = null == e ? void 0 : e.message) ? t : "Unknow error",
                        payload: null == e ? void 0 : e.payload
                    }
                }
            }
            Object.defineProperties(window, {
                KnownServerError: {
                    value: e
                },
                UnauthorizeError: {
                    value: class extends e {
                        constructor({msg: e, jwtDrop: t}={}) {
                            super(e),
                            this.isUnauthorize = !0,
                            this.jwtDrop = t
                        }
                    }
                },
                CancelledRequestError: {
                    value: class extends e {
                        constructor(e="") {
                            super(e),
                            this.isCancelled = !0
                        }
                    }
                },
                NotFoundError: {
                    value: class extends e {
                        constructor(e="") {
                            super(e),
                            this.isNotFound = !0
                        }
                    }
                },
                NetworkError: {
                    value: class {
                        constructor() {
                            this.isNetworkError = !0
                        }
                    }
                }
            })
        },
        6127: function() {
            "use strict";
            class e {
                static canShowWalletDiscount(e=0, t="", r=0, s=0, n=0) {
                    if (1048576 & r || 0 === s)
                        return !1;
                    return (n || (wb.settings.walletTypeCode > 1 ? wb.global.settings.variables.wlt2DiscountDisplayMaxPrice : wb.global.settings.variables.wlt1DiscountDisplayMaxPrice)) >= e && "RUB" === t
                }
                static calcWalletDiscount(t=0, r="", s=0, n=0, a=0) {
                    const o = n || (wb.settings.walletTypeCode > 1 ? wb.settings.wlt2DiscountPercent : wb.settings.wlt1DiscountPercent);
                    if (o > 0) {
                        const n = e.calculateDiscount(t, o, r);
                        if (e.canShowWalletDiscount(t - n, r, s, o, a))
                            return n
                    }
                    return 0
                }
                static calculateDiscount(e=0, t=0, r="", s=!1) {
                    if (!e || !t)
                        return 0;
                    let n = e * (t / 100);
                    return this.toLocalPrice(n, r, s)
                }
                static calculateCommission(e, t, r="") {
                    return this.calculateDiscount(e, t, r, !0)
                }
                static calculateAdjustedDiscount(e=0, t=0, r=0, s="") {
                    if (!t || !r)
                        return 0;
                    let n = e / t * r;
                    return this.toLocalPrice(n, s)
                }
                static toLocalPrice(e=0, t="", r=!1) {
                    if (0 !== e) {
                        const s = $.views.helpers.minFiscalPriceInCurrency(t);
                        e = e < s ? s : Math[r ? "floor" : "ceil"](e / s) * s
                    }
                    return e
                }
                static calculateCustomCharges(e, t, r) {
                    const s = 100 * e;
                    if (!r)
                        return 0;
                    if (s < r.dutyFreelimit)
                        return 0;
                    const n = .15 * (s - r.dutyFreelimit) + r.fixedAmount;
                    return $.views.helpers.toLocalPrice(n / 100, t)
                }
                static getReturnableVatPercent(e) {
                    return !!e && (!!wb.xnm.isVatRefundable(e) && wb.xnm.getVatPercent(e))
                }
            }
            wb.priceHelper = e
        },
        10003: function(e, t, r) {
            "use strict";
            r.d(t, {
                A: function() {
                    return S
                }
            });
            var s = r(33036)
              , n = JSON.parse('{"RUB":{"locale":"ru","name":"Российский рубль","sign":"₽","code":"643"},"BYN":{"locale":"by","name":"Белорусский рубль","sign":"р.","code":"933"},"KZT":{"locale":"kz","name":"Казахстанский тенге","sign":"тг.","code":"398"},"AMD":{"locale":"am","name":"Армянский драм","sign":"драм","code":"051"},"KGS":{"locale":"kg","name":"Кыргызский сом","sign":"сом","code":"417"},"UZS":{"locale":"uz","name":"Узбекский сум","sign":"сум","code":"860"},"TJS":{"locale":"tj","name":"Таджикский сомони","sign":"с.","code":"972"}}');
            const a = Object.entries(n).reduce(( (e, [t,r]) => (e[r.sign] = t,
            e)), {});
            wb.currencies = {
                info: n,
                getIsoBySign: e => a[e] || wb.settings.currencyCodeByLetters,
                getDefaultForLocale: function(e) {
                    let t;
                    for (const r in n)
                        n[r].locale === e && (t = r);
                    return null != t ? t : "RUB"
                },
                localeWithCoins: ["BYN", "TJS", "byn", "tjs"]
            },
            $.views.helpers({
                wbCurrencies: wb.currencies.info,
                getIsoCode: function(e) {
                    var t;
                    return null == (t = wb.currencies.info[null == e ? void 0 : e.toUpperCase()] || wb.currencies.info[wb.settings.currencyCodeByLetters]) ? void 0 : t.code
                }
            }),
            $.views.converters({
                isoCode: e => {
                    var t;
                    return null == (t = wb.currencies.info[null == e ? void 0 : e.toUpperCase()] || wb.currencies.info[wb.settings.currencyCodeByLetters]) ? void 0 : t.code
                }
                ,
                currencySign: e => {
                    var t;
                    return null == (t = wb.currencies.info[e] || wb.currencies.info[wb.settings.currencyCodeByLetters]) ? void 0 : t.sign
                }
            });
            var o = Object.defineProperty
              , i = Object.defineProperties
              , l = Object.getOwnPropertyDescriptors
              , c = Object.getOwnPropertySymbols
              , u = Object.prototype.hasOwnProperty
              , d = Object.prototype.propertyIsEnumerable
              , p = (e, t, r) => t in e ? o(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }) : e[t] = r
              , h = (e, t) => {
                for (var r in t || (t = {}))
                    u.call(t, r) && p(e, r, t[r]);
                if (c)
                    for (var r of c(t))
                        d.call(t, r) && p(e, r, t[r]);
                return e
            }
              , m = (e, t) => i(e, l(t));
            const g = "_sys_auth"
              , y = "user-balance"
              , b = s.of
              , f = ["65896095", "6182663", "8175888", "16474491", "126051733", "112501232", "13539779", "15800639", "60152764", "27921069", "20432466", "7127629", "146311557", "124235485", "11253735", "19089801", "153164239", "151251536", "152733644", "151839264", "151581324", "157878042", "180073193", "157878042", "157922000", "158757427", "159245498", "180322273", "180086213", "180073193", "153865697", "180986891", "181306249", "151234692", "186198155", "186198155", "186199515", "191493705"]
              , v = class e {
                constructor() {
                    var t;
                    for (const t in e.syncData)
                        e.syncData[t].init();
                    this.balance = localStorage.getObject(e.storageKey(y)),
                    this.balance && (this._savedBalance = Object.assign(this.balance)),
                    this._balanceTs = (null == (t = this.balance) ? void 0 : t.balanceTs) || 0,
                    this.getUserGrade = WbSpaModel.prototype.$helper.lockPromise(this.getUserGrade),
                    this.getCustomsDuty = WbSpaModel.prototype.$helper.lockPromise(this.getCustomsDuty),
                    window.addEventListener("storage", this._onSync.bind(this))
                }
                getUid() {
                    return e._getUserUid()
                }
                getId() {
                    return WbSpaModel.prototype.$auth.jwtData.user || 0
                }
                getUserInfo() {
                    return this.userInfo
                }
                initUser() {
                    const t = this.$auth.jwtData
                      , r = this.$auth.isAuth
                      , s = this.$services.sessionService.getBasketUid()
                      , n = r ? e._getUserUid() : "";
                    localStorage.setItem(g, r ? t.user : "unauth"),
                    this.userInfo = r ? {
                        uid: n,
                        basketUid: void 0,
                        isAuth: r,
                        t: t.user
                    } : {
                        uid: 0,
                        basketUid: s,
                        isAuth: r
                    },
                    wb.analitics.sendUserEvent(n, r ? t.user : ""),
                    wb.analitics.sendSessionStartEvent(),
                    r ? this.getUserGrade(this.getCurrency()) : this._setDiscountForUnAuth(),
                    wb.spa && wb.spa.setUserStatus({
                        userIsAuth: r,
                        userUid: r ? n : s,
                        userId: parseInt(t.user, 10)
                    })
                }
                async getBalance({force: t, timeout: r}={}) {
                    var s, n;
                    let a = !1;
                    if (t || (null == (s = this._savedBalance) ? void 0 : s.balanceCurrency) && this._savedBalance.balanceCurrency !== this.getCurrency() || !this.balance || this._balanceTs < (new Date).getTime()) {
                        this._balanceTs = (new Date).getTime() + 3e4;
                        try {
                            this.balance = await this.$httpClient.fetchJSON("/webapi/account/getsignedbalance", {
                                method: "POST"
                            }, r ? {
                                timeout: r
                            } : {}),
                            this.balance.balanceCurrency = this.getCurrency(),
                            this.balance.walletTypeCode = this._getWalletTypeCode(this.balance.walletType, this.balance.walletStatus),
                            this._savedBalance = Object.assign(this.balance),
                            this.balance.balanceTs = this._balanceTs,
                            localStorage.putObject(e.storageKey(y), this.balance),
                            a = !0
                        } catch (e) {
                            if (!this._savedBalance)
                                throw this._balanceTs = (new Date).getTime() + 15e3,
                                e;
                            this.balance = Object.assign(this._savedBalance)
                        }
                    }
                    if (null === this.balance)
                        return {
                            walletLimit: 0,
                            moneyBalanceRUB: 0,
                            walletBalance: 0,
                            totalBalanceRub: 0,
                            totalBalance: 0,
                            balanceCurrency: this.getCurrency()
                        };
                    const o = null != (n = this.balance[`moneyBalance${this.balance.balanceCurrency}`]) ? n : "RUB" === this.balance.balanceCurrency ? this.balance.moneyBalance : 0;
                    return this.balance.totalBalance = o + ("RUB" === this.balance.balanceCurrency ? this.balance.bonusBalance + this.balance.walletBalance : 0),
                    "RUB" === this.balance.balanceCurrency && (this.balance.totalBalance = Math.floor(Math.abs(this.balance.totalBalance) < 1 ? 0 : this.balance.totalBalance)),
                    this.balance.totalBalanceRub = (this.balance.moneyBalanceRUB || 0) + (this.balance.bonusBalance || 0) + (this.balance.walletBalance || 0),
                    this.balance.totalBalanceRub = Math.floor(Math.abs(this.balance.totalBalanceRub) < 1 ? 0 : this.balance.totalBalanceRub),
                    a && this.$eventBus.dispatchEvent(new CustomEvent("BalanceUpdated",{
                        detail: this.balance
                    })),
                    this.balance
                }
                _getWalletTypeCode(e="", t="") {
                    return "rejected" === t || "closed" === t ? 0 : "verified" === e ? 2 : "anonymous" === e ? 1 : 0
                }
                resetBalance() {
                    this.balance = null,
                    this.$eventBus.dispatchEvent(new CustomEvent("BalanceReset"))
                }
                async getBrokerInstallmentConfig() {
                    if (!this.isBrokerInstEnabled() || "ru" !== wb.settings.currentLocale)
                        return null;
                    if (this.brokerInstallmentConfig)
                        return this.brokerInstallmentConfig;
                    if (this.brokerInstallmentConfig = localStorage.getObject("wbx_br_inst_config"),
                    !this.brokerInstallmentConfig || this.brokerInstallmentConfig.expire < Date.now())
                        try {
                            const e = await this.$wbxHttpClient.fetch(`${b}/v1/config`, {
                                method: "GET",
                                timeout: 1e3
                            })
                              , t = await e.json();
                            t.expire = Date.now() + 36e5,
                            localStorage.putObject("wbx_br_inst_config", t),
                            this.brokerInstallmentConfig = t
                        } catch (e) {
                            wb.spa.logError(e, "[WBX_BR_INST_CONFIG]: failed to fetch broker installment config")
                        }
                    return this.brokerInstallmentConfig
                }
                resetBrokerInstStatusTs() {
                    this._resetBrokerInstStatusTs = !0
                }
                isBrokerInstEnabled() {
                    var e, t, r;
                    return this.$isRangeEnabledFor(null == (r = null == (t = null == (e = wb.global) ? void 0 : e.settings) ? void 0 : t.variables) ? void 0 : r.cwbInstRange) || f.indexOf(this.$auth.jwtData.user) > -1
                }
                async getBrokerInstallmentStatus(e=!1) {
                    if (!this.isBrokerInstEnabled() || "ru" !== wb.settings.currentLocale)
                        return null;
                    if (e && this.resetBrokerInstStatusTs(),
                    this._brokerInstStatusTs = this._resetBrokerInstStatusTs ? 0 : Date.now() + 3e5,
                    !this.brokerInstallmentStatus || this._brokerInstStatusTs < Date.now())
                        try {
                            const e = await this.$wbxHttpClient.fetch(`${b}/v1/status`, {
                                method: "GET",
                                credentials: "include",
                                timeout: 1e3
                            });
                            this.brokerInstallmentStatus = await e.json(),
                            ["186199515"].includes(this.$auth.jwtData.user) && (this.brokerInstallmentStatus = {
                                maxInstallmentSum: 15e5,
                                status: "completed",
                                availableSum: 15e5
                            }),
                            this._resetBrokerInstStatusTs = !1
                        } catch (e) {
                            this.brokerInstallmentStatus = null
                        }
                    return this.brokerInstallmentStatus
                }
                async getUserGrade(e="RUB") {
                    var t, r, s;
                    if (!this.$auth.isAuth)
                        return null;
                    let n = this._userGrade || localStorage.getObject("wbx_user_grade");
                    this.$auth.jwtData.user !== (null == n ? void 0 : n.user_id) && (n = null);
                    const a = this.$useCatalogReturnCost() ? 4 : 3;
                    if (null == n || n.expire < Date.now() || this.$auth.jwtData.user !== n.user_id || n.currency !== e || n.version != a)
                        try {
                            const o = await this.$wbxHttpClient.fetch(`https://user-grade.wildberries.ru/api/v${a}/grade?curr=${e}`);
                            if (!o.ok)
                                throw new Error(`resp_status=${o.status}`);
                            const i = await o.json();
                            if (null == i.payload || 0 !== i.state)
                                throw new Error(`resp_data=${JSON.stringify(i || {})}`);
                            n = i.payload,
                            n.sign = i.sign,
                            n.sign_version = i.sign_version,
                            n.expire = Date.now() + 3e5,
                            n.fraud && (null == (t = JSON.parse(n.fraud)) ? void 0 : t.is_trust) ? (n.premiumIsAvailable = !0,
                            n.wbClub = "available") : n.premiumIsAvailable = !1,
                            (null == (r = n.subscription_features) ? void 0 : r.length) && (n.wbClub = "subscribed"),
                            n.isPremium = (null == (s = n.subscription_features) ? void 0 : s.indexOf("extra_discount")) > -1,
                            localStorage.putObject("wbx_user_grade", n),
                            this._userGrade = n,
                            this.$eventBus.dispatchEvent(new CustomEvent("UserGradeUpdated"))
                        } catch (e) {
                            wb.spa.logError(e, "[WBX_USER_GRADE]: failed to fetch user grade data")
                        }
                    if (null == n ? void 0 : n.payments) {
                        const e = n.payments.find((e => 1 === e.wctype_id));
                        wb.settings.wlt1DiscountPercent = n.isPremium && (null == e ? void 0 : e.wb_club_anonymous_discount) > 0 ? e.wb_club_anonymous_discount : (null == e ? void 0 : e.anonymous_discount) || 0,
                        wb.settings.wlt2DiscountPercent = n.isPremium && (null == e ? void 0 : e.wb_club_uprid_discount) > 0 ? e.wb_club_uprid_discount : (null == e ? void 0 : e.uprid_discount) || 0;
                        let t = (null == e ? void 0 : e.wb_club_anonymous_discount) - (null == e ? void 0 : e.anonymous_discount)
                          , r = (null == e ? void 0 : e.wb_club_uprid_discount) - (null == e ? void 0 : e.uprid_discount);
                        wb.settings.premium1DiscountPercent = t > 0 ? t : 0,
                        wb.settings.premium2DiscountPercent = r > 0 ? r : 0,
                        wb.settings.premium1DiscountPercentFull = null == e ? void 0 : e.wb_club_anonymous_discount,
                        wb.settings.premium2DiscountPercentFull = null == e ? void 0 : e.wb_club_uprid_discount
                    }
                    return n || {
                        spp: 0,
                        postpaid_limit: 0,
                        currency: e
                    }
                }
                getUserGradeFromCache() {
                    return this.$auth.isAuth ? this._userGrade || localStorage.getObject("wbx_user_grade") : null
                }
                resetUserGrade() {
                    const e = this.getUserGradeFromCache();
                    e && (e.expire = 0,
                    localStorage.putObject("wbx_user_grade", e))
                }
                async _setDiscountForUnAuth() {
                    var e;
                    let t = localStorage.getObject("wbx_default_discounts");
                    if (null == t || t.expire < Date.now()) {
                        const r = await this.$httpClient.fetchStaticV3(wb.helpers.url.urlStaticBasket, {}, "global-payment/default-payment.json", 1);
                        if (0 === (null == r ? void 0 : r.state)) {
                            const s = null == (e = r.data) ? void 0 : e.find((e => 1 === e.wctype_id));
                            t = {
                                wctype_id: null == s ? void 0 : s.wctype_id,
                                discount_value: (null == s ? void 0 : s.discount_value) || 0,
                                expire: Date.now() + 3e5
                            },
                            t.expire = Date.now() + 3e5,
                            localStorage.putObject("wbx_default_discounts", t)
                        }
                    }
                    wb.settings.wlt1DiscountPercent = (null == t ? void 0 : t.discount_value) || wb.global.settings.variables.wlt1DiscountPercent
                }
                async getCustomsDuty(e) {
                    var t, r, s;
                    if (!(null == (r = null == (t = wb.global.settings) ? void 0 : t.switches) ? void 0 : r.enableCustomsDuty))
                        return null;
                    let n = this._customsData || localStorage.getObject("customs_duty");
                    try {
                        if (!n || !n.dutyForImportedGoods || n.dutyForImportedGoods.find((e => new Date(1e3 * e.timestamp).addDays(1) < new Date))) {
                            const e = await this.$httpClient.fetchStaticV3(wb.helpers.url.urlStaticBasket, {
                                timeout: 500
                            }, "duty/duty.json", 44).catch((e => (wb.spa.logError(e, "[CUSTOMS_DUTY]: failed to fetch customs duty data"),
                            this._customsData)));
                            e && (localStorage.putObject("customs_duty", e),
                            this._customsData = n = e)
                        }
                        return null == (s = null == n ? void 0 : n.dutyForImportedGoods) ? void 0 : s.find((t => t.curr == e))
                    } catch (e) {
                        return wb.spa.logError(e, "[CUSTOMS_DUTY]: customs duty exception"),
                        null
                    }
                }
                getCustomsDutyFromCache() {
                    return this._customsData || localStorage.getObject("customs_duty")
                }
                reset() {
                    this.resetUserGrade(),
                    wb.cookieHelper.deleteCookie("access_token"),
                    this.initUser(),
                    this.resetBalance(),
                    this.clearXInfo(),
                    this.$services.userData.clear(),
                    this.$getService("groupedDeliveriesService").then((e => e.resetCache()))
                }
                clearLocalUserData() {
                    this.$services.userData.clearLocalUserInfo(),
                    localStorage.removeItem(e.storageKey(y)),
                    localStorage.removeItem("offerRateMain")
                }
                static _getUserUid() {
                    return WbSpaModel.prototype.$auth.um.userUid || "0"
                }
                async _getUserData() {
                    return e.syncData.userData.time <= Date.now() && !e.syncData.userData.updateInProgress && await this._xInfoUpdate(),
                    e.syncData.userData.data
                }
                get geoDataStorageKey() {
                    return e.storageKey(e.syncData.userData.prefix)
                }
                static storageKey(t) {
                    return `${t}-${e._getUserUid()}`
                }
                async _xInfoUpdate() {
                    const t = e.syncData.userData;
                    wb.settings.b2bMode ? t.data.xinfo += "&b2b=true" : t.data.xinfo = t.data.xinfo.replace("&b2b=true", ""),
                    t.updateInProgress = !0;
                    const r = e.storageKey(t.prefix);
                    await navigator.locks.request(`lock-${r}`, (async s => {
                        var n;
                        const a = e.syncData.userData;
                        if (!a || a.time < Date.now()) {
                            const e = null == t ? void 0 : t.data;
                            let s = new URLSearchParams;
                            (null == e ? void 0 : e.currency) && s.set("currency", e.currency),
                            e && (s.set("latitude", e.latitude),
                            s.set("longitude", e.longitude),
                            s.set("locale", e.locale),
                            s.set("address", e.address),
                            s.set("dt", e.dt || "0"),
                            e.addressId && s.set("addressId", e.addressId),
                            e.addressType && s.set("addressType", e.addressType));
                            const a = t.fetchParam.url(s)
                              , o = await WbSpaModel.prototype.$httpClient.fetchBasicJSON(a, {
                                credentials: "include"
                            }, {
                                timeout: t.fetchParam.timeout,
                                nullOnError: !0,
                                addAuthHeader: !0
                            });
                            if (o) {
                                const e = null == (n = localStorage.getObject(r)) ? void 0 : n.data
                                  , s = {
                                    time: Date.now() + t.interval,
                                    data: h(h({}, e), o)
                                };
                                localStorage.putObject(r, s),
                                Object.assign(t, s),
                                this._checkForRefresh(e, o)
                            } else
                                e.time = Date.now() + 1e4
                        } else
                            a && a.time !== t.time && Object.assign(t, a);
                        t.updateInProgress = !1
                    }
                    ))
                }
                getXinfo() {
                    return this._getUserData().then((e => Promise.resolve(e.xinfo)))
                }
                getXinfoWithClustersAndVectors(t) {
                    return this._checkNeedUpdateData(e.syncData.userClusters),
                    this._checkNeedUpdateData(e.syncData.userVector),
                    this._getUserData().then((r => {
                        var s, n;
                        let a = e.syncData.userClusters.data.length > 0 ? r.xinfo + `&uclusters=${e.syncData.userClusters.data.join(",")}` : r.xinfo;
                        if ((wb.global.settings.switches.addUserVector && "search" === t || wb.global.settings.switches.addUserVectorCatalog && "catalog" === t || wb.global.settings.switches.addUserVectorRecommend && "new_recom" === t) && (null == (n = null == (s = e.syncData.userVector) ? void 0 : s.data[t]) ? void 0 : n.value)) {
                            const r = e.syncData.userVector.data[t];
                            a += `&uv=${r.value}&uiv=${r.version}`
                        }
                        return Promise.resolve(a)
                    }
                    ))
                }
                getUserClusters() {
                    return this._checkNeedUpdateData(e.syncData.userClusters),
                    e.syncData.userClusters.data.join(",")
                }
                getBannersClusters() {
                    return this._checkNeedUpdateData(e.syncData.userClustersBanners),
                    e.syncData.userClustersBanners.data.length > 0 ? e.syncData.userClustersBanners.data : []
                }
                getXinfoSignedV1() {
                    return this._getUserData().then((e => {
                        var t;
                        return Promise.resolve({
                            xinfo: e.xinfo,
                            userDataSign: e.userDataSign,
                            addressDataSign: e.addressDataSign,
                            shard: e.shard,
                            latitude: e.latitude,
                            longitude: e.longitude,
                            address: e.address,
                            dest: null == (t = e.destinations) ? void 0 : t.last(),
                            addressId: e.addressId
                        })
                    }
                    ))
                }
                async getLocationData() {
                    const e = await this._getUserData();
                    return {
                        latitude: e.latitude,
                        longitude: e.longitude,
                        address: e.address,
                        destinations: e.destinations,
                        locale: e.locale
                    }
                }
                async setGeo(t) {
                    var r, s, n;
                    const a = null != (r = t.lat) ? r : t.latitude
                      , o = null != (s = t.lon) ? s : t.longitude
                      , i = t.address;
                    if (a && o && i) {
                        const r = e.syncData.userData
                          , s = e.storageKey(r.prefix);
                        const l = `officeId=${"self" === t.deliveryType ? t.addressId : t.officeId}&dest=${t.dest}&sign=${t.sign}&lat=${a}&lng=${o}`
                          , c = m(h(h({}, null == r ? void 0 : r.data), null == (n = localStorage.getObject(s)) ? void 0 : n.data), {
                            latitude: a,
                            longitude: o,
                            address: i,
                            addressId: t.addressId,
                            addressType: t.deliveryType,
                            addressDataSign: l,
                            dt: Date.now() / 1e3 | 0,
                            relevant: !1
                        });
                        c.xinfo = this._changeXDest(c.xinfo, t.dest);
                        const u = {
                            data: c,
                            time: e._timeInPast(r.interval)
                        };
                        Object.assign(r, u),
                        localStorage.putObject(s, u),
                        WbSpaModel.prototype.$geoLocation.setCityName(i),
                        await this._xInfoUpdate()
                    }
                }
                async setCurrency(t) {
                    var r;
                    if (t) {
                        const s = e.syncData.userData
                          , n = e.storageKey(s.prefix)
                          , a = m(h(h({}, null == s ? void 0 : s.data), null == (r = localStorage.getObject(n)) ? void 0 : r.data), {
                            currency: t,
                            relevant: !1
                        });
                        a.xinfo = this._changeXCurrency(a.xinfo, t),
                        Object.assign(s, {
                            data: a,
                            time: e._timeInPast(s.interval)
                        }),
                        await this._xInfoUpdate()
                    }
                }
                clearXInfo() {
                    for (const t in e.syncData)
                        e.syncData[t].time = e._timeInPast(e.syncData[t].interval);
                    Object.keys(localStorage).forEach((t => {
                        for (const r in e.syncData)
                            -1 !== t.indexOf(e.syncData[r].prefix) && localStorage.removeItem(t)
                    }
                    ))
                }
                clearUserVectors() {
                    e.syncData.userVector.time = e._timeInPast(e.syncData.userVector.interval),
                    Object.keys(localStorage).forEach((t => {
                        -1 !== t.indexOf(e.syncData.userVector.prefix) && localStorage.removeItem(t)
                    }
                    ))
                }
                async getShardAsync() {
                    return (await this._getUserData()).shard
                }
                getIp() {
                    return e.syncData.userData.data.ip
                }
                getCurrency() {
                    return e.syncData.userData.data.currency
                }
                async getCurrencyAsync() {
                    return (await this._getUserData()).currency
                }
                getLocale() {
                    return e.syncData.userData.data.locale
                }
                getDest() {
                    var t;
                    return null == (t = e.syncData.userData.data.destinations) ? void 0 : t.last()
                }
                _changeXCurrency(e, t) {
                    const r = `$1${t.toLowerCase()}$3`;
                    return e.replace(/(&curr=)(.*?)(&)/, r)
                }
                _changeXDest(e, t) {
                    const r = `$1${t}$3`;
                    return e.replace(/(&dest=)(.*?)(&)/, r)
                }
                static getXCurrency(e) {
                    var t;
                    return null == (t = /curr=(.*?)&/.exec(e)) ? void 0 : t[1]
                }
                _checkForRefresh(t, r, s) {
                    var n, a, o, i, l, c, u, d;
                    let p = !1;
                    (null == t ? void 0 : t.currency) !== (null == r ? void 0 : r.currency) && (e._checkCurrencyInvalid(r) && location.reload(),
                    null == (n = wb.spa.getMainLayout().header) || n.changeCurrency.refresh(r.currency),
                    p = !0),
                    (null == t ? void 0 : t.destinations[t.destinations.length - 1]) !== (null == r ? void 0 : r.destinations[r.destinations.length - 1]) && (p = !0),
                    (null == r ? void 0 : r.address) && (null == (a = WbSpaModel.prototype.$geoLocation.location) ? void 0 : a.address) !== (null == r ? void 0 : r.address) && WbSpaModel.prototype.$geoLocation.updateLocation(),
                    p && (this.$eventBus.dispatchEvent(new CustomEvent("GeoUpdated")),
                    null == (l = null == (i = null == (o = wb.spa) ? void 0 : o.getMainLayout()) ? void 0 : i.menuTop) || l.refreshMenu((null == t ? void 0 : t.locale) !== (null == r ? void 0 : r.locale)),
                    this.$router.clearNotActiveContainer(),
                    (s || WbSpaModel.prototype.$router.currentRoute && "SpaBasketEntrypoint" !== (null == (c = WbSpaModel.prototype.$router.currentRoute) ? void 0 : c.name) && "SpaBasketBuyItNowEntrypoint" !== (null == (u = WbSpaModel.prototype.$router.currentRoute) ? void 0 : u.name)) && (null == (d = wb.spa) || d.refresh()))
                }
                _onSync({key: t, oldValue: r, newValue: s}) {
                    if (t === g && s)
                        r !== s && (s && "unauth" !== s && !this.$auth.isAuth ? wb.spa.getMainLayout().updateAfterLogin() : location.reload());
                    else if (t === e.storageKey(e.syncData.userData.prefix)) {
                        if (s) {
                            const t = JSON.parse(r)
                              , n = JSON.parse(s);
                            Object.assign(e.syncData.userData, n),
                            setTimeout(( () => this._checkForRefresh(null == t ? void 0 : t.data, n.data, !0)), 1e3)
                        }
                    } else
                        for (const r in e.syncData)
                            if (t === e.storageKey(e.syncData[r].prefix)) {
                                const t = JSON.parse(s);
                                Object.assign(e.syncData[r], t)
                            }
                }
                static _getFallbackData() {
                    const t = e._getDefaultLocale()
                      , r = e._getDefaultCurrency(t);
                    let s;
                    switch (t) {
                    case "ru":
                        s = {
                            xinfo: `appType=1&curr=${r.toLowerCase()}&dest=-1257786&locale=${t}&spp=30&lang=${WbSpaModel.prototype.$helper.currentCulture}`,
                            address: "Москва",
                            latitude: 55.753737,
                            longitude: 37.6201,
                            currency: r,
                            destinations: [-1029256, -102269, -2162196, -1257786]
                        };
                        break;
                    case "by":
                        s = {
                            xinfo: `appType=1&curr=${r.toLowerCase()}&dest=-8139704&locale=${t}&spp=30&lang=${WbSpaModel.prototype.$helper.currentCulture}`,
                            address: "Минск",
                            latitude: 53.901328,
                            longitude: 27.549044,
                            currency: r,
                            destinations: [12358386, 12358403, -70563, -8139704]
                        };
                        break;
                    case "kz":
                        s = {
                            xinfo: `appType=1&curr=${r.toLowerCase()}&dest=85&locale=${t}&spp=30&lang=${WbSpaModel.prototype.$helper.currentCulture}`,
                            address: "Нур-Султан",
                            latitude: 51.129669,
                            longitude: 71.495475,
                            currency: r,
                            destinations: [12358388, 12358412, -3479876, 85]
                        };
                        break;
                    case "kg":
                        s = {
                            xinfo: `appType=1&curr=${r.toLowerCase()}&dest=28&locale=${t}&spp=30&lang=${WbSpaModel.prototype.$helper.currentCulture}`,
                            address: "Бишкек",
                            latitude: 42.8618,
                            longitude: 74.5831,
                            currency: r,
                            destinations: [12358387, 12358395, -10860151, 28]
                        };
                        break;
                    case "am":
                        s = {
                            xinfo: `appType=1&curr=${r.toLowerCase()}&dest=36&locale=${t}&spp=30&lang=${WbSpaModel.prototype.$helper.currentCulture}`,
                            address: "Ереван",
                            latitude: 40.177628,
                            longitude: 44.512547,
                            currency: r,
                            destinations: [12358387, 12358400, -13404218, 36]
                        };
                        break;
                    case "uz":
                        s = {
                            xinfo: `appType=1&curr=${r.toLowerCase()}&dest=491&locale=${t}&spp=30&lang=${WbSpaModel.prototype.$helper.currentCulture}`,
                            address: "Ташкент",
                            latitude: 41.311158,
                            longitude: 69.279737,
                            currency: r,
                            destinations: [12358390, 12358442, -2448072, 491]
                        };
                        break;
                    case "tj":
                        s = {
                            xinfo: `appType=1&curr=${r.toLowerCase()}&dest=-1257786&locale=${t}&spp=30&lang=${WbSpaModel.prototype.$helper.currentCulture}`,
                            address: "Душанбе",
                            latitude: 38.576271,
                            longitude: 68.779716,
                            currency: r,
                            destinations: [-1029256, -102269, -2162196, -1257786]
                        }
                    }
                    return s.locale = t,
                    s.shard = 0,
                    s
                }
                static _getDefaultCurrency(e) {
                    const t = localStorage.getItem("wbx__currency")
                      , r = wb.currencies.info[t];
                    return t && localStorage.removeItem("wbx__currency"),
                    r ? t : wb.currencies.getDefaultForLocale(e)
                }
                static _getDefaultLocale() {
                    switch (document.location.hostname) {
                    case "www.wildberries.by":
                        return "by";
                    case "www.wildberries.kz":
                        return "kz";
                    case "www.wildberries.kg":
                        return "kg";
                    case "www.wildberries.am":
                        return "am";
                    case "www.wildberries.uz":
                    case "uz.wildberries.ru":
                        return "uz";
                    case "www.wildberries.tj":
                        return "tj"
                    }
                    return "ru"
                }
                static _timeInPast(e) {
                    return Date.now() - e
                }
                static _checkCurrencyInvalid(t) {
                    var r;
                    return !t || !wb.currencies.info[t.currency] || !wb.currencies.info[null == (r = e.getXCurrency(t.xinfo)) ? void 0 : r.toUpperCase()]
                }
                _checkNeedUpdateData(t) {
                    if (t.time >= Date.now() || t.updateInProgress)
                        return;
                    t.updateInProgress = !0;
                    const r = e.storageKey(t.prefix);
                    navigator.locks.request(`lock-${r}`, (async s => {
                        const n = localStorage.getObject(r);
                        if (!n || n.time < Date.now()) {
                            let s;
                            if ("0" !== e._getUserUid())
                                if (t.disableFetch && await t.disableFetch())
                                    s = [];
                                else {
                                    const r = t.fetchParam.url(e._getUserUid())
                                      , n = await WbSpaModel.prototype.$httpClient.fetchBasicJSON(r, {
                                        credentials: "omit"
                                    }, {
                                        timeout: t.fetchParam.timeout,
                                        nullOnError: !0,
                                        addAuthHeader: t.fetchParam.jwt
                                    });
                                    s = t.processData(n)
                                }
                            else
                                s = [];
                            if (s) {
                                const e = {
                                    time: Date.now() + t.interval,
                                    data: s
                                };
                                localStorage.putObject(r, e),
                                Object.assign(t, e)
                            } else
                                t.time = Date.now() - t.interval + 6e4
                        } else
                            n && n.time !== t.time && Object.assign(t, n);
                        t.updateInProgress = !1
                    }
                    ))
                }
            }
            ;
            var w;
            p(v, "symbol" != typeof (w = "syncData") ? w + "" : w, {
                userData: {
                    prefix: "geo-data-v1",
                    data: null,
                    interval: 18e4,
                    fetchParam: {
                        url: e => `${s.Ho}get-geo-info?${e}`,
                        timeout: 3e3
                    },
                    init: function() {
                        const e = {
                            data: v._getFallbackData(),
                            time: v._timeInPast(Date.now())
                        }
                          , t = localStorage.getObject(v.storageKey(this.prefix));
                        (null == t ? void 0 : t.data) && v._checkCurrencyInvalid(t.data) && (t.time = v._timeInPast(this.interval)),
                        Object.assign(this, h(h({}, e), t))
                    }
                },
                userClusters: {
                    prefix: "user-clusters",
                    data: null,
                    processData: function(e) {
                        return this.fetchParam.dataField ? e[this.fetchParam.dataField] : e
                    },
                    interval: 432e5,
                    fetchParam: {
                        url: e => `https://personal-clusters.wildberries.ru/api/v1/clusters?id=${e}`,
                        dataField: "uclusters",
                        timeout: 2e4
                    },
                    init: function() {
                        Object.assign(this, h(h({}, {
                            data: [],
                            time: v._timeInPast(this.interval)
                        }), localStorage.getObject(v.storageKey(this.prefix))))
                    }
                },
                userClustersBanners: {
                    prefix: "user-clusters-banners",
                    data: null,
                    processData: function(e) {
                        return this.fetchParam.dataField ? e[this.fetchParam.dataField] : e
                    },
                    interval: 432e5,
                    fetchParam: {
                        url: e => `https://user-banner.wb.ru/api/v1/clusters?id=${e}`,
                        timeout: 2e4
                    },
                    init: function() {
                        Object.assign(this, h(h({}, {
                            data: [],
                            time: v._timeInPast(this.interval)
                        }), localStorage.getObject(v.storageKey(this.prefix))))
                    }
                },
                userVector: {
                    prefix: "user-vector",
                    data: null,
                    processData: function(e) {
                        var t;
                        return e ? null == (t = e.data[0]) ? void 0 : t.vectors.reduce(( (e, t) => (e[t.space] = {
                            value: t.value,
                            version: t.version
                        },
                        e)), {}) : this.data
                    },
                    interval: 432e5,
                    fetchParam: {
                        url: () => "https://user-vector-info.wb.ru/api/v1/vector",
                        timeout: 2e4,
                        jwt: !0
                    },
                    init: function() {
                        Object.assign(this, h(h({}, {
                            data: [],
                            time: v._timeInPast(this.interval)
                        }), localStorage.getObject(v.storageKey(this.prefix))))
                    },
                    disableFetch: async function() {
                        const e = await WbSpaModel.prototype.$services.userData.getUserDataAsync();
                        return !e || !e.userInfo.enableUserVectors
                    }
                }
            });
            var S = v
        },
        30311: function() {
            "use strict";
            window.wb = {
                namespace: function(e, t) {
                    for (var r = e.split("."), s = this, n = r.length, a = 0; a < n; a++)
                        void 0 === s[r[a]] && (s[r[a]] = t && a === n - 1 ? t : {}),
                        s = s[r[a]];
                    return s
                },
                getURLparam: function(e) {
                    return (RegExp("[\\?&]" + e + "=([^&#]*)", "i").exec(location.href) || [, null])[1]
                }
            },
            $.processResponse = function(e, t, r, s) {
                var n;
                if (null == e)
                    return !1;
                let a = void 0 !== e.ResultState ? e.ResultState : e.resultState;
                switch (e.hasOwnProperty("resultState") || e.hasOwnProperty("ResultState") || (a = e.state),
                a) {
                case -1:
                    const o = e.Value || e.value || (null == (n = e.data) ? void 0 : n.errorMsg) || "Ошибка сервера";
                    if ("boolean" == $.type(r)) {
                        r && wb.popup.renderModalError(o);
                        break
                    }
                    null != r ? r(o) : alert(o);
                    break;
                case 0:
                    if (null == t)
                        return !1;
                    t(e.Value || e.value);
                    break;
                case 1:
                    window.location.href = e.Value || e.value;
                    break;
                case 2:
                case 4:
                    if (4 === a && wb.spa) {
                        wb.spa.refresh();
                        break
                    }
                    let i = window.location.href;
                    const l = i.indexOf("#");
                    -1 !== l && (i = i.substr(0, l)),
                    null != e.Value || null != e.value ? (window.location.href = i + (e.Value || e.value),
                    window.location.reload()) : window.location.href = i;
                    break;
                case 3:
                    const c = e.Value || e.value;
                    if (null == wb.spa)
                        return window.location.href = c.url;
                    const u = new URL(decodeURIComponent(c.url),window.location.origin);
                    c.redirect = !0,
                    null == s || s(c),
                    wb.spa.redirect(u.href, c.replaceState, c.forceUpdate)
                }
                return !0
            }
            ,
            wb.quickNav = function(e) {
                var t = e || {}
                  , r = document.querySelector(".j-quicknav");
                r.addEventListener("click", (function() {
                    return window.scrollTo({
                        top: 0,
                        behavior: "smooth"
                    }),
                    !1
                }
                ));
                let s;
                function n() {
                    r.style.display = "block"
                }
                function a() {
                    r.style.display = "none"
                }
                window.addEventListener("scroll", (function() {
                    if (r) {
                        document.documentElement.clientWidth >= 768 ? function() {
                            const e = t.bottomPx || function() {
                                const e = document.querySelector("#app");
                                return e ? e.offsetTop + parseFloat(getComputedStyle(e, null).height.replace("px", "")) : 0
                            }();
                            (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0) > e ? n() : a()
                        }() : function() {
                            const e = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
                            s || (s = e),
                            function() {
                                if (e >= s)
                                    return !1;
                                const t = document.documentElement.clientHeight;
                                return !(e < 1.5 * t)
                            }() ? n() : a(),
                            s = e
                        }()
                    }
                }
                ))
            }
            ,
            wb.namespace("utils.script", function() {
                var e = {};
                function t(e) {
                    var t = $("html").attr("lang");
                    if ("ru" == t)
                        return Promise.resolve();
                    var r = e.substring(e.lastIndexOf("/") + 1).replace(".min.js", ".js").split("?");
                    return fetch("j/localized/" + r[0] + "?v=" + r[1] + "&c=" + t)
                }
                return {
                    require: function(r, s) {
                        var n, a = e[r];
                        return a || ($.isEmptyObject(e) && document.querySelectorAll("script[type='text/javascript']").forEach((function(t) {
                            if (t.type) {
                                var r = t.src.replace("http:", "").replace("https:", "");
                                e[r] = Promise.resolve()
                            }
                        }
                        )),
                        e[r] || (a = Promise.all([s ? t(r) : Promise.resolve(), (n = r,
                        new Promise(( (e, t) => {
                            try {
                                var r = document.createElement("script");
                                r.type = "text/javascript",
                                r.src = n,
                                r.readyState ? r.onreadystatechange = function() {
                                    "loaded" !== r.readyState && "complete" !== r.readyState || (r.onreadystatechange = null,
                                    e())
                                }
                                : (r.onload = function() {
                                    e()
                                }
                                ,
                                r.onerror = function() {
                                    t()
                                }
                                ),
                                document.body.appendChild(r)
                            } catch (e) {
                                t()
                            }
                        }
                        )))]),
                        e[r] = a)),
                        a
                    }
                }
            }()),
            wb.namespace("displayModeSettings", function() {
                const e = "displayMode";
                let t;
                var r = new Map;
                return {
                    init: function() {
                        function r() {
                            const r = wb.settings.breakponts
                              , s = window.innerWidth;
                            for (var n in t = "d",
                            r)
                                s < n && (t = r[n]);
                            let a = "desktop";
                            s <= 767.98 && (a = "phone"),
                            s >= 768 && s <= 1023.98 && (a = "tablet"),
                            $.observable(wb.settings).setProperty(e, t),
                            $.observable(wb.settings).setProperty({
                                displayType: a
                            })
                        }
                        r(),
                        window.addEventListener("resize", r)
                    },
                    addObserver: function(s, n) {
                        if ("function" == typeof s) {
                            n && s(t);
                            var a = () => s(t);
                            $.observe(wb.settings, e, a),
                            $.observe(wb.settings, "displayType", a),
                            r.set(s, a)
                        }
                    },
                    removeObserver: function(t) {
                        let s = r.get(t);
                        s && ($.unobserve(wb.settings, e, s),
                        $.unobserve(wb.settings, "displayType", s))
                    }
                }
            }()),
            wb.namespace("network", function() {
                return {
                    init: function() {
                        function e() {
                            $.observable(wb.settings).setProperty("isOffline", !window.navigator.onLine)
                        }
                        e(),
                        window.addEventListener("online", e),
                        window.addEventListener("offline", e)
                    }
                }
            }())
        },
        24623: function() {
            "use strict";
            var e, t, r, s;
            wb.stat = function() {
                let e, t = [];
                function r() {
                    const e = t;
                    return t = [],
                    e
                }
                function s() {
                    if (!t.length || window._debug)
                        return;
                    const s = r()
                      , n = {};
                    n.pageViewGuid = e,
                    n.path = window.location.pathname,
                    n.queryString = window.location.search,
                    n.urlReferrer = null != wb.spa ? wb.spa.getReferrer() : document.referrer,
                    n.deviceId = wb.cookieHelper.getCookie("_wbauid"),
                    n.statisticEvents = s,
                    WbSpaModel.prototype.$httpClient.fetch("/webapi/stats/events", {
                        method: "POST",
                        body: JSON.stringify(n),
                        headers: {
                            "Content-Type": "application/json"
                        }
                    }).catch((e => {
                        t = t.concat(s)
                    }
                    ))
                }
                return setInterval((function() {
                    s()
                }
                ), 3e3),
                {
                    sendEvent: function(e, r, n) {
                        const a = r.slice();
                        t.push({
                            EventName: e,
                            EventParams: a
                        }),
                        n && s()
                    },
                    wrapParam: function(e, t) {
                        return {
                            ParamName: e,
                            ParamValue: void 0 === t ? null : t.toString().replace(/"/g, "\\x22")
                        }
                    },
                    sendPageView: function() {
                        if (window._debug)
                            return;
                        const s = {};
                        let n;
                        s.statusCode = 200,
                        s.path = window.location.pathname,
                        s.queryString = window.location.search,
                        s.urlReferrer = document.referrer,
                        s.deviceId = wb.cookieHelper.getCookie("_wbauid"),
                        t.length > 0 && (n = r(),
                        s.statisticEvents = n),
                        WbSpaModel.prototype.$user.getLocationData().then((e => (e && (s.address = e.address,
                        s.latitude = e.latitude,
                        s.longitude = e.longitude),
                        WbSpaModel.prototype.$httpClient.fetch("/webapi/stats/pageview", {
                            method: "POST",
                            body: JSON.stringify(s),
                            headers: {
                                "Content-Type": "application/json"
                            }
                        })))).then((e => e.json())).then((t => {
                            e = t
                        }
                        )).catch((e => {
                            t = t.concat(n)
                        }
                        ))
                    }
                }
            }(),
            wb.stat.banners = function() {
                const e = {
                    ths: this,
                    cl: {
                        banner: "j-banner"
                    }
                };
                e.sl = {
                    shownStat: ".j-banner-shown-stat",
                    clickStat: ".j-banner-click-stat",
                    banner: "." + e.cl.banner
                };
                const t = function(e) {
                    const t = []
                      , r = e.data("banner-id")
                      , s = e.data("section")
                      , n = e.data("statistic-fields");
                    return "" === r ? null : (t.push(wb.stat.wrapParam("BID", r)),
                    t.push(wb.stat.wrapParam("SCTN", s)),
                    n && (t.push(wb.stat.wrapParam("BUT", n.urlType)),
                    t.push(wb.stat.wrapParam("BLT", n.locationType)),
                    t.push(wb.stat.wrapParam("BDT", n.displayType)),
                    t.push(wb.stat.wrapParam("SORT", n.sort))),
                    t)
                }
                  , r = function(e) {
                    e instanceof jQuery || (e = $(e));
                    if (e.data("shown-stat-sent"))
                        return;
                    const r = t(e);
                    if (!r)
                        return;
                    const s = e[0].classList.contains("j-banner-stat-send");
                    wb.stat.sendEvent("BSE", r, s),
                    e.attr("data-shown-stat-sent", !0)
                };
                var s = function(e, r) {
                    var s, n;
                    if ((null == e ? void 0 : e.length) > 0) {
                        const t = e[0];
                        if (t.classList.contains("j-banner-wba")) {
                            let {data: e} = $.view(t);
                            e = e.length > 0 ? e[0] : e,
                            e.banner && (e = e.banner);
                            const r = !!e.ordBannerMark
                              , n = (null == (s = e.bannerSelections) ? void 0 : s.length) > 0 ? e.bannerSelections.map((e => e.href)).toString() : e.link;
                            wb.analitics.sendBannersWbaEvent("Banner_T", e.alt, t.dataset.analiticsCode, n, t.dataset.bannerIndex, e.id, r)
                        }
                    }
                    r || (e.data("click-stat-sent") || (n = t(e)) && (wb.stat.sendEvent("BCE", n, !0),
                    e.attr("data-click-stat-sent", !0)))
                };
                return {
                    initClickEvent: function(t) {
                        $("body").off("mousedown", e.sl.clickStat).on("mousedown", e.sl.clickStat, (function(r) {
                            if (3 !== r.which) {
                                var n, a = r.currentTarget.classList.contains(e.cl.banner), o = $(r.currentTarget);
                                a || (n = $this.data("banner-id"),
                                o = $(e.sl.banner).filter((function(e, t) {
                                    return $(t).data("banner-id") === n
                                }
                                )).first()),
                                s(o, t)
                            }
                        }
                        ))
                    },
                    sendShownStatistic: r,
                    sendAllShownStatistic: function() {
                        var t = $(e.sl.shownStat);
                        wb.scrollListener.addElements(t, (function(e) {
                            r($(e))
                        }
                        ), !1, .6),
                        wb.scrollListener.start()
                    },
                    sendStatisticNow: function() {
                        $.each($(e.sl.shownStat), (function(e, t) {
                            wb.stat.banners.sendShownStatistic($(t))
                        }
                        ))
                    },
                    sendShownCarousel: function(e) {
                        var t;
                        t = e.find("li:not(.jc-clone)").find(".j-banner"),
                        $.each(t, (function(e, t) {
                            wb.stat.banners.sendShownStatistic($(t))
                        }
                        ))
                    },
                    callShownVisibleHandlerForCarousel: function(e, t) {
                        var r;
                        r = e.find("li").find(".j-banner:not(.j-banner-section)"),
                        wb.scrollListener.addElements(r, (function(e) {
                            wb.stat.banners.sendShownStatistic($(e))
                        }
                        ), !1, t),
                        wb.scrollListener.start()
                    },
                    getShownAfterSetActiveEvent: function(e) {
                        return function(t) {
                            var r = t.find(".j-banner").first();
                            wb.scrollListener.checkRatio(r, e) && wb.stat.banners.sendShownStatistic(r)
                        }
                    },
                    sendClickStatistic: s,
                    destroyClickEvent: function() {
                        $("body").off("mousedown", e.sl.clickStat)
                    },
                    bannerBlockShownStatWba: function(e) {
                        const t = function(e) {
                            if (!e)
                                return;
                            const t = document.querySelectorAll(".j-banners-block")
                              , r = [];
                            function s(t) {
                                const s = t.querySelectorAll(".j-banner-wba").toArray()
                                  , n = e.$observerHelper.getVerticalObserver(s, {
                                    threshold: .5
                                });
                                function a(t) {
                                    const r = t.target;
                                    let {data: s} = $.view(r);
                                    const o = !!s.ordBannerMark;
                                    e.$analitic.sendBannersWbaEvent("Banner_S", r.title, r.dataset.analiticsCode, r.href, r.dataset.bannerIndex, r.dataset.bannerId, o, s.pixelSrc),
                                    e.$stat.banners.sendShownStatistic(r),
                                    r.removeEventListener(n.elementInViewportEventName, a)
                                }
                                r.push(n),
                                s.forEach((e => {
                                    e.addEventListener(n.elementInViewportEventName, a)
                                }
                                )),
                                n.observe()
                            }
                            return t.forEach((e => {
                                s(e)
                            }
                            )),
                            {
                                destroy: function() {
                                    r.forEach((e => {
                                        e.destroy()
                                    }
                                    ))
                                },
                                addBlocks: function(e) {
                                    (null == e ? void 0 : e.length) && e.filter((e => e.classList.contains("j-banners-block"))).forEach((e => {
                                        s(e)
                                    }
                                    ))
                                }
                            }
                        }(e);
                        return {
                            destroy: function() {
                                t.destroy()
                            },
                            addBlocks: function(e) {
                                t.addBlocks(e)
                            }
                        }
                    }
                }
            }(),
            function() {
                var e = document.createElement("a");
                if (e.href = document.referrer,
                function(e) {
                    let t = !0;
                    return ["wb.", "wildberries."].forEach((function(r) {
                        e.indexOf(r) >= 0 && -1 === $.inArray(e.split(".")[0], ["style", "blog", "lookshop"]) && (t = !1)
                    }
                    )),
                    t
                }(e.hostname)) {
                    var t = wb.helpers.getParamsFromUrlQuery(location.search)
                      , r = wb.stat
                      , s = [];
                    e.hostname || t.utm_medium || t.utm_campaign || t.utm_source ? (s.push(r.wrapParam("UTMM", t.utm_medium ? t.utm_medium : "not_set")),
                    s.push(r.wrapParam("UTMC", t.utm_campaign ? t.utm_campaign : "not_set")),
                    s.push(r.wrapParam("UTMS", t.utm_source ? t.utm_source : e.hostname ? e.hostname : "not_set")),
                    t.gclid && s.push(r.wrapParam("GCID", "adwords")),
                    e.hostname && s.push(r.wrapParam("Rfr", e.hostname))) : s.push(r.wrapParam("Rfr", "direct")),
                    wb.stat.sendEvent("RFR", s)
                }
            }(),
            e = wb.getURLparam("wb_tp"),
            t = wb.getURLparam("wb_bnd"),
            r = wb.stat,
            s = [],
            e && t && (s.push(r.wrapParam("Btp", e)),
            s.push(r.wrapParam("Bbnd", t)),
            r.sendEvent("BV", s))
        },
        59060: function() {
            "use strict";
            $.observable.Object.prototype.setAllProperty = function(e, t) {
                var r = this;
                $.each(e, (function(e, s) {
                    var n = e;
                    t && (n = t + "." + n),
                    $.isPlainObject(s) ? r.setAllProperty(s, n) : !$.isArray(s) && r.setProperty(n, s)
                }
                ))
            }
            ,
            $.observable.Array.prototype.refreshArray = function(e) {
                for (var t = this, r = 0; r < e.length; r++)
                    t._data.length === r ? t.insert(e[r]) : $.observable(t._data[r]).setProperty(e[r]);
                for (; e.length < t._data.length; )
                    t.remove(t._data.length - 1)
            }
            ,
            $.views.helpers({
                suppliersOrgForms: ["ООО", "ПАО", "ОАО", "ЗАО", "ИП", "Фонд", "Ассоциации", "Союзы", "НАО", "ТОО", "АО"],
                isDefaultSupplier: function(e, t) {
                    return 32477 === e || 12399 === e || 17887 === e || 23316 === e || 28906 === e || "Brands Seller" === t || "Best Brands" === t || "First Choice" === t || "WILDBERRIES" === t
                },
                supplierFineName: function(e, t) {
                    return 20624 === t ? "" : 1876 === t && "Wildberries" === e ? "Brands Seller" : 20253 === t && "Wildberries" === e ? "Best Brands" : 154 === t && "Wildberries" === e ? "First Choice" : "Wildberries" === e ? "WILDBERRIES" : $.views.converters.trimWord(e, $.views.helpers.suppliersOrgForms)
                },
                ImageUrl: wb.helpers.url.imageUrl,
                ImageUrlPb: function() {
                    return wb.helpers.url.imageUrl(arguments[0], null == arguments ? void 0 : arguments[1], null == arguments ? void 0 : arguments[2], null == arguments ? void 0 : arguments[3], null == arguments ? void 0 : arguments[4], !0)
                },
                urlFeedbackPhoto: wb.helpers.url.urlFeedbackPhoto,
                urlProductVideo: wb.helpers.url.urlVideoProduct,
                urlFeedbackVideo: wb.helpers.url.urlFeedbackVideo,
                productCardUrl: function(e, t, r) {
                    return $.views.converters.urlForGood(e, null, r, null, null, t)
                },
                forBrandLogoFromId: function(e, t) {
                    return e ? wb.helpers.url.urlStaticBasket(`sellers/brands/${e}.webp`, 1, t) : $.views.converters.urlSiteStatic("i/nologo.gif")
                },
                forSellerLogo: function(e, t=!1) {
                    return $.views.helpers.forSellerLogoPb(e, t, !1)
                },
                forSellerLogoPb: function(e, t=!1, r=!0) {
                    return wb.helpers.url.urlStaticBasket(`crm-bnrs/shops/${e}_${t ? "main_banner" : "logo"}.webp`, 1, r)
                },
                isEmptyObject: function(e) {
                    return $.isEmptyObject(e)
                },
                Declension: function(e, t, r, s, n) {
                    var a, o = e % 10, i = e % 100;
                    return a = 1 == o && 11 != i ? t : 2 == o && 12 != i || 3 == o && 13 != i || 4 == o && 14 != i ? r : s || r,
                    void 0 === n ? a : String.format(n, e, String.format(a, e))
                },
                pluralize: function(e) {
                    return $.pluralize(null != e ? e : 0, Array.prototype.slice.call(arguments, 1))
                },
                debug: function(e) {
                    console.log(e)
                },
                toDateFormat: function(e, t) {
                    return new Date(parseInt(e.replace("/Date(", "").replace(")\\/", ""), 10)).format(t)
                },
                formatDate: function(e, t) {
                    return new Date(e).format(t)
                },
                toJson: function(e) {
                    return JSON.stringify(e)
                },
                fromJson: function(e) {
                    return JSON.parse(e)
                },
                encode: function() {
                    for (var e = "", t = 0; t < arguments.length; t++)
                        e = e.concat(arguments[t]);
                    return encodeURIComponent(e)
                },
                isLazyImgInCarousel: function(e, t, r, s, n) {
                    return !0 === e && (!0 === r ? t >= 2 * s && t < n - s : t >= 2 * s)
                },
                timeLeft: function(e) {
                    var t = $.views.helpers.parseFromDotNet(e);
                    return wb.helpers.date.leftBefore(t)
                },
                parseFromDotNet: function(e) {
                    return new Date(parseInt(e.replace("/Date(", "").replace(")\\/", ""), 10))
                },
                timeLeftSpa: function(e) {
                    var t = new Date(e);
                    return wb.helpers.date.leftBefore(t)
                },
                isPriceEqual: function(e, t) {
                    return e === t
                },
                isNullOrWhiteSpace: function(e) {
                    return !e || 0 === e.length || /^\s*$/.test(e)
                },
                HasFlag: function(e, t) {
                    return (e & t) == t
                },
                blurAdult: function(e) {
                    return e && !wb.adult.isConfirmed
                },
                nonBreakingSpaceFormatted: function(e) {
                    return String(e).replace(/\B(?=(\d{3})+(?!\d))/g, "&nbsp;")
                },
                pickupType: function(e, t) {
                    if (86 == e.dtype)
                        return e.name;
                    if (31 == (null == e ? void 0 : e.typePoint))
                        return "Киоск";
                    if ("courier" == e.deliveryType)
                        return "Курьерский адрес";
                    if (63 == e.dtype || e.isSortCenter)
                        return t ? "СЦ / Склад" : "СЦ / Склад Wildberries";
                    if (29 == e.dtype || 31 == e.dtype || 32 == e.dtype)
                        return t ? "Почта" : "Отделение Почты";
                    if (23 == e.dtype)
                        return 2 == e.pickupType ? "Партнерский&nbsp;пункт выдачи (Почта&nbsp;России)" : t ? "Почта&nbsp;России" : "Отделение Почты России";
                    if (14 == e.dtype)
                        return "Постамат Халва";
                    if (15 == e.dtype && e.pickupType >= 0) {
                        if (1 == e.pickupType)
                            return "Отделение&nbsp;Сбербанка";
                        if (0 == e.pickupType)
                            return "Постамат&nbsp;Сбербанка"
                    }
                    return 16 == e.dtype ? "Постамат&nbsp;Пятерочка" : e.isExternalPostamat ? "Партнерский&nbsp;постамат" : e.isWb ? "Пункт выдачи" : "Партнерский&nbsp;пункт выдачи"
                },
                pickupPhotos: e => {
                    var t, r;
                    if (!e.photos)
                        return [];
                    if (86 == e.dtype)
                        return e.photos;
                    const s = new Set
                      , n = new Set;
                    for (let t of e.photos) {
                        const e = t.split(".").pop();
                        t = t.replace("preview", ""),
                        "webp" == (null == e ? void 0 : e.toLowerCase()) ? s.add(t) : n.add(t)
                    }
                    return [...s.size > 0 && (null == (r = null == (t = WbSpaModel.prototype) ? void 0 : t.$apiSupport) ? void 0 : r.webpImage) ? s : n]
                }
                ,
                priceFromRub: (e, t, r) => {
                    var s, n;
                    if (!(null == (n = null == (s = wb.global) ? void 0 : s.settings) ? void 0 : n.currencies))
                        return e;
                    const a = r || WbSpaModel.prototype.$user.getCurrency();
                    if ("RUB" === a)
                        return e;
                    if (!wb.global.settings.currencies[a])
                        return e;
                    let o = e / wb.global.settings.currencies[a].rubRate;
                    return t ? "AMD" === a || "KZT" === a ? 10 * Math.floor(o / 10) : "BYN" === a ? Math.floor(100 * o) / 100 : "UZS" === a ? 100 * Math.floor(o / 100) : Math.floor(o) : o
                }
                ,
                priceToRub: (e, t) => {
                    var r, s;
                    return (null == (s = null == (r = wb.global) ? void 0 : r.settings) ? void 0 : s.currencies) && wb.global.settings.currencies[t] ? e * wb.global.settings.currencies[t].rubRate : e
                }
                ,
                toLocalPrice: (e, t) => "AMD" === t || "KZT" === t ? 10 * Math.floor(e / 10) : "BYN" === t ? Math.floor(100 * e) / 100 : "UZS" === t ? 100 * Math.floor(e / 100) : Math.floor(e),
                max: e => Math.max(e, 0),
                abs: e => Math.abs(e),
                trimWord: function(e, t) {
                    if (!(null == t ? void 0 : t.length) || !e)
                        return e;
                    if ((null == (t = [].concat(t)) ? void 0 : t.length) > 0) {
                        const s = (e = e.trim()).toLowerCase();
                        for (var r = 0; r < t.length; r++) {
                            const n = t[r].toLowerCase()
                              , a = s.indexOf(n + " ", 0);
                            0 == a && (e = e.substring(n.length).trim());
                            const o = e.toLowerCase().indexOf(n, e.length - n.length);
                            if (o > 0 && (e = e.substring(0, o)),
                            0 == a || o > 0)
                                return e.trim()
                        }
                    }
                    return e
                },
                brandUrl: function(e) {
                    return `/brands/${encodeURIComponent(e)}`
                },
                brandUrlById: async function(e) {
                    if (!e)
                        return null;
                    const t = await WbSpaModel.prototype.$httpClient.fetchStaticV3(wb.helpers.url.urlStaticData, {}, `brands-by-id/${e}.json`);
                    return t ? $.views.helpers.brandUrl(t.url) : null
                },
                formatPrice: function(e, t, r) {
                    let s = $.views.converters.divideNumberBySeparator(e) + (t ? `,${t}` : "");
                    return "" !== r && (s += "&nbsp;" + (r || wb.settings.currencyShortName)),
                    s
                },
                isDateToday: e => new Date(e).dateEqual(new Date),
                isClosedByUser: e => {
                    var t;
                    return (null == (t = wb.global.userSettings.closed) ? void 0 : t.includes(e)) || !1
                }
                ,
                getCurrentCurrency: function() {
                    return $.views.converters.currencySign(WbSpaModel.prototype.$user.getCurrency())
                },
                fillFeedbackPhotosAndVideo(e) {
                    return e ? e.map((e => {
                        const t = e.isVideo ? this.fillFeedbackVideos([e]) : this.fillFeedbackPhotos([e]);
                        return null == t ? void 0 : t[0]
                    }
                    )) : []
                },
                fillFeedbackPhotos: function(e) {
                    const t = [];
                    return e ? e.map((e => {
                        const t = e.id || e;
                        return {
                            id: t,
                            preview: wb.helpers.url.urlFeedbackPhoto(t, "ms"),
                            previewFallback: wb.helpers.url.urlFeedbackPhoto(t, "ms", !0),
                            fullPath: wb.helpers.url.urlFeedbackPhoto(t, "fs"),
                            fullPathFallback: wb.helpers.url.urlFeedbackPhoto(t, "fs", !0)
                        }
                    }
                    )) : t
                },
                fillFeedbackVideos: function(e) {
                    if (!e)
                        return [];
                    return (Array.isArray(e) ? e : [e]).map((e => {
                        const t = e.id
                          , [r,s] = null == t ? void 0 : t.split("/")
                          , n = e.durationSec ? wb.helpers.formatVideoDuration(e.durationSec) : "-";
                        return {
                            id: t,
                            preview: wb.helpers.url.urlFeedbackVideo(e),
                            video: wb.helpers.url.urlFeedbackVideo(e, "index.m3u8"),
                            mp4: wb.helpers.url.urlFeedbackVideo(e, "preview.mp4"),
                            isVideo: !0,
                            duration: n
                        }
                    }
                    ))
                },
                stripHtml: (e, t) => {
                    if (!e)
                        return "";
                    if (t)
                        return e;
                    return (new DOMParser).parseFromString(e, "text/html").body.textContent || ""
                }
                ,
                isIosDevice: wb.helpers.iOS,
                isHuaweiDevice: wb.helpers.huawei,
                sumBy(e, t) {
                    return t && e && 0 != e.length ? e.reduce(( (e, r) => (isNaN(r[t]) || (e += +r[t]),
                    e)), 0) : 0
                },
                minFiscalPriceInCurrency: function(e) {
                    switch (e.toUpperCase()) {
                    case "UZS":
                        return 100;
                    case "AMD":
                    case "KZT":
                        return 10;
                    case "BYN":
                    case "USD":
                    case "TJS":
                        return .01;
                    default:
                        return 1
                    }
                },
                stopPropagation: e => e.stopPropagation(),
                subtract: function(e, t=0) {
                    return (Math.round(100 * e) - Math.round(100 * t)) / 100
                },
                isExpressDeliveryToday: function(e, t, r) {
                    if (!t || !e || !r)
                        return !1;
                    const s = new Date
                      , n = 60 * s.getHours() + s.getMinutes()
                      , a = r[0]
                      , o = r[1]
                      , i = n + 60 * e;
                    if (n >= a && n <= o) {
                        if (t.some((e => i < e.start)) && e < 5)
                            return !0
                    }
                    return !1
                },
                formatNumberWithDot: function(e) {
                    return e ? String(e).replace(".", ",") : ""
                },
                getVatAmount(e, t, r) {
                    let s = Number(-1 * (e / (1 + t / 100) - e)).toFixed(2);
                    return r && (s = $.views.converters.divideNumberBySeparator(s),
                    s += `&nbsp;${r}`),
                    s
                },
                onPreventDefault(e) {
                    e.preventDefault()
                },
                checkProductOpenSameWindowAb() {
                    return "m" === wb.settings.displayMode || !(wb.global.settings.switches.enableOpenNewTab || wb.analitics.checkDataInSplitterServiceV2Sync("common", "ab_enableOpenNewTab", "yes"))
                }
            }),
            $.views.converters({
                not: function(e) {
                    return !e
                },
                formatPhone: function(e, t) {
                    return e.toString().formatPhone(t)
                },
                toOrdinalDigitByFemaleGender: function(e) {
                    return ["Первая", "Вторая", "Третья", "Четвертая", "Пятая", "Шестая", "Седьмая", "Восьмая", "Девятая", "Десятая"][e] || e + 1
                },
                spaceFormatted: function(e) {
                    return String(e).replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1 ")
                },
                plusMinus: e => {
                    let t = "";
                    return e > 0 ? t = "+" : e < 0 && (t = "-"),
                    t + " " + $.views.converters.spaceFormatted(Math.abs(e))
                }
                ,
                toInt: function(e) {
                    return parseInt(e, 10)
                },
                toFixed: function(e, t) {
                    var r = parseFloat(e);
                    return isNaN(r) ? "" : r.toFixed(t)
                },
                leadZero: function(e, t) {
                    if (isNaN(e) || null == e)
                        return null;
                    for (var r = Math.floor(e); r.toString().length < t; )
                        r = "0" + r;
                    return r
                },
                basketDeliveryDate: function(e, t, r, s, n=!1, a=!1, o=!1, i=!1, l=!1) {
                    if (!e)
                        return "";
                    if (o && a && a > 540 && (n = "9:00–23:00"),
                    !(8 & ~r)) {
                        const t = (new Date).daysBetween(e);
                        if (n) {
                            const t = $.views.converters.dayNameFromDate(e, l);
                            return i ? t : `${t}, ${n}`
                        }
                        if (s < 5 && 0 == t)
                            return $.views.converters.deliveryDateTxt(s, !0)
                    }
                    if (!t) {
                        if (n) {
                            const t = $.views.converters.dayNameFromDate(e, l);
                            return i ? t : `${t}, ${n}`
                        }
                        return $.views.converters.dayNameFromDate(e, l)
                    }
                    const c = t instanceof Date ? t : new Date;
                    return "number" == typeof t && (c.setTime(e.getTime()),
                    c.setDate(c.getDate() + t)),
                    c.is1stJan() && c.setDate(c.getDate() + 1),
                    e.getMonth() !== c.getMonth() ? `${e.format("d MMMM")}-${c.format("d MMMM")}` : `${e.format("d")}-${c.format("d MMMM")}`
                },
                priceWithCoins: function(e, t, r=!1) {
                    var s, n, a, o, i, l, c = Math.abs(Math.round(100 * (e % 1).toFixed(2)));
                    e = e > 0 ? Math.floor(e) : Math.ceil(e);
                    const u = (null == (a = null == (n = null == (s = this.tagCtx) ? void 0 : s.props) ? void 0 : n.iso) ? void 0 : a.toUpperCase()) || this.ctxPrm && (null == (o = this.ctxPrm("iso")) ? void 0 : o.toUpperCase());
                    return u && (t = null == (l = null == (i = wb.currencies) ? void 0 : i.info[u]) ? void 0 : l.sign),
                    0 == c && r ? c = null : c < 10 && (c = "0" + c),
                    $.views.helpers.formatPrice(e, c, t)
                },
                priceWithCurrencyOld: function(e, t, r, s=!1) {
                    if (!t && (isNaN(e) || !e))
                        return "";
                    if (("byn" === r || !r && "" !== r) && ("by" === wb.settings.currentLocale || "byn" === r || s)) {
                        let t = Math.round(100 * (e % 1).toFixed(2));
                        return e = Math.floor(e),
                        t < 10 && (t = "0" + t),
                        r && "byn" !== r && (t = null),
                        r = "р.",
                        $.views.helpers.formatPrice(e, t, r)
                    }
                    let n = "" === r ? "" : r || wb.settings.currencyShortName;
                    return e = Math.floor(100 * e) / 100,
                    $.views.helpers.formatPrice(e, null, n)
                },
                priceWithCurrencyV2: function(e, t, r) {
                    var s, n, a, o, i, l, c, u, d, p, h, m, g;
                    if (!t && (isNaN(e) || !e))
                        return "";
                    const y = e.toString().split(".")
                      , b = (null == (n = null == (s = this.tagCtx) ? void 0 : s.props) ? void 0 : n.withCoins) && e % 1 != 0
                      , f = r ? null == (o = null == (a = wb.currencies) ? void 0 : a.getIsoBySign) ? void 0 : o.call(a, r) : (null == (c = null == (l = null == (i = this.tagCtx) ? void 0 : i.props) ? void 0 : l.iso) ? void 0 : c.toUpperCase()) || this.ctxPrm && (null == (u = this.ctxPrm("iso")) ? void 0 : u.toUpperCase()) || WbSpaModel.prototype.$user.getCurrency();
                    r || (r = null == (p = null == (d = wb.currencies) ? void 0 : d.info[f]) ? void 0 : p.sign);
                    const v = null != (g = null == (m = null == (h = this.tagCtx) ? void 0 : h.props) ? void 0 : m.sale) ? g : 0;
                    if (v > 0) {
                        e = Number(e);
                        let t = Math.ceil(e * (v / 100));
                        t = -wb.priceHelper.toLocalPrice(t, r),
                        e += t,
                        y[0] = `${e}`
                    }
                    if ("RUB" === f && "byn" !== r && !b)
                        return $.views.helpers.formatPrice(y[0], null, r || "₽");
                    let w, S = e;
                    if ("byn" === r || "BYN" === f || "RUB" === f && b) {
                        S = Math.floor(e),
                        w = "00";
                        const t = e.toString().replace(",", ".").split(".")[1];
                        (null == t ? void 0 : t.length) > 0 && (w = t.substring(0, 2),
                        1 == w.length && (w += "0")),
                        r = "byn" === r || "BYN" === f ? "р." : "₽"
                    } else
                        "AMD" !== f && "KZT" !== f || "string" == typeof e ? "UZS" === f ? S = 100 * parseInt(e / 100) : "KGS" === f && (S = Math.floor(e)) : S = 10 * parseInt(e / 10);
                    return $.views.helpers.formatPrice(S, w, r)
                },
                priceUsdRaw: function(e) {
                    var t, r, s;
                    if (!(null == (s = null == (r = null == (t = wb.global) ? void 0 : t.settings) ? void 0 : r.variables) ? void 0 : s.toUsdExchangeRate))
                        return 0;
                    return (parseInt(e * wb.global.settings.variables.toUsdExchangeRate * 100) / 100).toFixedNumber(2)
                },
                priceUsd: function(e) {
                    var t, r, s;
                    if (!(null == (s = null == (r = null == (t = wb.global) ? void 0 : t.settings) ? void 0 : r.variables) ? void 0 : s.toUsdExchangeRate))
                        return "";
                    return "$" + $.views.converters.priceUsdRaw(e).toString().replace(/\B(?=(\d{3})+(?!\d))/g, "&nbsp;").replace(".", ",")
                },
                urlForGood: function(e, t, r, s, n, a, o, i) {
                    const l = new URL("/catalog/" + e + "/detail.aspx",window.location.origin);
                    return r && l.searchParams.set("targetUrl", r),
                    a && l.searchParams.set("size", a),
                    o && l.searchParams.set("helpKursk", "true"),
                    i && l.searchParams.set("isTrend", "true"),
                    s && (l.hash = s),
                    l.toString()
                },
                urlSiteStatic: function(e, t) {
                    return window._debug || window._isFeature ? `/${e}` : wb.helpers.url.urlSiteStatic(e, t)
                },
                urlSiteStaticPb: function(e) {
                    return $.views.converters.urlSiteStatic(e, !0)
                },
                urlStaticBasket: function(e, t, r) {
                    return wb.helpers.url.urlStaticBasket(e, t, r)
                },
                toLower: function(e) {
                    return null == e ? void 0 : e.toLowerCase()
                },
                dateFromTimestamp: function(e, t) {
                    return new Date(e).format(t || "dd.MM.yyyy HH:mm")
                },
                formatDate: function(e, t) {
                    var r;
                    if (!e)
                        return "";
                    const s = new Date(e);
                    return (null == (r = this.tagCtx) ? void 0 : r.props.yearFormat) && (new Date).getFullYear() != s.getFullYear() && (t += this.tagCtx.props.yearFormat),
                    s.format(t)
                },
                humanDate: function(e, t) {
                    var r, s;
                    if (!e)
                        return "";
                    "string" == typeof e && (e = new Date(e));
                    const n = e => `${e} мес`
                      , a = e => $.pluralize(e, "{0} год", "{0} года", "{0} лет")
                      , {years: o, months: i, days: l} = wb.helpers.date.diff(e);
                    let c = (o > 0 || i > 0) && l > 15 ? i + 1 : i;
                    if (o > 0)
                        return 0 == c ? a(o) : 12 == c ? a(o + 1) : `${a(o)} ${n(c)}`;
                    if (i > 0)
                        return 12 == c ? a(o + 1) : n(c);
                    const u = null == (s = null == (r = this.tagCtx) ? void 0 : r.props) ? void 0 : s.genitive;
                    return null != t ? t : u ? $.pluralize(l, "{0} дня", "{0} дней") : $.pluralize(l, "{0} день", "{0} дня", "{0} дней")
                },
                humanTime: function(e) {
                    var t, r, s, n, a, o;
                    if (e <= 0 || isNaN(e))
                        return "";
                    const i = null == (r = null == (t = this.tagCtx) ? void 0 : t.props) ? void 0 : r.genitive
                      , l = []
                      , c = null == (n = null == (s = this.tagCtx) ? void 0 : s.props) ? void 0 : n.withDays
                      , u = Math.round(e / 86400);
                    if (c && u)
                        return i ? $.pluralize(u, "{0} дня", "{0} дней") : $.pluralize(u, "{0} день", "{0} дня", "{0} дней");
                    const d = Math.floor(e % 86400 / 3600);
                    d && l.push(i ? $.pluralize(d, "{0} часа", "{0} часов") : $.pluralize(d, "{0} час", "{0} часа", "{0} часов"));
                    const p = null == (o = null == (a = this.tagCtx) ? void 0 : a.props) ? void 0 : o.withSeconds
                      , h = Math.floor(e % 3600 / 60) + (p ? 0 : 1);
                    if (h && l.push(i ? $.pluralize(h, "{0} минуты", "{0} минут") : $.pluralize(h, "{0} минута", "{0} минуты", "{0} минут")),
                    p) {
                        const t = e % 60;
                        t && l.push(i ? $.pluralize(t, "{0} секунды", "{0} секунд") : $.pluralize(t, "{0} секунда", "{0} секунды", "{0} секунд"))
                    }
                    return l.reduce(( (e, t, r, s) => {
                        if (0 == r)
                            return t;
                        return `${e}${s.length - 1 == r ? " и " : ", "}${t}`
                    }
                    ), "")
                },
                differenceDatesInSeconds: function(e=new Date, t=0) {
                    const r = new Date(e).addDays(t)
                      , s = new Date
                      , n = Math.floor((r - s) / 1e3);
                    return Math.max(0, n)
                },
                humanTimerFormat: function(e=0, t=!1) {
                    if (e <= 0 || isNaN(e))
                        return "время закончилось";
                    const r = Math.floor(e / 3600)
                      , s = Math.floor(e % 3600 / 60)
                      , n = e % 60;
                    if (e < 86400)
                        return `${t ? "" : $.pluralize(r, "остался", "осталось")} ${r < 10 ? "0" : ""}${r}${t ? " ч " : ":"}${s < 10 ? "0" : ""}${s}${t ? " мин " : ":"}${n < 10 ? "0" : ""}${n}${t ? " сек" : ""}`;
                    {
                        const t = Math.floor(e / 86400);
                        return $.pluralize(t, "остался {0} день", " осталось {0} дня", "осталось {0} дней")
                    }
                },
                humanTimerFormatSimple: function(e=0, t=!1) {
                    if (!e)
                        return;
                    const r = Math.floor(e / 3600)
                      , s = Math.floor(e % 3600 / 60)
                      , n = e % 60;
                    return `${r > 0 || t ? `${r < 10 ? "0" : ""}${r}:` : ""}${s < 10 ? "0" : ""}${s}:${n < 10 ? "0" : ""}${n}`
                },
                dateStringToFormat: function(e, t) {
                    if (!e || "string" != typeof e)
                        return "";
                    const [r,s,n] = e.split(".").map((e => parseInt(e)));
                    try {
                        return new Date(n,s - 1,r).format(t || "dd MMMM yyyy")
                    } catch (e) {
                        return ""
                    }
                },
                localize: function(e) {
                    return $.localize(e, Array.prototype.slice.call(arguments, 1))
                },
                pluralize: function(e) {
                    return $.pluralize(null != e ? e : 0, Array.prototype.slice.call(arguments, 1))
                },
                customDateTimeFormat: function(e, t, r, s, n) {
                    n || (n = "HH:mm");
                    var a = new Date(e)
                      , o = new Date;
                    if (a.toDateString() === o.toDateString())
                        return r + ", " + a.format(n);
                    var i = function() {
                        return this.setDate(this.getDate() - 1),
                        this
                    }
                    .call(o);
                    if (a.toDateString() === i.toDateString())
                        return s + ", " + a.format(n);
                    var l = a.format(t);
                    return a.getFullYear() < o.getFullYear() ? l + " " + a.getFullYear() + ", " + a.format(n) : l + ", " + a.format(n)
                },
                divideNumberBySeparator: function(e, t) {
                    return Object.is(e, -0) ? "-0" : null == e ? void 0 : e.toString().replace(/\B(?=(\d{3})+(?!\d))/g, t || "&nbsp;")
                },
                trimWord: $.views.helpers.trimWord,
                join: function(e) {
                    if (!e || 0 == e.length)
                        return "";
                    const {upper: t, prefix: r, separator: s} = this.tagCtx.props;
                    return e.map((e => (t && (e = e.toUpperCase()),
                    r && (e = `${r}${e}`),
                    e))).join(s)
                },
                humanBytes: e => {
                    const t = wb.i18n.t
                      , r = [t("common.bytes.byte"), t("common.bytes.kilobyte"), t("common.bytes.megabyte"), t("common.bytes.gigabyte")];
                    let s = 0;
                    for (; s < r.length - 1 && e >= 1024; )
                        e /= 1024,
                        s++;
                    return `${+e.toFixed(2)} ${r[s]}`
                }
                ,
                deliveryDateTxt: function(e, t) {
                    if (!e || "number" != typeof e)
                        return "";
                    let r;
                    const s = new Date(Date.now())
                      , n = new Date(s.getTime() + 60 * e * 60 * 1e3);
                    n.is1stJan() && (n.setDate(n.getDate() + 1),
                    e += 24);
                    const a = 24 - s.getHours()
                      , o = n.getHours();
                    return s.getDate() === n.getDate() && e < 24 ? r = o < 9 ? "Сегодня утром" : o < 23 ? t ? e < 5 ? "Сегодня за 2–4 часа" : $.pluralize(e, "Сегодня за {0} час", "Сегодня за {0} часа", "Сегодня за {0} часов") : $.pluralize(e, "За {0} час", "За {0} часа", "За {0} часов") : "Завтра утром" : e < a + 9 ? r = e < 5 ? "Завтра утром" : "Завтра" : e < 24 + a ? r = o < 23 ? "Завтра" : "Послезавтра" : e < 48 + a && o < 23 ? r = "Послезавтра" : (o >= 23 && (e += a),
                    r = $.views.converters.dateFromTimestamp(Date.now() + 60 * e * 60 * 1e3, "d MMMM")),
                    r
                },
                minutesToTime: function(e) {
                    return Math.floor(e / 60) + ":" + (e % 60).toString().padStart(2, "0")
                },
                fastDeliveryText: function(e, t, r) {
                    if (!t || !e || !r)
                        return;
                    const s = new Date
                      , n = 60 * s.getHours() + s.getMinutes()
                      , a = r[0]
                      , o = r[1]
                      , i = n + 60 * e
                      , l = t[0].start
                      , c = $.views.converters.minutesToTime(l);
                    if (n <= a)
                        return `Сегодня с ${c}`;
                    if (n >= a && n <= o) {
                        return t.some((e => i < e.start)) ? e < 5 ? "За 2–4 часа" : $.pluralize(e, "За {0} час", "За {0} часа", "За {0} часов") : `Завтра с ${c}`
                    }
                    return `Завтра с ${c}`
                },
                formatTimeStr: function(e) {
                    return e.replace(/^0(\d):/, "$1:")
                },
                dayNameFromDate: function(e, t=!1, r=!1, s=!1, n=!1) {
                    if (!e)
                        return;
                    const a = new Date
                      , o = e instanceof Date ? e : new Date(e)
                      , i = a.daysBetween(o);
                    return 0 === i ? n ? "сегодня" : "Сегодня" : 1 === i ? n ? "завтра" : "Завтра" : 2 === i && t ? n ? "послезавтра" : "Послезавтра" : i >= 3 && i <= 7 && s ? `через ${i} ${3 === i || 4 === i ? "дня" : "дней"}` : r && o.getFullYear() !== a.getFullYear() ? o.format("d MMMM yyyy") : o.format("d MMMM")
                },
                catalogDeliveryDate: function(e) {
                    return `Доставка <span class="product-card__delivery-date">${$.views.converters.deliveryDateTxt(e)}</span>`
                },
                deliveryType: function() {
                    const {storeType: e} = this.tagCtx.props;
                    return `${4 & ~e ? "Доставка" : "Грузовая доставка"} ${8 & ~e ? "Wildberries" : "продавца"}`
                },
                formatString: function() {
                    let[e,t,r,s] = arguments;
                    if ("string" != typeof e)
                        throw new Error("Template must be a string");
                    return r && (e = e.replace(/\[(\d+)\]/gm, "{$1}")),
                    s && (t = $.views.converters.encode(t)),
                    String.format.apply(null, [e, t])
                },
                trim: function(e) {
                    return null == e ? void 0 : e.trim()
                },
                imgForPromoCategory: function(e=0, t=!1, r, s, n) {
                    const a = t ? "small/" : ""
                      , o = r ? `promo_custom/pack_${s}/` : "promo_v2/"
                      , i = e < 1e6 ? e : parseInt((e + "").slice(-6));
                    return wb.helpers.url.urlStaticBasket(`wbx-catalog/${o}${a}${i}.webp`, 1, n)
                },
                fileName: function(e) {
                    var t, r;
                    const s = e.substring(e.lastIndexOf("/") + 1)
                      , n = null == (r = null == (t = this.tagCtx) ? void 0 : t.props) ? void 0 : r.mode;
                    return "name" == n ? s.substring(0, s.lastIndexOf(".")) || s : "extension" == n ? s.slice(1 + (Math.max(s.lastIndexOf("."), 0) || s.length)) || "" : s
                },
                convertToText: function(e) {
                    if (!Array.isArray(e) || 0 === e.length)
                        return "";
                    const t = {
                        text: "текст",
                        photo: "фото",
                        video: "видео"
                    }
                      , r = e.map((e => t[e.toLowerCase()])).filter(Boolean);
                    if (0 === r.length)
                        return "";
                    if (1 === r.length)
                        return $.localize(r[0]);
                    const s = r.pop()
                      , n = r.join(", ");
                    return $.localize(`${n} и&nbsp;${s}`)
                },
                toHttps: e => $.views.converters.url(null == e ? void 0 : e.replace(/^http:/i, "https:")),
                onlyDigits: e => null == e ? void 0 : e.replace(/[^\d\.]/g, ""),
                toWebp: function(e) {
                    var t, r;
                    return (null == (r = null == (t = WbSpaModel.prototype) ? void 0 : t.$apiSupport) ? void 0 : r.webpImage) ? "webp" : e
                },
                useWebp: function(e) {
                    var t, r;
                    return (null == (r = null == (t = WbSpaModel.prototype) ? void 0 : t.$apiSupport) ? void 0 : r.webpImage) ? null == e ? void 0 : e.replace(/^(.*\.)(jpg|jpeg)$/i, "$1webp") : e
                },
                toNumber: e => +e,
                fixHtml: e => e ? (new DOMParser).parseFromString(e, "text/html").body.innerHTML : ""
            }),
            $.views.tags({
                range: {
                    boundProps: ["start", "end"],
                    baseTag: "for",
                    render: function(e) {
                        var t = e
                          , r = this.tagCtx
                          , s = r.props.start || 0
                          , n = r.props.end
                          , a = r.params.props;
                        if (s || n)
                            if (r.args.length)
                                $.isArray(t) && (t = t.slice(s, n));
                            else {
                                t = [],
                                n = n || 0;
                                for (var o = s; o <= n; o++)
                                    t.push(o)
                            }
                        return arguments.length || a && (a.start || a.end) ? this.base(t) : this.base()
                    },
                    onArrayChange: function(e, t) {
                        this.refresh()
                    }
                },
                calendarV2: {
                    dataBoundOnly: !0,
                    onUpdate: !1,
                    bindTo: ["selected", "limitTo", "limitFrom"],
                    linkedCtxParam: ["selected", "limitTo", "limitFrom"],
                    format: "dd.MM.yyyy",
                    init: function(e) {
                        e.props.format && (this.format = e.props.format),
                        e.props.appendTo && (this.appendTo = e.props.appendTo)
                    },
                    onBind: function(e) {
                        const t = {
                            x: 0,
                            y: 1
                        };
                        e.props.offsetX && (t.x = e.props.offsetX),
                        this.datePicker = $(e.props.target).glDatePicker({
                            selectedDate: this.ctxPrm("selected") ? this.ctxPrm("selected") : e.props.limitTo,
                            customWidth: e.props.width,
                            zIndex: e.props.zIndex,
                            appendTo: this.appendTo,
                            overlay: "m" === wb.settings.displayMode,
                            useClick: !0,
                            calendarOffset: t,
                            onClick: (t, r, s, n) => {
                                this.ctxPrm("selected", s),
                                "function" == typeof e.props.onSelect && e.props.onSelect(s.format(this.format))
                            }
                        }).glDatePicker(!0)
                    },
                    onAfterLink: function(e, t, r, s, n) {
                        var a = {
                            from: e.props.defaultFrom ? e.props.defaultFrom : new Date(2001,1,1),
                            to: new Date
                        };
                        e.props.limitFrom && (a.from = e.props.limitFrom),
                        e.props.limitTo && (a.to = e.props.limitTo),
                        this.datePicker.options.selectableDateRange = [a];
                        for (var o = [], i = a.from.getFullYear(); i <= a.to.getFullYear(); i++)
                            o.push(i);
                        this.datePicker.options.selectableYears = o,
                        this.datePicker.render()
                    }
                },
                swiper: {
                    dataBoundOnly: !0,
                    mainElement: ".custom-slider",
                    boundProps: ["total", "needRefresh", "activeSlide"],
                    template: '\n                <div class="custom-slider{{if ~tag.sliderClass}} {{: ~tag.sliderClass}}{{/if}}">\n                    <div class="custom-slider__list">\n                        {{include tmpl=#content/}}\n                    </div>\n                    {{if ~tag.showArrows}}\n                    <button type="button" aria-label="Назад" class="custom-slider__arrow custom-slider__arrow--prev" data-link="{on ~tag.scroll \'left\'}disabled{:~leftArrowDisabled}"></button>\n                    <button type="button" aria-label="Вперёд" class="custom-slider__arrow custom-slider__arrow--next" data-link="{on ~tag.scroll \'right\'}disabled{:~rightArrowDisabled}"></button>\n                    {{/if}}\n                    {{if ~tag.showArrows && ~tag.showFade}}\n                    <div class="custom-slider__fade custom-slider__fade--prev" data-link="disabled{:~leftArrowDisabled}"></div>\n                    <div class="custom-slider__fade custom-slider__fade--next" data-link="disabled{:~rightArrowDisabled}"></div>\n                    {{/if}}\n                </div>\n            ',
                    init: function() {
                        var e, t, r, s;
                        const n = this.tagCtx.props.slidesPerView;
                        this.slidesPerView = "auto" === n || "number" == typeof n ? n : 1,
                        this.showArrows = null != (e = this.tagCtx.props.showArrows) && e,
                        this.showFade = null != (t = this.tagCtx.props.showFade) && t,
                        this.sliderClass = null != (r = this.tagCtx.props.sliderClass) && r,
                        this.slideSelector = null != (s = this.tagCtx.props.slideSelector) ? s : ".custom-slider__item",
                        this.checkArrows = this.checkArrows.bind(this),
                        this.doOnScroll = WbSpaModel.prototype.$helper.throttle(this.doOnScroll.bind(this), 300),
                        this.scrollToSlide = this.scrollToSlide.bind(this)
                    },
                    onAfterLink: function() {
                        this.checkArrows();
                        const e = this.tagCtx.props.activeSlide;
                        void 0 !== e && this.scrollToSlide(e)
                    },
                    onBind: function(e) {
                        this.containerList = this.mainElem[0].querySelector(".custom-slider__list"),
                        this.containerList.addEventListener("scroll", this.doOnScroll)
                    },
                    onUpdate: function(e, t, r) {
                        return "propertyChange" === e.type && "needRefresh" === t.path && (this.containerList.scrollLeft = 0,
                        this.checkArrows()),
                        !1
                    },
                    scroll: function(e) {
                        const t = this.containerList.querySelector(this.slideSelector).clientWidth + parseInt(getComputedStyle(this.containerList).gap);
                        let r = this.slidesPerView;
                        if ("auto" === this.slidesPerView) {
                            const e = this.mainElem[0].getBoundingClientRect();
                            r = Math.floor(e.width / t)
                        }
                        const s = t * r
                          , n = Math.round(this.containerList.scrollLeft) + ("left" === e ? -s : s);
                        this.containerList.scrollLeft = Math.round(n / t) * t
                    },
                    scrollToSlide: function(e) {
                        const t = e * (this.containerList.querySelector(this.slideSelector).clientWidth + parseInt(getComputedStyle(this.containerList).gap));
                        this.containerList.scrollLeft = t
                    },
                    doOnScroll: async function(e) {
                        this.checkArrows()
                    },
                    checkArrows: async function() {
                        window.requestAnimationFrame(( () => {
                            const e = this.containerList.querySelectorAll(this.slideSelector);
                            if (!e.length > 0)
                                this.ctxPrm("leftArrowDisabled", !0),
                                this.ctxPrm("rightArrowDisabled", !0);
                            else {
                                const t = this.mainElem[0].getBoundingClientRect()
                                  , r = e[e.length - 1].getBoundingClientRect();
                                this.ctxPrm("leftArrowDisabled", this.containerList.scrollLeft <= 0),
                                this.ctxPrm("rightArrowDisabled", t.right + 5 >= r.right)
                            }
                        }
                        ))
                    }
                },
                btnAdvertising: {
                    template: "\n            {{if ordBannerMark}}<button \n                                    type=\"button\" \n                                    class=\"btn-advertising\" \n                                    title=\"\" \n                                    data-link=\"{on ~onPreventDefault}\n                                    {tooltip classes='tooltip-advertising j-tooltip-advertising tooltip--dark' pos='alignright bottom' trigger='hover' distance=0 tmplName='advertisingTooltipTmpl' tmplData=ordBannerMark}\">\n                                    <span>Реклама</span>\n                                </button>{{/if}}\n        "
                },
                infiniteScroll: {
                    mainElement: "div",
                    template: '<div class="scroll-loader"></div>',
                    onAfterLink() {
                        this.scrollObserver = new IntersectionObserver(( (e, t) => {
                            e.forEach((e => {
                                e.isIntersecting && this.tagCtx.props.callback()
                            }
                            ))
                        }
                        ),{
                            threshold: 0,
                            rootMargin: "0px 0px 50% 0px"
                        }),
                        this.scrollObserver.observe(this.mainElem[0])
                    },
                    onDispose() {
                        this.scrollObserver.disconnect()
                    }
                },
                onSwipe: {
                    init: function(e) {
                        var t;
                        this.threshold = 10,
                        1 == (null == (t = e.args) ? void 0 : t.length) && "function" == typeof e.args[0] && (this.onSwiped = e.args[0]),
                        this.onTouchStart = this.onTouchStart.bind(this),
                        this.onTouchMove = this.onTouchMove.bind(this),
                        this.onTouchEnd = this.onTouchEnd.bind(this)
                    },
                    onBind: function() {
                        this.onSwiped && (this.linkCtx.elem.addEventListener("touchstart", this.onTouchStart, !1),
                        this.linkCtx.elem.addEventListener("touchmove", this.onTouchMove, !1),
                        this.linkCtx.elem.addEventListener("touchend", this.onTouchEnd, !1))
                    },
                    onUnbind: function() {
                        this.linkCtx.elem.removeEventListener("touchstart", this.onTouchStart, !1),
                        this.linkCtx.elem.removeEventListener("touchmove", this.onTouchMove, !1),
                        this.linkCtx.elem.removeEventListener("touchend", this.onTouchEnd, !1)
                    },
                    onTouchStart: function(e) {
                        const t = e.changedTouches[0];
                        this.startX = t.pageX,
                        this.startY = t.pageY,
                        e.cancelable && e.preventDefault()
                    },
                    onTouchMove: function(e) {
                        const t = e.changedTouches[0];
                        this.deltaX = t.pageX - this.startX,
                        this.deltaY = t.pageY - this.startY,
                        e.cancelable && e.preventDefault()
                    },
                    onTouchEnd: function(e) {
                        const t = Math.atan2(-this.deltaY, -this.deltaX)
                          , r = 3 * Math.PI / 4
                          , s = Math.PI / 4;
                        let n;
                        n = s <= t && t <= r ? "up" : -r <= t && t <= -s ? "down" : -r < t && t < r ? "left" : "right",
                        (Math.abs(this.deltaX) >= this.threshold || Math.abs(this.deltaY) >= this.threshold) && this.onSwiped(n),
                        e.cancelable && e.preventDefault()
                    }
                }
            })
        },
        25314: function() {
            "use strict";
            var e = Object.defineProperty
              , t = Object.defineProperties
              , r = Object.getOwnPropertyDescriptors
              , s = Object.getOwnPropertySymbols
              , n = Object.prototype.hasOwnProperty
              , a = Object.prototype.propertyIsEnumerable
              , o = (t, r, s) => r in t ? e(t, r, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: s
            }) : t[r] = s
              , i = (e, t) => {
                for (var r in t || (t = {}))
                    n.call(t, r) && o(e, r, t[r]);
                if (s)
                    for (var r of s(t))
                        a.call(t, r) && o(e, r, t[r]);
                return e
            }
              , l = (e, s) => t(e, r(s));
            const c = "tail_object_data"
              , u = ["SNT", "SNH", "SNS", "SST", "SHT"]
              , d = ["SNS", "ANS", "SNH", "ANH", "SHT"]
              , p = ["SAB", "ANH", "ANS", "AST", "ATR"]
              , h = ["MBB", "MBM", "MBS", "BBB", "BBA", "CBB", "CBA", "CBU", "CBS"];
            var m = class {
                getTermsFromTailObject(e, t) {
                    var r, s, n;
                    const a = this.getTailObjectData()
                      , o = {
                        filters: null != (r = a.filters) ? r : "",
                        filters_entry_point: null != (s = a.filters_entry_point) ? s : "default"
                    }
                      , c = {
                        bid: a.bid,
                        bid_index: a.bid_index
                    }
                      , m = {
                        category: a.category,
                        id_category: a.id_category
                    }
                      , g = {
                        parent_item_id: a.parent_item_id,
                        brand: a.brand
                    };
                    if ("AAA" === e || "ADI" === e) {
                        const e = this.getTailObjectData();
                        let t = "";
                        switch (e.page_type) {
                        case "brand":
                            t = e.brand;
                            break;
                        case "catalog":
                            t = e.id_category;
                            break;
                        case "search":
                            t = e.search_text;
                            break;
                        case "seller":
                            t = e.page_info;
                            break;
                        default:
                            t = ""
                        }
                        return {
                            page_type: e.page_type,
                            page_info: t
                        }
                    }
                    if ("AHT" === e) {
                        const e = this.getTailObjectData();
                        return {
                            catalog_type: e.catalog_type,
                            catalog_value: e.catalog_value,
                            normquery: e.normquery,
                            query_id: e.query_id,
                            filters: e.filters,
                            filters_entry_point: e.filters_entry_point,
                            rmi: e.rmi,
                            search_text: e.search_text
                        }
                    }
                    if ("SCL" === e) {
                        const e = this.getTailObjectData();
                        return {
                            catalog_type: e.catalog_type,
                            catalog_value: e.catalog_value,
                            query_id: e.query_id,
                            rmi: e.rmi
                        }
                    }
                    if ("SCM" === e) {
                        const e = this.getTailObjectData();
                        return {
                            catalog_type: e.catalog_type,
                            catalog_value: e.catalog_value,
                            query_id: e.query_id,
                            rmi: e.rmi
                        }
                    }
                    function y() {
                        return i(i({}, o), m)
                    }
                    if (h.includes(e))
                        return i(i({}, c), o);
                    if (u.includes(e) || p.includes(e)) {
                        const t = i({
                            catalog_type: a.catalog_type,
                            catalog_value: a.catalog_value,
                            normquery: a.normquery,
                            query_id: a.query_id,
                            rmi: a.rmi,
                            search_text: a.search_text
                        }, o);
                        return d.includes(e) && (t.text_typed = null != (n = a.text_typed) ? n : ""),
                        t
                    }
                    return "STB" === e ? {
                        filters: a.filters,
                        filters_entry_point: a.filters_entry_point,
                        brand: a.brand,
                        query_id: a.query_id,
                        text_typed: null != (b = a.text_typed) ? b : ""
                    } : "SCF" === e ? {
                        search_text: a.search_text
                    } : "SPA" === e ? {
                        query_id: a.query_id
                    } : "MAB" === e || "MCS" === e ? i({
                        catalog_type: a.catalog_type,
                        catalog_value: a.catalog_value,
                        preset_type: a.preset_type,
                        recid: a.recid
                    }, t) : "MBL" === e ? i({
                        bid: a.bid
                    }, o) : "MBT" === e ? l(i(i({}, c), o), {
                        tv_block: 1
                    }) : ["BCR", "IBC"].includes(e) ? o : "BCA" === e ? y() : "CCT" === e || "CCR" === e ? {} : ["CCC", "CTC", "CAB"].includes(e) ? y() : "ICC" === e ? o : "IAB" === e ? l(i({}, o), {
                        banner_name: a.banner_name
                    }) : ["ABN", "ABC"].includes(e) ? i(i({}, o), g) : ["IAC", "IBN"].includes(e) ? l(i({}, o), {
                        parent_item_id: a.parent_item_id
                    }) : ["ICO", "ICV", "ICR", "ISP", "ICA"].includes(e) ? {
                        parent_item_id: a.parent_item_id
                    } : "ITO" === e ? {
                        parent_item_id: a.parent_item_id,
                        type_of_block: a.type_of_block
                    } : "ISC" === e ? l(i({}, o), {
                        parent_item_id: a.parent_item_id
                    }) : "IPT" === e ? {
                        parent_item_id: a.parent_item_id
                    } : ["ICS", "ICA"].includes(e) ? {
                        catalog_type: a.catalog_type,
                        catalog_value: a.catalog_value,
                        preset_type: a.preset_type,
                        parent_item_id: a.parent_item_id
                    } : ["CCB", "CCM", "CPF"].includes(e) ? {
                        item_ids: a.item_ids
                    } : "CRV" === e ? {
                        empty_cart: a.empty_cart
                    } : "CSI" === e || "TCM" === e ? {
                        parent_item_id: a.parent_item_id
                    } : ["CSD", "CAD", "WLC", "WLA"].includes(e) ? i(i({
                        discount_name: "Скидка WB клуба"
                    }, o), m) : ["PBC", "PBB"].includes(e) ? c : "PCB" === e ? m : ["PSA", "PBA", "PAP", "AMB", "PPA", "PCS", "DLV", "DCV", "DRE"].includes(e) ? {} : "FBR" === e ? o : ["AAA", "ADI"].includes(e) ? {
                        page_type: a.page_type,
                        page_info: a.page_info
                    } : ["LLI", "AIL"].includes(e) ? {
                        special_project: a.special_project
                    } : "ICB" === e ? {
                        type_of_block: a.type_of_block,
                        parent_item_id: a.parent_item_id
                    } : "PVC" === e || "PAC" === e ? {
                        type_of_block: a.type_of_block,
                        filters: a.filters,
                        filters_entry_point: a.filters_entry_point,
                        vendor_index: a.vendor_index,
                        promo_name: a.promo_name,
                        promo_id: a.promo_id,
                        vendor_rate: a.vendor_rate,
                        vendor_id: a.vendor_id
                    } : null;
                    var b
                }
                getTailObjectData() {
                    const e = sessionStorage.getItem(c);
                    return e ? JSON.parse(e) : {}
                }
                updateTailObjectDataFromHtml(e) {
                    if ([...h, "MBL", "MBT"].includes(e.l)) {
                        const t = {
                            bid: e.t,
                            bid_index: e.t2
                        };
                        this.updateTailObjectData(t)
                    } else if ("IAB" === e.l) {
                        const t = {
                            banner_name: e.t
                        };
                        this.updateTailObjectData(t)
                    } else if (["ICO", "ICV", "ICR", "ICS", "ISC", "ISP", "IBN"].includes(e.l)) {
                        const t = {
                            parent_item_id: e.t
                        };
                        this.updateTailObjectData(t)
                    }
                }
                updateTailObjectData(e) {
                    if (!e)
                        return;
                    const t = this.getTailObjectData();
                    e.terms && (e.terms = i(i({}, t.terms), e.terms));
                    const r = i(i({}, t), e);
                    this._saveTailObjectData(r)
                }
                _saveTailObjectData(e) {
                    try {
                        if (!e)
                            return;
                        sessionStorage.setItem(c, JSON.stringify(e))
                    } catch (e) {}
                }
            }
            ;
            const g = "onw_handler_key"
              , y = 3e5;
            var b = class {
                saveStatInfo(e, t) {
                    if (!e || !t)
                        return;
                    const r = document.location.pathname;
                    this._saveStatInfo({
                        targetUrl: e,
                        pathname: r,
                        analiticsData: t
                    })
                }
                getStatInfo() {
                    const e = this._getStatInfo();
                    return (null == e ? void 0 : e.analiticsData) || null
                }
                _getStatInfo() {
                    var e;
                    const t = null != (e = JSON.parse(localStorage.getItem(g))) ? e : {};
                    if (!(null == t ? void 0 : t.expired) || t.expired < Date.now() - y)
                        return null;
                    const r = t.data
                      , s = document.location.href
                      , n = document.referrer ? new URL(document.referrer).pathname : "";
                    return r.targetUrl == s && r.pathname == n ? r : void 0
                }
                _saveStatInfo(e) {
                    try {
                        if (!e)
                            return;
                        localStorage.putObject(g, {
                            expired: Date.now() + y,
                            data: e
                        })
                    } catch (e) {}
                }
            }
            ;
            var f = class {
                ecomInfoToArray(e) {
                    return e ? [e.analiticsCode, e.index, e.sort, e.termsForListName.t, e.termsForListName.t1, e.termsForListName.t2, e.termsForListName.t3, e.termsForListName.t4, e.logs] : []
                }
                getFullEcomInfoHtml(e) {
                    return this.getFullEcomInfo(e)
                }
                _tryGetTargetItem(e) {
                    var t, r, s;
                    let n = null == e ? void 0 : e.closest(".j-analitics-item");
                    return n ? $.view(n).data : (n = null == e ? void 0 : e.closest(".j-menu-main-item"),
                    n ? {
                        getFullEcomInfo: null == (s = null == (r = null == (t = wb.spa.getMainLayout().menuTop) ? void 0 : t.sideMenu) ? void 0 : r.statisticManager) ? void 0 : s.getFullEcomInfoMenuItem
                    } : void 0)
                }
                getFullEcomInfo(e, t) {
                    var r;
                    if (t || (t = this._tryGetTargetItem(e)),
                    !t)
                        return null;
                    return null == (r = t.getFullEcomInfo) ? void 0 : r.call(t, e, t)
                }
            }
              , v = Object.defineProperty
              , w = Object.defineProperties
              , S = Object.getOwnPropertyDescriptors
              , _ = Object.getOwnPropertySymbols
              , C = Object.prototype.hasOwnProperty
              , I = Object.prototype.propertyIsEnumerable
              , M = (e, t, r) => t in e ? v(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }) : e[t] = r
              , k = (e, t) => {
                for (var r in t || (t = {}))
                    C.call(t, r) && M(e, r, t[r]);
                if (_)
                    for (var r of _(t))
                        I.call(t, r) && M(e, r, t[r]);
                return e
            }
              , P = (e, t) => w(e, S(t));
            wb.namespace("analitics", ( () => {
                const e = "wbAnalitic"
                  , t = "__wba_s"
                  , r = "lats_search_type"
                  , s = "search_suggest"
                  , n = "purchase_checkout"
                  , a = "stat_helper"
                  , o = "query_id_search"
                  , i = {
                    l: "AAA",
                    iid: 1
                }
                  , l = 3e5
                  , c = new m
                  , u = new b
                  , d = new f;
                let p = {
                    moveFrom: ""
                }
                  , h = "";
                if (null == sessionStorage.getItem(e)) {
                    const t = JSON.parse(localStorage.getItem(e));
                    (null == t ? void 0 : t.expired) > Date.now() - l && sessionStorage.setItem(e, JSON.stringify(t.payload)),
                    function() {
                        const e = u.getStatInfo();
                        if (!e)
                            return;
                        if (!e.analiticsCode)
                            return;
                        T(I(e)),
                        !e.tailObjectTerms || S(e.tailObjectTerms)
                    }()
                }
                const g = JSON.parse(localStorage.getItem(a));
                function y() {
                    return p
                }
                async function v() {
                    return WbSpaModel.prototype.$services.splitterService.getSplitInfo()
                }
                async function w(e) {
                    return WbSpaModel.prototype.$services.splitterService.getSplitInfoV2(e)
                }
                function S(e) {
                    c.updateTailObjectData(e)
                }
                function _(e, t=null, r="", s=!1) {
                    var n;
                    e || (e = "");
                    const a = ["targetUrl", "iid", "l", "lw", "s", "t", "t1", "t2", "t3", "t4", "logs"]
                      , o = (e, s) => {
                        var n;
                        return null != (n = null != e ? e : null == t ? void 0 : t[s]) ? n : r
                    }
                      , i = {}
                      , l = e.split("|");
                    for (let e = s ? 2 : 0; e < a.length; e++) {
                        let t = null != (n = l[e]) ? n : null
                          , r = a[e];
                        if (!r)
                            return;
                        i[r] = o(t, r)
                    }
                    return i
                }
                function C(e) {
                    return d.getFullEcomInfoHtml(e)
                }
                function I(e) {
                    const t = M(...d.ecomInfoToArray(e));
                    return e.sort && (t.s = e.sort),
                    t
                }
                function M(e, t, r, s, n, a, o, i, l) {
                    if ("string" != typeof e)
                        return;
                    "string" != typeof t && "number" != typeof t && (t = null),
                    "string" != typeof r && "number" != typeof r && (r = null),
                    "string" != typeof s && "number" != typeof s && (s = null),
                    "string" != typeof n && "number" != typeof n && (n = null),
                    "string" != typeof a && "number" != typeof a && (a = null),
                    "string" != typeof o && "number" != typeof o && (o = null),
                    "string" != typeof i && "number" != typeof i && (i = null),
                    "string" != typeof l && (l = null);
                    const c = {
                        l: e
                    };
                    let u = parseInt(t);
                    return null == t || isNaN(u) || (c.iid = Math.max(1, u)),
                    null != r && (c.opt = r),
                    null != s && (c.t = s),
                    null != n && (c.t1 = n),
                    null != a && (c.t2 = a),
                    null != o && (c.t3 = o),
                    null != i && (c.t4 = i),
                    null != l && (c.logs = l),
                    c
                }
                function T(t, r=!1, s=!1) {
                    try {
                        "string" == typeof t && (t = _(`||${t}`));
                        const n = JSON.stringify({
                            payload: t,
                            expired: Date.now() + l
                        });
                        s || (t.s = function(e) {
                            return "DRE" === e.l ? "" : (JSON.parse(localStorage.getItem("__catalogOptions")),
                            "DRE" === e.l || "LCV" === e.l ? "" : "popular")
                        }(t));
                        const a = JSON.stringify(t);
                        sessionStorage.setItem(e, a),
                        r || localStorage.setItem(e, n)
                    } catch (e) {
                        console.warn("Saving analitics state has failed"),
                        console.error(e.message)
                    }
                }
                return (null == g ? void 0 : g.expired) > Date.now() - l && (p = g.info),
                {
                    saveEcomInfo: function(e) {
                        let t = d.getFullEcomInfo(e);
                        t && u.saveStatInfo(e.href, t)
                    },
                    getTermByTermName: function(e) {
                        const t = wb.cookieHelper.getCookie("_wbauid")
                          , r = (new Date).format("yyyyMMddHHmmss", !0)
                          , s = {
                            qid: "qid",
                            recid: "recid"
                        };
                        return s[e] ? `${s[e]}${t}${r}` : void 0
                    },
                    ecomInfoToAnaliticsState: I,
                    analiticsStateToEcomInfo: function(e) {
                        const {l: t="", iid: r="", logs: s="", lw: n="", s: a="", t: o="", t1: i="", t2: l="", t3: c="", t4: u=""} = e
                          , d = {
                            analiticsCode: t,
                            locationWay: n,
                            sort: a,
                            index: r,
                            termsForListName: {
                                t: o,
                                t1: i,
                                t2: l,
                                t3: c,
                                t4: u
                            }
                        };
                        return s && (d.logs = s),
                        d
                    },
                    getEcomInfoFromItem: function(e, t) {
                        return d.getFullEcomInfo(e, t)
                    },
                    getEcomInfoFromHtmlItem: C,
                    getTermsFromTailObject: function(e, t) {
                        return c.getTermsFromTailObject(e, t)
                    },
                    updateTailObjectData: S,
                    getTailObjectData: function() {
                        return c.getTailObjectData()
                    },
                    analiticsInfoToListName: function(e={}, t={}) {
                        const r = k(k({}, e), t)
                          , {l: s="", lw: n="", s: a="", t: o="", t1: i="", t2: l="", t3: c="", t4: u="", t5: d=""} = r;
                        let p = `${s}|${n}|${a}|${o}|${i}|${l}|${c}|${u}`;
                        return d && (p += `|${d}`),
                        p
                    },
                    getDeliveryTypeForStat: function(e=null) {
                        switch (15 & e) {
                        case 2:
                            return "DBS";
                        case 7:
                            return "eDBS";
                        default:
                            return "WB"
                        }
                    },
                    getStoreProp: function(e=null, t=null) {
                        var r;
                        return (null == e ? void 0 : e.length) && t ? null == (r = e.sort(( (e, t) => e.time1 + e.time2 - t.time1 - t.time2))[0]) ? void 0 : r[t] : null
                    },
                    getAnaliticsInfoFromTargetUrl: _,
                    getTailObjectFromAnalyticsInfo: function(e, t, r) {
                        return function({l: e="", lw: t="", s: r="", t: s="", t1: n="", t2: a="", t3: o="", t4: i="", t5: l="", t6: c="", t7: u="", t8: d=""}={}, p=null) {
                            const h = {
                                loc: e,
                                loc_way: t,
                                sort: r
                            };
                            if (p)
                                return h.terms = p,
                                h;
                            const m = l
                              , g = u
                              , y = a
                              , b = d
                              , f = {
                                catalog_type: a,
                                catalog_value: n,
                                normquery: "",
                                rmi: ""
                            }
                              , v = {
                                catalog_type: "",
                                catalog_value: "",
                                normquery: "",
                                rmi: ""
                            }
                              , w = {
                                filters: "",
                                filters_entry_point: ""
                            }
                              , S = {}
                              , _ = {
                                category: s,
                                id_category: n
                            }
                              , C = {
                                bid: s,
                                bid_index: a
                            }
                              , I = {
                                supplier_type: n
                            };
                            return ["SVR", "STA", "SNT", "SHS", "SNH", "STH", "SNS", "SHT", "SCF", "STC", "STB"].includes(e) ? P(k({}, h), {
                                terms: P(k(k({}, f), w), {
                                    search_text: s,
                                    query_id: m
                                })
                            }) : ["SST"].includes(e) ? P(k({}, h), {
                                terms: {
                                    search_text: s,
                                    catalog_value: n,
                                    catalog_type: a
                                }
                            }) : ["SAB", "AVR", "ANH", "ANS", "AST", "AHT", "ATR"].includes(e) ? P(k({}, h), {
                                terms: P(k({}, S), {
                                    search_text: o,
                                    query_id: m
                                })
                            }) : ["ATC"].includes(e) ? P(k({}, h), {
                                terms: P(k({}, S), {
                                    id_category: o,
                                    query_id: m
                                })
                            }) : ["ATB"].includes(e) ? P(k({}, h), {
                                terms: P(k({}, S), {
                                    brand: o,
                                    query_id: m,
                                    filtersT7: g
                                })
                            }) : "STB" === e ? P(k({}, h), {
                                terms: {
                                    brand: s,
                                    catalog_value: n,
                                    catalog_type: a,
                                    query_id: m
                                }
                            }) : "STC" === e ? P(k({}, h), {
                                terms: P(k(k({}, f), w), {
                                    category: s,
                                    query_id: m
                                })
                            }) : "STS" === e ? P(k({}, h), {
                                terms: P(k(k({}, f), w), {
                                    supplier_name: s,
                                    supplier_id: "",
                                    query_id: m
                                })
                            }) : ["STR", "STG"].includes(e) ? P(k({}, h), {
                                terms: P(k(k({}, w), v), {
                                    tag_text: s,
                                    tag_index: n,
                                    supplier_id: "",
                                    query_id: m
                                })
                            }) : ["SBA", "SIS", "SCM", "SCN", "SPH", "STM", "SCR", "SPA"].includes(e) ? P(k({}, h), {
                                terms: {
                                    query_id: m
                                }
                            }) : ["MBB", "MBH", "MBM", "MBS", "MBV"].includes(e) ? P(k({}, h), {
                                terms: k(k({}, C), w)
                            }) : "MBT" === e ? P(k({}, h), {
                                terms: P(k(k({}, C), w), {
                                    tv_block: n
                                })
                            }) : ["MBG", "MBF"].includes(e) ? P(k({}, h), {
                                terms: k({}, C)
                            }) : ["MAB", "AMB"].includes(e) ? P(k({}, h), {
                                terms: k({}, S)
                            }) : ["MCS", "MCB", "MCP", "MCV", "MCO", "MPF", "MCM", "MCN", "MSA"].includes(e) ? k({}, h) : "MCD" === e || "MAD" === e ? P(k({}, h), {
                                terms: {
                                    promo_name: s,
                                    promo_id: n,
                                    type_of_block: l
                                }
                            }) : ["BBB", "BBA", "BBD"].includes(e) ? P(k({}, h), {
                                terms: k(k({}, w), C)
                            }) : "BCA" === e ? P(k({}, h), {
                                terms: k({
                                    filters: y
                                }, _)
                            }) : ["BPA"].includes(e) ? P(k({}, h), {
                                terms: P(k({}, S), {
                                    brand: o,
                                    filters: g
                                })
                            }) : ["BCR", "BCB", "BCP"].includes(e) ? P(k({}, h), {
                                terms: k({}, w)
                            }) : ["CCC", "CTC"].includes(e) ? P(k({}, h), {
                                terms: P(k({}, _), {
                                    filters: y,
                                    filters_entry_point: ""
                                })
                            }) : "CAB" === e ? P(k({}, h), {
                                terms: P(k(k({}, w), S), {
                                    id_category: o
                                })
                            }) : "CAA" === e ? P(k({}, h), {
                                terms: P(k(k({}, w), S), {
                                    search_text: o,
                                    query_id: m,
                                    filters: g
                                })
                            }) : ["CBB", "CBA", "CBS", "CBU"].includes(e) ? P(k({}, h), {
                                terms: k(k({}, C), w)
                            }) : ["CCA", "CCR", "CCT", "CAR", "CBP", "CPA"].includes(e) ? k({}, h) : "CAR" === e ? P(k({}, h), {
                                terms: {
                                    search_text: s,
                                    catalog_value: n,
                                    catalog_type: a,
                                    query_id: m,
                                    filters: g
                                }
                            }) : "SPL" === e ? P(k({}, h), {
                                terms: k({}, I)
                            }) : ["SBB", "SBT", "SBC"].includes(e) ? P(k({}, h), {
                                terms: k(k({}, I), C)
                            }) : "SCA" === e ? P(k({}, h), {
                                terms: P(k({}, I), {
                                    category: s
                                })
                            }) : "SBR" === e ? P(k({}, h), {
                                terms: P(k({}, I), {
                                    brand_index: a
                                })
                            }) : ["SCB", "SCO", "SCP"].includes(e) ? P(k({}, h), {
                                terms: k({}, I)
                            }) : ["ABP", "ABC", "ABN"].includes(e) ? P(k({}, h), {
                                terms: P(k({
                                    parent_item_id: null == s ? void 0 : s.toString()
                                }, S), {
                                    brand: o,
                                    filters: g,
                                    filters_entry_point: b
                                })
                            }) : "IAC" === e ? P(k({}, h), {
                                terms: P(k({
                                    parent_item_id: null == s ? void 0 : s.toString()
                                }, S), {
                                    filters: g,
                                    filters_entry_point: b
                                })
                            }) : ["ICO", "ICB", "ICF", "ICV", "ICD", "ICR", "ICE", "ICS", "IBS", "ICL", "ICI", "ISC", "IAD"].includes(e) ? P(k({}, h), {
                                terms: k({
                                    parent_item_id: null == s ? void 0 : s.toString()
                                }, w)
                            }) : "ICA" === e ? P(k({}, h), {
                                terms: P(k({}, S), {
                                    parent_item_id: null == s ? void 0 : s.toString()
                                })
                            }) : "IAB" === e ? P(k({}, h), {
                                terms: k(k({}, C), w)
                            }) : ["IBP", "IBC", "ICC", "IRC", "ISP", "ITA"].includes(e) ? P(k({}, h), {
                                terms: k({}, w)
                            }) : "IBN" === e ? P(k({}, h), {
                                terms: {
                                    parent_item_id: null == s ? void 0 : s.toString(),
                                    filters: g,
                                    filters_entry_point: b
                                }
                            }) : ["CCM", "CPF", "CRA"].includes(e) ? P(k({}, h), {
                                terms: {
                                    item_ids: s
                                }
                            }) : "CSI" === e ? P(k({}, h), {
                                terms: {
                                    parent_item_id: null == s ? void 0 : s.toString()
                                }
                            }) : "CRV" === e ? P(k({}, h), {
                                terms: {
                                    empty_cart: s
                                }
                            }) : ["CCS", "CSA"].includes(e) ? P(k({}, h), {
                                terms: {}
                            }) : ["CRT", "CER", "CEB"].includes(e) ? k({}, h) : "CCB" === e ? P(k({}, h), {
                                terms: {
                                    item_ids: s,
                                    parent_item_id: null == n ? void 0 : n.toString(),
                                    subject_id: a,
                                    subject_parent_id: o,
                                    carousel_type: i
                                }
                            }) : ["DLV", "DCR", "DCV", "DRC", "DRE"].includes(e) ? P(k({}, h), {
                                terms: k({}, w)
                            }) : "TCB" === e ? P(k({}, h), {
                                terms: {
                                    parent_item_id: null == s ? void 0 : s.toString()
                                }
                            }) : "TCM" === e || ["FCR", "FCS", "FRP", "FCV"].includes(e) || ["VRW", "VCV"].includes(e) || ["AAA", "ADI", "AAB", "AAC", "AAS"].includes(e) || ["LCS", "LCR", "WTL"].includes(e) || ["WSH", "WCA", "WCV", "WCS", "WCR", "WAB"].includes(e) || "RWA" === e || ["NCV", "NCB", "NCM", "NCR"].includes(e) || "NIA" === e || ["PRC", "PCV"].includes(e) || "PPM" === e ? k({}, h) : ["FBR", "FBV"].includes(e) ? P(k({}, h), {
                                terms: k({}, w)
                            }) : "FBA" === e ? P(k({}, h), {
                                terms: P(k({}, S), {
                                    brand: o,
                                    filters: g
                                })
                            }) : "LBA" === e ? P(k({}, h), {
                                terms: k({}, w)
                            }) : "PCA" === e ? P(k({}, h), {
                                terms: P(k({}, w), {
                                    type: s,
                                    name: n,
                                    link: a
                                })
                            }) : "ITO" === e ? P(k({}, h), {
                                terms: {
                                    parent_item_id: null == s ? void 0 : s.toString(),
                                    type_of_block: n
                                }
                            }) : "LSP" === e ? P(k({}, h), {
                                sort: "default",
                                terms: {
                                    project_name: s
                                }
                            }) : ["PBC", "PBB"].includes(e) ? P(k({}, h), {
                                terms: k({}, C)
                            }) : ["PSA", "PBA", "PPA"].includes(e) ? P(k({}, h), {
                                terms: P(k({}, S), {
                                    bid: l,
                                    bid_index: c
                                })
                            }) : "PAP" === e ? P(k({}, h), {
                                terms: P(k({}, S), {
                                    category: l,
                                    id_category: c
                                })
                            }) : "PCB" === e ? P(k({}, h), {
                                terms: k({}, _)
                            }) : "PSP" === e ? P(k({}, h), {
                                terms: {
                                    parent_item_id: null == s ? void 0 : s.toString()
                                }
                            }) : "PCS" === e || ["WCI", "WCD"].includes(e) ? k({}, h) : "LCV" === e ? P(k({}, h), {
                                sort: "popular"
                            }) : ["TBV", "TBN", "TBC", "TBA", "TBP", "TBT"].includes(e) ? P(k({}, h), {
                                terms: k({}, C)
                            }) : "PVC" === e ? P(k({}, h), {
                                terms: {
                                    promo_name: s,
                                    promo_id: n,
                                    vendor_rate: a,
                                    vendor_id: o,
                                    vendor_index: i
                                }
                            }) : "PAC" === e ? P(k({}, h), {
                                terms: {
                                    promo_name: s,
                                    adv_id: n,
                                    adv_rate: a,
                                    promo_id: o,
                                    adv_type: i
                                }
                            }) : {}
                        }(e, t = t || c.getTermsFromTailObject(null == e ? void 0 : e.l, r))
                    },
                    tryGetAnaliticsCodeForSearchAdvert: function(e) {
                        switch (e) {
                        case "SNH":
                            return "ANH";
                        case "SNS":
                            return "ANS";
                        case "SHT":
                            return "AHT";
                        case "STC":
                            return "ATC";
                        case "SNT":
                            return "SAB";
                        case "SST":
                            return "AST";
                        case "AAA":
                            return "ADI";
                        case "MBB":
                            return "AMB";
                        case "PBC":
                            return "PBA";
                        case "PBB":
                            return "PPA";
                        case "PCB":
                            return "PAP";
                        case "CSD":
                        case "CSD":
                            return "CAD";
                        case "WLC":
                        case "WLC":
                            return "WLA";
                        case "WCI":
                        case "WCI":
                            return "WCD";
                        case "PVC":
                            return "PAC";
                        case "IBN":
                            return "ABN";
                        case "IBC":
                            return "ABC";
                        case "ICC":
                            return "IAC";
                        default:
                            return null
                        }
                    },
                    tryGetAdvertCode: function(e) {
                        switch (e) {
                        case "ANH":
                            return "SNH";
                        case "ANS":
                            return "SNS";
                        case "AHT":
                            return "SHT";
                        case "ATC":
                            return "STC";
                        case "SAB":
                            return "SNT";
                        case "AST":
                            return "SST";
                        case "ADI":
                            return "AAA";
                        default:
                            return null
                        }
                    },
                    getRecomendationsSplitterHeaders: async function() {
                        return await async function(e) {
                            var t;
                            const r = await w(e)
                              , s = WbSpaModel.prototype.$user.getUserInfo()
                              , n = (null != (t = null == s ? void 0 : s.uid) ? t : 0).toString();
                            let a = "";
                            (null == r ? void 0 : r.length) && r.forEach((e => {
                                a += `${e.key}=${e.value};`
                            }
                            ));
                            const o = new Headers;
                            return o.set("UserID", n),
                            o.set("Test-Properties", (null == a ? void 0 : a.substring(0, a.length - 1)) || ""),
                            o
                        }("rec")
                    },
                    checkDataInSplitterServiceV2: async function(e, t, r) {
                        let s = !1;
                        if (e) {
                            const n = await w(e);
                            for (let e = 0; e < n.length; e++)
                                n[e].key === t && n[e].value === r && (s = !0,
                                e = n.length)
                        }
                        return s
                    },
                    checkDataInSplitterServiceV2Sync: function(e, t, r) {
                        let s = !1;
                        if (e) {
                            const n = function(e) {
                                return WbSpaModel.prototype.$services.splitterService.getSplitInfoV2(e)
                            }(e);
                            for (let e = 0; e < n.length; e++)
                                n[e].key === t && n[e].value === r && (s = !0,
                                e = n.length)
                        }
                        return s
                    },
                    getSplitInfo: v,
                    getSplitInfoV2: w,
                    appendSplitInfoV2: async function(e, t) {
                        return WbSpaModel.prototype.$services.splitterService.appendSplitInfoV2(e, t)
                    },
                    getStatInfo: y,
                    updateStatInfo: function(e) {
                        const t = y();
                        t.moveFrom = h || "",
                        h = "",
                        function(e, t) {
                            try {
                                null == localStorage || localStorage.putObject(a, {
                                    info: e,
                                    expired: Date.now() + l
                                }),
                                t || (p = e)
                            } catch (e) {
                                console.warn("Saving analitics state has failed"),
                                console.error(e.message)
                            }
                        }(t, e)
                    },
                    sendWbaEcomStat: function(e, t, r, s) {
                        var n;
                        try {
                            if (!window.wba || (!s && !(null == t ? void 0 : t.length)) > 0)
                                return;
                            if ((r = null != r ? r : {}).hasOwnProperty("cookies_alert") || (r.cookies_alert = wb.spa.getMainLayout().cookiePolicy.check() ? 1 : 0),
                            r.hasOwnProperty("country") || (r.country = wb.settings.currentLocale),
                            !r.hasOwnProperty("cluster")) {
                                const e = WbSpaModel.prototype.$user.getUserClusters();
                                e && (r.cluster = e)
                            }
                            r.address = null != (n = this.currentAddress) ? n : "not_selected";
                            const a = (new Date).format("yyyy-MM-dd HH:mm:ss");
                            t.length && !s ? t.forEach((t => {
                                var s, n, o, i, l, c, u, d, p, h, m;
                                let g = {
                                    utcTime: a,
                                    id: null == (s = t.id) ? void 0 : s.toString(),
                                    nm: Number(t.id),
                                    chrt: Number(t.chrt),
                                    rid: null == (n = t.rid) ? void 0 : n.toString(),
                                    name: t.name,
                                    brand: t.brand,
                                    price: parseInt(t.price),
                                    inListIndex: parseInt(t.inListIndex) || 1,
                                    listName: t.listName,
                                    variant: null != (o = t.variant) ? o : "",
                                    quantity: 1,
                                    affiliation: `${null != (i = t.affiliation) ? i : ""}|${null != (l = t.storeId) ? l : ""}|${null != (c = t.deliveryType) ? c : ""}`,
                                    category: null != (u = t.category) ? u : "regular",
                                    category2: t.subjectId > 0 ? t.subjectId.toString() : "",
                                    category3: t.subjectParentId > 0 ? t.subjectParentId.toString() : "",
                                    coupon: `${null != (d = t.feedbacksCount) ? d : ""}|${null != (p = t.rating) ? p : ""}`,
                                    logs: null != (h = t.logs) ? h : "",
                                    tailObject: t.tailObject,
                                    is_available: t.is_available
                                };
                                if ("cart_del" === (null == r ? void 0 : r.type_remove) || "after_check_data" === (null == r ? void 0 : r.type_remove) || "card" === (null == r ? void 0 : r.type_add))
                                    return g.quantity = t.quantity,
                                    void window.wba("ec:addProduct", g);
                                if (window.wba("ec:setCurrency", WbSpaModel.prototype.$user.getCurrency()),
                                "add_to_wishlist" === e)
                                    window.wba("ec:addProduct", g);
                                else {
                                    const e = parseInt(t.quantity) || 1
                                      , r = !!t.rid && e > 1 && (null == (m = g.rid) ? void 0 : m.split(",")) || [];
                                    for (let t = 0; t < e; t++)
                                        (null == r ? void 0 : r.length) > t && (g = Object.assign({}, g),
                                        g.rid = r[t]),
                                        window.wba("ec:addProduct", g)
                                }
                            }
                            )) : window.wba("ec:setCurrency", WbSpaModel.prototype.$user.getCurrency()),
                            window.wba("ec:setAction", e),
                            window.wba("ec:send", r)
                        } catch (e) {
                            console.log("wba exception", e)
                        }
                    },
                    sendAddToCartEvent: async function(e, t) {
                        const {nmIds: r, wbStatModel: s} = e.reduce(( (e, t) => (null != t.code1S || e.nmIds.push(t.code1S),
                        null != t.cod1S || e.nmIds.push(t.cod1S),
                        e.wbStatModel.push({
                            nmId: t.cod1S ? t.cod1S : t.code1S,
                            size: t.characteristicId
                        }),
                        e)), {
                            nmIds: [],
                            wbStatModel: []
                        })
                          , n = await wb.xnm.getInfoForWbaStat(s)
                          , a = e.map((e => {
                            var r, s;
                            const a = t.find((t => t.cod1S == e.cod1S)) || t.find((t => t.code1S == e.cod1S))
                              , o = this.getStoreProp(e.stocks, "wh")
                              , i = this.getStoreProp(e.stocks, "dtype");
                            return {
                                id: e.cod1S,
                                chrt: e.characteristicId,
                                name: a.goodsName || a.name,
                                brand: a.brandName || a.brand,
                                price: null != (s = null == (r = n.get(e.code1S || e.cod1S)) ? void 0 : r.salePrice) ? s : 0,
                                inListIndex: parseInt(e.targetInfo.analiticsInfo.iid || 1),
                                listName: this.analiticsInfoToListName(e.targetInfo.analiticsInfo),
                                variant: a.colorName || a.color,
                                quantity: e.quantity,
                                affiliation: a.supplierId || a.sellerId,
                                storeId: o || a.wh,
                                deliveryType: (null == a ? void 0 : a.whDtype) || this.getDeliveryTypeForStat(i),
                                subjectId: a.subjectId,
                                subjectParentId: a.subjectParentId,
                                feedbacksCount: a.feedbacks,
                                rating: a.reviewRating || a.rating,
                                rid: a.rId,
                                logs: e.targetInfo.analiticsInfo.logs,
                                tailObject: this.getTailObjectFromAnalyticsInfo(e.targetInfo.analiticsInfo),
                                is_available: 1
                            }
                        }
                        ));
                        this.sendWbaEcomStat("add_to_cart", a, {
                            type_add: "list"
                        })
                    },
                    savePurchaseCheckout: function(e) {
                        sessionStorage.setItem(n, e)
                    },
                    getPurchaseCheckout: function() {
                        var e;
                        return null != (e = sessionStorage.getItem(n)) ? e : "not_found"
                    },
                    sendCarouselWbaEvent: function(e, t, r, s, n, a) {
                        "Carousel_All" === e && (h = "carousel");
                        let o = {
                            location: t = t || this.getState().l,
                            index: null == r ? void 0 : r.toString(),
                            item_id: null == s ? void 0 : s.toString(),
                            name: n
                        };
                        a && (o = Object.assign(o, a)),
                        this.sendEvent(e, o)
                    },
                    sendEvent: function(e, t={}) {
                        var r;
                        if (!window.wba)
                            return;
                        t.country = wb.settings.currentLocale;
                        const s = WbSpaModel.prototype.$user.getUserClusters();
                        s && (t.cluster = s),
                        t.address = null != (r = this.currentAddress) ? r : "not_selected",
                        "Header_T" === e && (t.type = "d" === wb.settings.displayMode ? "desktop" : "mobile"),
                        window.wba(e, t)
                    },
                    sendAddressSelection: function({source: e, deliveryType: t, addressId: r, address: s, isChanged: n}) {
                        const a = n ? "DLV_Address_Add_Ok" : "DLV_Address_Slt"
                          , o = {
                            location: e
                        };
                        "courier" === t ? (o.type = "CRR",
                        o.address_crr = s) : (o.type = "PUP",
                        o.pup_id = r.toString()),
                        this.sendEvent(a, o)
                    },
                    sendBannersWbaEvent: function(e, t, r, s, n="0", a, o, i=null) {
                        r = r || this.getState().l,
                        "Banner_T" === e && (h = "banner");
                        const l = {
                            name: null != t ? t : "",
                            location: r,
                            link: s,
                            index: (n = parseInt(n) + 1).toString(),
                            id: a,
                            promo: o ? "yes" : "no"
                        };
                        "MBT" === r && (l.tv_block = 1),
                        this.sendEvent(e, l),
                        i && this.sendTrackingPixel(i)
                    },
                    sendSessionStartEvent: function() {
                        const e = localStorage.getItem(t)
                          , r = Date.now();
                        localStorage.setItem(t, (r + 18e5).toString()),
                        e && e > r || this.sendEvent("session_start")
                    },
                    sendEventTmpl(e, ...t) {
                        if (!window.wba)
                            return;
                        const r = t.slice(0, -2)
                          , s = {};
                        if (r && r.length % 2 == 0)
                            for (let e = 0; e < r.length; e += 2)
                                s[r[e]] = r[e + 1];
                        this.sendEvent(e, s)
                    },
                    convertToAnaliticsState: M,
                    proceedAndSave(e, t, r, s, n, a, o, i, l) {
                        if ("string" != typeof e)
                            return;
                        const u = this.convertToAnaliticsState(e, t, r, s, n, a, o, i, l);
                        c.updateTailObjectDataFromHtml(u),
                        this.saveState(u)
                    },
                    updateAnalyticsFromQuery() {
                        const e = new URL(window.location.href);
                        if (document.referrer.indexOf("guru.wildberries.ru") > 0 && e.searchParams.has("externalSource") && e.searchParams.has("analyticsCode"))
                            this.saveState(e.searchParams.get("analyticsCode"), !1, !0);
                        else if (e.searchParams.has("listName")) {
                            const t = _(`||${e.searchParams.get("listName")}`);
                            this.saveState(t),
                            ["LLI", "AIL"].includes(t.l) && S({
                                special_project: t.t
                            })
                        } else
                            e.searchParams.has("analiticsCode") && this.saveState({
                                l: e.searchParams.get("analiticsCode")
                            }, !0)
                    },
                    saveState: T,
                    trySaveStateV2: function(e) {
                        const t = C(e);
                        return !!t && (T(I(t)),
                        S(t.tailObjectTerms),
                        !0)
                    },
                    updateState(e, t) {
                        const r = this.getState(!1);
                        let s = k(k({}, r), e);
                        !e.extraTerms && t && t[r.l] && (s = k(k({}, s), t[r.l])),
                        this.saveState(s)
                    },
                    getState(t=!0) {
                        var r;
                        let s = null != (r = sessionStorage.getObject(e)) ? r : i;
                        return t && s.extraL && (s.l = s.extraL,
                        s.extraTerms && (s = k(k({}, s), s.extraTerms))),
                        this._validateAndFix(s)
                    },
                    saveLastSearchAnaliticsData(e, t, s) {
                        sessionStorage.setItem(r, `${e}&${t}&${s}`)
                    },
                    saveLastSearchAnalyticsDataForSuggest(e) {
                        sessionStorage.setItem(s, e)
                    },
                    saveQueryIdForSearch(e) {
                        sessionStorage.setItem(o, e)
                    },
                    retrieveQueryIdForSearch() {
                        const e = sessionStorage.getItem(o);
                        if (e)
                            return e;
                        {
                            const e = this.getTermByTermName("qid");
                            return this.saveQueryIdForSearch(e),
                            e
                        }
                    },
                    getLastSearchAnaliticsData() {
                        var e;
                        return null != (e = sessionStorage.getItem(r)) ? e : ""
                    },
                    getLastSearchAnalyticsDataForSuggest() {
                        var e;
                        return null != (e = sessionStorage.getItem(s)) ? e : ""
                    },
                    _validateAndFix(e) {
                        return (null == e.iid || isNaN(e.iid) || e.iid < 1) && (e.iid = 1),
                        e.t = this._escape(e.t),
                        e.t1 = this._escape(e.t1),
                        e.t2 = this._escape(e.t2),
                        e
                    },
                    _escape(e) {
                        return e ? "string" != typeof e ? e : e.replace(/'/g, " ") : ""
                    },
                    async isAbTest155Approved() {
                        const {splitId: e, title: t} = await v();
                        return "155" === e && "test_1" === t
                    },
                    sendUserEvent(e, t) {
                        this.sendEvent("user_id", {
                            clientId: e,
                            account_id: t
                        })
                    },
                    setCurrentAddress(e, t) {
                        this.currentAddress = `${"courier" === e ? "CRR" : ""}${t}`
                    },
                    saveLastViewedNm(e) {
                        sessionStorage.putObject("LAST_VIEWED_NM", e)
                    },
                    getLastViewedNm() {
                        return sessionStorage.getObject("LAST_VIEWED_NM")
                    },
                    updateAnalyticsSource(e) {
                        this.updateState({
                            source: e
                        })
                    },
                    sendTrackingPixel(e) {
                        document.createElement("img").src = e
                    }
                }
            }
            )())
        },
        80776: function(e) {
            var t = {
                utf8: {
                    stringToBytes: function(e) {
                        return t.bin.stringToBytes(unescape(encodeURIComponent(e)))
                    },
                    bytesToString: function(e) {
                        return decodeURIComponent(escape(t.bin.bytesToString(e)))
                    }
                },
                bin: {
                    stringToBytes: function(e) {
                        for (var t = [], r = 0; r < e.length; r++)
                            t.push(255 & e.charCodeAt(r));
                        return t
                    },
                    bytesToString: function(e) {
                        for (var t = [], r = 0; r < e.length; r++)
                            t.push(String.fromCharCode(e[r]));
                        return t.join("")
                    }
                }
            };
            e.exports = t
        },
        48756: function(e) {
            var t, r;
            t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            r = {
                rotl: function(e, t) {
                    return e << t | e >>> 32 - t
                },
                rotr: function(e, t) {
                    return e << 32 - t | e >>> t
                },
                endian: function(e) {
                    if (e.constructor == Number)
                        return 16711935 & r.rotl(e, 8) | 4278255360 & r.rotl(e, 24);
                    for (var t = 0; t < e.length; t++)
                        e[t] = r.endian(e[t]);
                    return e
                },
                randomBytes: function(e) {
                    for (var t = []; e > 0; e--)
                        t.push(Math.floor(256 * Math.random()));
                    return t
                },
                bytesToWords: function(e) {
                    for (var t = [], r = 0, s = 0; r < e.length; r++,
                    s += 8)
                        t[s >>> 5] |= e[r] << 24 - s % 32;
                    return t
                },
                wordsToBytes: function(e) {
                    for (var t = [], r = 0; r < 32 * e.length; r += 8)
                        t.push(e[r >>> 5] >>> 24 - r % 32 & 255);
                    return t
                },
                bytesToHex: function(e) {
                    for (var t = [], r = 0; r < e.length; r++)
                        t.push((e[r] >>> 4).toString(16)),
                        t.push((15 & e[r]).toString(16));
                    return t.join("")
                },
                hexToBytes: function(e) {
                    for (var t = [], r = 0; r < e.length; r += 2)
                        t.push(parseInt(e.substr(r, 2), 16));
                    return t
                },
                bytesToBase64: function(e) {
                    for (var r = [], s = 0; s < e.length; s += 3)
                        for (var n = e[s] << 16 | e[s + 1] << 8 | e[s + 2], a = 0; a < 4; a++)
                            8 * s + 6 * a <= 8 * e.length ? r.push(t.charAt(n >>> 6 * (3 - a) & 63)) : r.push("=");
                    return r.join("")
                },
                base64ToBytes: function(e) {
                    e = e.replace(/[^A-Z0-9+\/]/gi, "");
                    for (var r = [], s = 0, n = 0; s < e.length; n = ++s % 4)
                        0 != n && r.push((t.indexOf(e.charAt(s - 1)) & Math.pow(2, -2 * n + 8) - 1) << 2 * n | t.indexOf(e.charAt(s)) >>> 6 - 2 * n);
                    return r
                }
            },
            e.exports = r
        },
        86089: function(e) {
            function t(e) {
                return !!e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e)
            }
            e.exports = function(e) {
                return null != e && (t(e) || function(e) {
                    return "function" == typeof e.readFloatLE && "function" == typeof e.slice && t(e.slice(0, 0))
                }(e) || !!e._isBuffer)
            }
        },
        34832: function(e, t, r) {
            var s, n, a, o, i;
            s = r(48756),
            n = r(80776).utf8,
            a = r(86089),
            o = r(80776).bin,
            (i = function(e, t) {
                e.constructor == String ? e = t && "binary" === t.encoding ? o.stringToBytes(e) : n.stringToBytes(e) : a(e) ? e = Array.prototype.slice.call(e, 0) : Array.isArray(e) || e.constructor === Uint8Array || (e = e.toString());
                for (var r = s.bytesToWords(e), l = 8 * e.length, c = 1732584193, u = -271733879, d = -1732584194, p = 271733878, h = 0; h < r.length; h++)
                    r[h] = 16711935 & (r[h] << 8 | r[h] >>> 24) | 4278255360 & (r[h] << 24 | r[h] >>> 8);
                r[l >>> 5] |= 128 << l % 32,
                r[14 + (l + 64 >>> 9 << 4)] = l;
                var m = i._ff
                  , g = i._gg
                  , y = i._hh
                  , b = i._ii;
                for (h = 0; h < r.length; h += 16) {
                    var f = c
                      , v = u
                      , w = d
                      , S = p;
                    c = m(c, u, d, p, r[h + 0], 7, -680876936),
                    p = m(p, c, u, d, r[h + 1], 12, -389564586),
                    d = m(d, p, c, u, r[h + 2], 17, 606105819),
                    u = m(u, d, p, c, r[h + 3], 22, -1044525330),
                    c = m(c, u, d, p, r[h + 4], 7, -176418897),
                    p = m(p, c, u, d, r[h + 5], 12, 1200080426),
                    d = m(d, p, c, u, r[h + 6], 17, -1473231341),
                    u = m(u, d, p, c, r[h + 7], 22, -45705983),
                    c = m(c, u, d, p, r[h + 8], 7, 1770035416),
                    p = m(p, c, u, d, r[h + 9], 12, -1958414417),
                    d = m(d, p, c, u, r[h + 10], 17, -42063),
                    u = m(u, d, p, c, r[h + 11], 22, -1990404162),
                    c = m(c, u, d, p, r[h + 12], 7, 1804603682),
                    p = m(p, c, u, d, r[h + 13], 12, -40341101),
                    d = m(d, p, c, u, r[h + 14], 17, -1502002290),
                    c = g(c, u = m(u, d, p, c, r[h + 15], 22, 1236535329), d, p, r[h + 1], 5, -165796510),
                    p = g(p, c, u, d, r[h + 6], 9, -1069501632),
                    d = g(d, p, c, u, r[h + 11], 14, 643717713),
                    u = g(u, d, p, c, r[h + 0], 20, -373897302),
                    c = g(c, u, d, p, r[h + 5], 5, -701558691),
                    p = g(p, c, u, d, r[h + 10], 9, 38016083),
                    d = g(d, p, c, u, r[h + 15], 14, -660478335),
                    u = g(u, d, p, c, r[h + 4], 20, -405537848),
                    c = g(c, u, d, p, r[h + 9], 5, 568446438),
                    p = g(p, c, u, d, r[h + 14], 9, -1019803690),
                    d = g(d, p, c, u, r[h + 3], 14, -187363961),
                    u = g(u, d, p, c, r[h + 8], 20, 1163531501),
                    c = g(c, u, d, p, r[h + 13], 5, -1444681467),
                    p = g(p, c, u, d, r[h + 2], 9, -51403784),
                    d = g(d, p, c, u, r[h + 7], 14, 1735328473),
                    c = y(c, u = g(u, d, p, c, r[h + 12], 20, -1926607734), d, p, r[h + 5], 4, -378558),
                    p = y(p, c, u, d, r[h + 8], 11, -2022574463),
                    d = y(d, p, c, u, r[h + 11], 16, 1839030562),
                    u = y(u, d, p, c, r[h + 14], 23, -35309556),
                    c = y(c, u, d, p, r[h + 1], 4, -1530992060),
                    p = y(p, c, u, d, r[h + 4], 11, 1272893353),
                    d = y(d, p, c, u, r[h + 7], 16, -155497632),
                    u = y(u, d, p, c, r[h + 10], 23, -1094730640),
                    c = y(c, u, d, p, r[h + 13], 4, 681279174),
                    p = y(p, c, u, d, r[h + 0], 11, -358537222),
                    d = y(d, p, c, u, r[h + 3], 16, -722521979),
                    u = y(u, d, p, c, r[h + 6], 23, 76029189),
                    c = y(c, u, d, p, r[h + 9], 4, -640364487),
                    p = y(p, c, u, d, r[h + 12], 11, -421815835),
                    d = y(d, p, c, u, r[h + 15], 16, 530742520),
                    c = b(c, u = y(u, d, p, c, r[h + 2], 23, -995338651), d, p, r[h + 0], 6, -198630844),
                    p = b(p, c, u, d, r[h + 7], 10, 1126891415),
                    d = b(d, p, c, u, r[h + 14], 15, -1416354905),
                    u = b(u, d, p, c, r[h + 5], 21, -57434055),
                    c = b(c, u, d, p, r[h + 12], 6, 1700485571),
                    p = b(p, c, u, d, r[h + 3], 10, -1894986606),
                    d = b(d, p, c, u, r[h + 10], 15, -1051523),
                    u = b(u, d, p, c, r[h + 1], 21, -2054922799),
                    c = b(c, u, d, p, r[h + 8], 6, 1873313359),
                    p = b(p, c, u, d, r[h + 15], 10, -30611744),
                    d = b(d, p, c, u, r[h + 6], 15, -1560198380),
                    u = b(u, d, p, c, r[h + 13], 21, 1309151649),
                    c = b(c, u, d, p, r[h + 4], 6, -145523070),
                    p = b(p, c, u, d, r[h + 11], 10, -1120210379),
                    d = b(d, p, c, u, r[h + 2], 15, 718787259),
                    u = b(u, d, p, c, r[h + 9], 21, -343485551),
                    c = c + f >>> 0,
                    u = u + v >>> 0,
                    d = d + w >>> 0,
                    p = p + S >>> 0
                }
                return s.endian([c, u, d, p])
            }
            )._ff = function(e, t, r, s, n, a, o) {
                var i = e + (t & r | ~t & s) + (n >>> 0) + o;
                return (i << a | i >>> 32 - a) + t
            }
            ,
            i._gg = function(e, t, r, s, n, a, o) {
                var i = e + (t & s | r & ~s) + (n >>> 0) + o;
                return (i << a | i >>> 32 - a) + t
            }
            ,
            i._hh = function(e, t, r, s, n, a, o) {
                var i = e + (t ^ r ^ s) + (n >>> 0) + o;
                return (i << a | i >>> 32 - a) + t
            }
            ,
            i._ii = function(e, t, r, s, n, a, o) {
                var i = e + (r ^ (t | ~s)) + (n >>> 0) + o;
                return (i << a | i >>> 32 - a) + t
            }
            ,
            i._blocksize = 16,
            i._digestsize = 16,
            e.exports = function(e, t) {
                if (null == e)
                    throw new Error("Illegal argument " + e);
                var r = s.wordsToBytes(i(e, t));
                return t && t.asBytes ? r : t && t.asString ? o.bytesToString(r) : s.bytesToHex(r)
            }
        },
        92254: function(e, t, r) {
            "use strict";
            r.d(t, {
                O: function() {
                    return i
                },
                c: function() {
                    return o
                }
            });
            var s = r(13433)
              , n = Object.defineProperty
              , a = (e, t, r) => ( (e, t, r) => t in e ? n(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
            class o {
                constructor(e={}) {
                    return a(this, "observers", new Map),
                    a(this, "updateInProgress", !1),
                    a(this, "pendingNotifications", new Set),
                    this.checkForConflicts(e),
                    (0,
                    s.RI)(e) || Object.entries(e).forEach(( ([e,t]) => {
                        this.defineObservableProperty(e, t)
                    }
                    )),
                    new Proxy(this,{
                        set: (e, t, r) => {
                            if (!(0,
                            s.Kg)(t))
                                throw new TypeError("Property must be a string, got " + typeof t);
                            return e[t] !== r && (e[t] = r,
                            this.updateInProgress ? this.pendingNotifications.add(t) : this.notifyObservers(t)),
                            !0
                        }
                        ,
                        get: (e, t) => {
                            if (t)
                                return e[t]
                        }
                    })
                }
                subscribe(e, t) {
                    const r = String(e);
                    this.observers.has(r) || this.observers.set(r, new Set),
                    this.observers.get(r).add(t)
                }
                unsubscribe(e, t) {
                    var r;
                    const s = String(e);
                    null == (r = this.observers.get(s)) || r.delete(t)
                }
                update(e) {
                    this.updateInProgress = !0,
                    Object.entries(e).forEach(( ([e,t]) => {
                        this[e] = t
                    }
                    )),
                    this.updateInProgress = !1,
                    this.pendingNotifications.forEach((e => this.notifyObservers(e))),
                    this.pendingNotifications.clear()
                }
                notifyObservers(e) {
                    var t;
                    const r = String(e);
                    null == (t = this.observers.get(r)) || t.forEach((e => e()))
                }
                checkForConflicts(e) {
                    const t = Object.getOwnPropertyNames(Object.getPrototypeOf(this))
                      , r = Object.keys(e).filter((e => t.includes(e)));
                    r.length > 0 && console.warn(`Observable initialization warning: The following keys in the initial state conflict with properties in the prototype: ${r.join(", ")}.`)
                }
                defineObservableProperty(e, t) {
                    Object.defineProperty(this, e, {
                        configurable: !0,
                        enumerable: !0,
                        writable: !0,
                        value: t
                    })
                }
            }
            const i = (e={}) => new o(e)
        },
        33036: function(e, t, r) {
            "use strict";
            r.d(t, {
                Aj: function() {
                    return n
                },
                D4: function() {
                    return l
                },
                E$: function() {
                    return u
                },
                F3: function() {
                    return i
                },
                F8: function() {
                    return h
                },
                Ho: function() {
                    return o
                },
                R0: function() {
                    return c
                },
                XX: function() {
                    return s
                },
                YM: function() {
                    return p
                },
                g2: function() {
                    return a
                },
                of: function() {
                    return m
                },
                sk: function() {
                    return d
                }
            });
            const s = "https://card.wb.ru/cards/v2/list"
              , n = "https://card.wb.ru/cards/v2/detail"
              , a = "https://catalog.wb.ru/"
              , o = "https://user-geo-data.wildberries.ru/"
              , i = "https://cart-storage-api.wildberries.ru/api/basket"
              , l = "https://favs-storage-api.wildberries.ru/api/favs"
              , c = "https://wbx-auth.wildberries."
              , u = "https://ru-basket-api.wildberries.ru"
              , d = "https://basket-api.wildberries."
              , p = "https://wbx-bell-v3.wildberries.ru"
              , h = "https://shopper-bt.wb.ru"
              , m = "https://fin-person-installment.wildberries.ru"
        },
        13433: function(e, t, r) {
            "use strict";
            r.d(t, {
                Kg: function() {
                    return s
                },
                RI: function() {
                    return a
                },
                b0: function() {
                    return n
                }
            });
            const s = e => "string" == typeof e
              , n = e => void 0 === e
              , a = e => 0 === Object.keys(e).length
        },
        17728: function(e) {
            "use strict";
            e.exports = JSON.parse('{"common":{"goToMainPageBtn":"Перейти на главную","goToMainPage_short":"На главную","toTheTopPage":"К началу страницы","goToCatalog":"Перейти в каталог","goToPromotionPage":"На страницу акции","goTo":"Перейти","supplier":"Поставщик","seller":"Продавец","goBack":"Назад","goForward":"Вперёд","close":"Закрыть","clear":"Очистить","hide":"Скрыть","cancel":"Отмена","cancelBtn":"Отменить","toSend":"Отправить","toChoose":"Выбрать","removeBtn":"Удалить","update":"Обновить","reload":"Перезагрузить","yes":"Да","no":"Нет","toggle":"Переключатель","toggleContent":{"showMore":"Показать ещё","showMore_short":"Ещё","collapse":"Свернуть","moreDetailed":"Подробнее","expandBlock":"Раскрыть блок","showHide":"Показать/Скрыть"},"done":"Готово","goodBtn":"Хорошо","okBtn":"Понятно","okay":"ОК","comment":"Комментарий","photo":"Фото","video":"Видео","and":"и","anonymBuyerName":"Покупатель Wildberries","anonymBuyerName_short":"Покупатель WB","complainAnswer":"Пожаловаться на ответ","today":"Сегодня","todayMorning":"Сегодня утром","todayFrom":"Сегодня с {{slot}}","tomorrow":"Завтра","tomorrowMorning":"Завтра утром","tomorrowFrom":"Завтра с {{slot}}","dayAfterTomorrow":"Послезавтра","yesterday":"Вчера","toBuy":"Купить","currency":"Валюта","saveBtn":"Сохранить","continueBtn":"Продолжить","phoneNumber":"Номер телефона","enterCodeFromSms":"Введите код из СМС","getCodeBtn":"Получить код","enterBtn":"Войти","logo":"Логотип","time":{"year":{"plural_one":"{{displayCount}} год","plural_few":"{{displayCount}} года","plural_many":"{{displayCount}} лет"},"month":{"plural_one":"{{displayCount}} месяц","plural_few":"{{displayCount}} месяца","plural_many":"{{displayCount}} месяцев"},"forMonths":{"plural_one":"на {{displayCount}} месяц","plural_few":"на {{displayCount}} месяца","plural_many":"на {{displayCount}} месяцев"},"month_short":{"plural_one":"{{displayCount}} мес","plural_few":"{{displayCount}} мес","plural_many":"{{displayCount}} мес"},"days":{"plural_one":"{{displayCount}} день","plural_few":"{{displayCount}} дня","plural_many":"{{displayCount}} дней"},"daysGenitive":{"plural_one":"{{displayCount}} дня","plural_few":"{{displayCount}} дней","plural_many":"{{displayCount}} дней"},"hour":{"plural_one":"{{displayCount}} час","plural_few":"{{displayCount}} часа","plural_many":"{{displayCount}} часов"},"hour_short":{"plural_one":"{{displayCount}} ч","plural_few":"{{displayCount}} ч","plural_many":"{{displayCount}} ч"},"hourGenitive":{"plural_one":"{{displayCount}} часа","plural_few":"{{displayCount}} часов","plural_many":"{{displayCount}} часов"},"minute":{"plural_one":"{{displayCount}} минута","plural_few":"{{displayCount}} минуты","plural_many":"{{displayCount}} минут"},"minute_short":{"plural_one":"{{displayCount}} мин","plural_few":"{{displayCount}} мин","plural_many":"{{displayCount}} мин"},"minuteGenitive":{"plural_one":"{{displayCount}} минуты","plural_few":"{{displayCount}} минут","plural_many":"{{displayCount}} минут"},"second":{"plural_one":"{{displayCount}} секунда","plural_few":"{{displayCount}} секунды","plural_many":"{{displayCount}} секунд"},"second_short":{"plural_one":"{{displayCount}} сек","plural_few":"{{displayCount}} сек","plural_many":"{{displayCount}} сек"},"secondGenitive":{"plural_one":"{{displayCount}} секунды","plural_few":"{{displayCount}} секунд","plural_many":"{{displayCount}} секунд"},"timePeriodHour":{"plural_one":"За {{displayCount}} час","plural_few":"За {{displayCount}} часа","plural_many":"За {{displayCount}} часов"},"todayTimePeriodHour":{"plural_one":"Сегодня за {{displayCount}} час","plural_few":"Сегодня за {{displayCount}} часа","plural_many":"Сегодня за {{displayCount}} часов"}},"dates":{"dayNamesShort":{"sun":"вс","mon":"пн","tue":"вт","wed":"ср","thu":"чт","fri":"пт","sat":"сб"},"dayNamesLong":{"sun":"воскресенье","mon":"понедельник","tue":"вторник","wed":"среда","thu":"четверг","fri":"пятница","sat":"суббота"},"monthNamesShort":{"jan":"янв","feb":"февр","mar":"марта","apr":"апр","may":"мая","jun":"июня","jul":"июля","aug":"авг","sep":"сент","oct":"окт","nov":"нояб","dec":"дек"},"monthNamesLong":{"jan":"Январь","feb":"Февраль","mar":"Март","apr":"Апрель","may":"Май","jun":"Июнь","jul":"Июль","aug":"Август","sep":"Сентябрь","oct":"Октябрь","nov":"Ноябрь","dec":"Декабрь"},"monthNamesGenitive":{"jan":"января","feb":"февраля","mar":"марта","apr":"апреля","may":"мая","jun":"июня","jul":"июля","aug":"августа","sep":"сентября","oct":"октября","nov":"ноября","dec":"декабря"}},"goodsWithCount":{"plural_one":"{{displayCount}} товар","plural_few":"{{displayCount}} товара","plural_many":"{{displayCount}} товаров"},"statusWithCount":{"plural_one":"{{displayCount}} статус","plural_few":"{{displayCount}} статуса","plural_many":"{{displayCount}} статусов"},"seeAll":"Смотреть все","seeAll_short":"См. все","sizeMatch":{"bigger":"Большемерит","ok":"Соответствует размеру","ok_short":"Соответствует","smaller":"Маломерит"},"formValidation":{"currentLength":"Введено символов","minLength":"От {{minLength}} символов","msgRequired":"Заполните поле","tooManyCharacters":"Слишком много символов","incorrectDate":"Неверная дата"},"humanTimer":{"timeIsUp":"время закончилось","timeInWords":"{{hours}} ч {{minutes}} мин {{seconds}} сек","remainingTime":{"plural_one":"остался {{displayCount}}","plural_few":"осталось {{displayCount}}","plural_many":"осталось {{displayCount}}"},"remainingDays":{"plural_one":"остался {{displayCount}} день","plural_few":"осталось {{displayCount}} дня","plural_many":"осталось {{displayCount}} дней"}},"tryAgain":"Попробовать ещё раз","pleaseTryAgain":"Пожалуйста, попробуйте еще раз или&nbsp;повторите попытку позже","error":"Ошибка","errors":{"errorHasOccurred":"Произошла ошибка","tryAgainLater":"Произошла ошибка, попробуйте позже","lostConnectionTryLater":"Потеряли связь с сервисом, но скоро все заработает. Попробуйте позже","criticalError":"Произошла критическая ошибка. Пожалуйста, попробуйте обновить страницу","tryRefreshPage":"Мы уже делаем всё возможное, чтобы её исправить. Пожалуйста, попробуйте обновить страницу"},"btn":"Кнопка","increaseCount":"Увеличить количество","decreaseCount":"Уменьшить количество","proceedToPayment":"Перейти к оплате","forPayment":"К оплате","open":"Открыть","goToPurchases":"Перейти в покупки","viewSite":"Смотреть на сайте","quantity":"{{quantity}} шт","bytes":{"byte":"Б","kilobyte":"КБ","megabyte":"МБ","gigabyte":"ГБ"},"promoCodeCouponSale":"Промокод {{couponSale}}%","sale":"Распродажа","seeSimilar":"Смотреть похожие","seeSimilar_short":"Похожие","similarProducts":"Похожие товары","youRecentlyViewed":"Вы недавно смотрели","noProductsFound":"Товары не найдены","backInStock":"Снова в наличии","photoIsMissing":"Фото отсутствует","outOfStock":"Нет в наличии","noRatings":"Нет оценок","preOrder":"Предзаказ","previousPage":"Предыдущая страница","nextPage":"Следующая страница","prevSlide":"Предыдущий слайд","nextSlide":"Следующий слайд","savingWithColon":"Сохранение...","discountsHere":"Скидки тут","salesHits":"Хиты продаж","new":"Новое","great":"Отлично","countries":{"ru":"Россия","am":"Армения","by":"Беларусь","kz":"Казахстан","kg":"Киргизия","uz":"Узбекистан","cn":"Китай","mo-hk":"Макао и Гонконг","tw":"Тайвань","tj":"Таджикистан"}},"pageTitles":{"brandList":"Наши бренды","delivery":"Доставки","purchases":"Покупки","favorites":"Избранное","profile":"Профиль","basket":"Корзина","paymentMethods":"Способы оплаты","wbWallet":"WB Кошелёк","wbDiscount":"WB скидка","balance":"Баланс","communications":"Обращения","feedbackAndQuestions":"Отзывы и вопросы","feedback":"Отзывы","questions":"Вопросы"},"errorPages":{"error404":{"notFound":"По Вашему запросу ничего не найдено"},"error500":{"somethingWentWrong":"Что-то пошло не так","pleaseTryAgainLater":"Мы уже делаем все возможное, чтобы это исправить. Попробуйте повторить попытку позднее. А пока вы можете продолжить выбирать товары."},"loadingError":{"pageDidNotLoad":"Cтраница не загрузилась","dontWorry":"Не волнуйтесь, данные не пропали. <br>Иногда помогает перезагрузка"}},"basket":{"emptyBasket":{"title":"В корзине пока пусто","description":"Загляните на главную, чтобы выбрать товары или&nbsp;найдите нужное в поиске","goToMainPageBtn":"$t(common.goToMainPageBtn)"},"inBasket":"В корзине"},"favorites":{"emptyFavorites":{"favoritesAreEmptyForNow":"В избранном пока пусто","saveProductsYouLike":"Сохраняйте товары, которые понравились, чтобы долго не&nbsp;искать"},"favoriteBrands":{"addToFavorites":"Добавить в любимые бренды","removeFromFavorites":"Удалить из любимых брендов"},"byDateAdded":"По дате добавления ↓","selectSort":"Выбрать сортировку","productIsNoLongerForSale":"Товар больше не продается","showSimilarProducts":"Показать похожие товары","discountSale":"Скидка {{sale}}%","wbDiscountPersonalSale":"WB скидка {{personalSale}}%","nameBrandArticleColor":"Название, бренд, артикул, цвет","productWasRemovedFromFavorites":"Товар удалён из избранного","productAddedToBasket":"Товар добавлен в корзину"},"favoriteBrand":{"newItemsCount":"Новинки: <span>{{count}}</span>","emptyFavoriteBrand":{"noFavoriteBrands":"Любимых брендов пока нет","clickHeartInBrandCatalog":"Нажмите сердечко в&nbsp;каталоге бренда, чтобы сохранить&nbsp;его и&nbsp;раньше всех узнавать о&nbsp;новинках"}},"feedbacks":{"feedbacksCount":{"plural_one":"{{displayCount}} оценка","plural_few":"{{displayCount}} оценки","plural_many":"{{displayCount}} оценок"}},"payment":{"couldNotBeDebitedWithValue":"Не удалось списать {{- amount}}","weWillDebitOnDateWithValue":"{{textDay}} спишем {{- amount}}","forOrderWithPartialPayment":"За заказ с оплатой частями"},"recommendations":{"weRecommend":"Рекомендуем","recommendForYou":"Рекомендуем для вас","recommendationsForYou":"Рекомендации для вас","watchAllShort":"$t(common.seeAll_short)","watchAll":"$t(common.seeAll)","viewed":"Вы смотрели","usefulForShopping":"Пригодится к покупкам","seeAlso":"Смотрите также","similarInPhotos":"Похожие по фото","buyTogetherWithThisProduct":"С этим товаром покупают","todayIsTop":"Сегодня в топе","mayBeInterestedIn":"Возможно, вас заинтересует","personalRecommendations":"Персональные рекомендации","recommendWithGoods":"С товаром рекомендуют","buyWithThisGoods":"С этим покупают","promo":"Промотовары","hitOfSales":"Хит продаж","discountsHere":"Скидки тут"},"catalog":{"allFilters":"Все фильтры","filters":"Фильтры","closeFilter":"Закрыть фильтр","sortBy":{"popular":"По популярности","priceDown":"По убыванию цены","priceUp":"По возрастанию цены","newly":"По новинкам","rate":"По рейтингу","sale":"По скидке","benefit":"Сначала выгодные","benefitTip":"Покажем товары, на которые недавно снизилась цена","original":"Оригинал"},"priceFromTo":"от {{- min}} до {{- max}}","priceFrom":"От","priceUpTo":"До","originalTip":"Продавец подтверждает,<br>что товар оригинальный","goodsWithDiscount":"Товары со скидкой по подписке клуба","moneyForReview":"За отзывы на эти товары можно<br>получить деньги","premiumQualityGoods":"У товаров Премиум-продавцов<br>высокие оценки и мало возвратов","resetAll":"Сбросить все","show":"Показать","showAll":"Показать все","reset":"Сбросить","resetFilters":"Сбросить фильтры","filtredGoodsNotFounded":"Не нашлось подходящих товаров","findInList":"Найти в списке","tryToChangeParams":"Попробуйте поменять параметры или {{- startTag}}сбросить фильтры{{- endTag}}","cardSize":"Размер карточки","allCategories":"Все категории","categories":"Категории","filter":"Фильтр","notFound":"Ничего не нашлось","findGoods":{"plural_one":"Нашли {{displayCount}} товар","plural_few":"Нашли {{displayCount}} товара","plural_many":"Нашли {{displayCount}} товаров"},"all":"Все","showGoodsCount":{"plural_one":"Показать {{displayCount}} товар","plural_few":"Показать {{displayCount}} товара","plural_many":"Показать {{displayCount}} товаров"},"anyMale":"Любой","anyFemale":"Любая","upTo4hours":"2–4 часа","upTo3Days":"До 3 дней","upTo5Days":"До 5 дней","selectedValuesFromTo":"от {{from}} до {{to}}"},"brands":{"allBrands":"Все бренды","allBrandsStartingWith":"Все бренды на {{letterName}}","brandByLetter":"Бренды на «{{currentLetterName}}»","title":"Страницы брендов","description":"На этих страницах вы найдете не&nbsp;только каталог товаров, но&nbsp;и&nbsp;массу интересной информации: историю брендов, новости, статьи о&nbsp;технологиях производства и&nbsp;многое другое.","popularBrand":"Популярные бренды","thereNoGoods":"Товаров пока нет"},"confirmAdultPopup":{"confirmYourAge":"Подтвердите свой возраст","eighteenPlusTip":"Данный раздел предназначен только для посетителей, достигших возраста 18 лет!","eighteenPlusConfirm":"Да, мне есть 18 лет"},"wbWallet":{"wallet":"Кошелёк","withWbWallet":"с WB Кошельком","main":"Основной","topUpBtn":"Пополнить","transferMoney":"Перевести","moreWalletFeatures":"Ещё возможности","createWalletForFree":"Создать бесплатно","giftsAndBonuses":"Подарки и бонусы","wbWalletTransactions":"Операции по WB Кошельку","increaseLimit":"Увеличить лимит","increaseWalletLimit":"Увеличить до 60 000 <b>₽</b>","howToFindOutStatus":"Чтобы узнать статус, {{- tagStart}}перезагрузите страницу{{- tagEnd}}","errorOfIncreasingTheWalletsCapabilities":"Не получилось увеличить<br> возможности кошелька","requestsForWithdrawalOfFunds":"Заявки на вывод:","dscountPercentAtTime":"Со скидкой WB Кошелька {{- tagStart}}{{discountPercent}}%{{- tagEnd}}<br>за раз можно платить до 15 000 <b>₽</b>","discountIfPayWithWallet":"Скидка {{- tagStart}}{{discountPercent}}%{{- tagEnd}} на заказы до 15 000 <b>₽</b>,<br>если платить WB Кошельком","maxDiscountPercentAtTime":"Cо скидкой {{- tagStart}}{{discountPercent}}%{{- tagEnd}} от WB Кошелька <br>можно платить до 60 000 <b>₽</b> за раз","giftBonuses":"Подарочные бонусы","openWallet":"Открыть кошелёк","amountInWallet":"В кошельке:","sumInWallet":"В кошельке {{- amount}}","replenishmentWBWallet":"Пополнение WB Кошелька","ok":"Хорошо","great":"Отлично","needConsent":"Нужно ваше согласие","moneyInWallet":"Готово, деньги в WB Кошельке","moneyWasCredited":"Зачислили деньги на баланс: <br>создать кошелёк не получилось","certificateIsActivated":"Сертификат активирован","date":"Дата","amount":"Сумма","status":"Статус","insufficientFunds":"Недостаточно средств","processedByBank":"Обрабатывается банком","refundSuccessful":"Возврат прошел успешно","refundFailed":"Возврат не прошел","requisites":"Реквизиты","paymentInCashUponReceipt":"Оплата наличными при получении","paymentByCardUponReceipt":"Оплата картой при получении","paymentByCardOnline":"Оплата картой онлайн","paymentFromWallet":"Оплата с WB Кошелька","paymentFromBalance":"Оплата с баланса","paymentWithBonuses":"Оплата бонусами","paymentInInstallments":"Оплата в рассрочку","accrualOfBonuses":"Начисление бонусов","transferMoneyFromWallet":"Из кошелька","needToIncreaseLimit":"Для перевода нужно увеличить лимит&nbsp;— понадобится подтвердить данные на&nbsp;Госуслугах","translations":"Переводы","confirmDataToIncreaseLimit":"Подтвердите данные, чтобы&nbsp;увеличить лимит","operationNotification":"Оповещения об операциях","notificationsAndStatement":"Уведомления и выписка","createWBWallet":"Создайте WB&nbsp;Кошелёк","moneyFromCertWillBeCreditedToWallet":"В него придут деньги от сертификата: чтобы&nbsp;их&nbsp;потратить, просто выбирайте кошелёк способом оплаты","transferMoneyInWBApp":"Перевести деньги можно в приложении Wildberries","fullAmount":"Все {{- amount}}","transferAmount":"Сумма перевода – {{- amount}}","amountTransferred":"{{- amount}} выведены","linkToConfirmationOfData":"Для перевода {{- walletBalance}} нужно увеличить лимит&nbsp;— понадобится {{- linkStart}}подтвердить данные на&nbsp;Госуслугах{{- linkEnd}}","sumOnGiftAccount":"{{- sumWithCurrency}} на&nbsp;подарочном счёте&nbsp;&mdash; их&nbsp;можно потратить только на&nbsp;покупки","choosePaymentMethod":"Выбирайте {{paymentMethod}} способом оплаты и&nbsp;оплачивайте покупки","walletFeatures":{"title":"Возможности WB Кошелька","paymentWithDiscount":"Оплата со скидкой","amountOfDiscountAtTime":"За один раз","amountLimit":"до","remainingAmount":"Осталось","depositsAndTransfers":"Пополнение и переводы","oneDeposit":"Одно пополнение","transfersPerMonth":"Переводы в месяц","perMonth":"В месяц","currentFeatures":"Что можно сейчас","capabilitiesOfYourWallet":"Возможности вашего WB Кошелька","unavailable":"недоступны","walletCanBeLarger":"Кошелёк может больше","ifProvideDataFromEsia":"Если предоставить данные с Госуслуг","improveWallet":"Улучшить кошелёк","needDataFromEsia":"Нужны только ваши данные с&nbsp;Госуслуг"},"agreement":{"agreeToTermsAndPDPolicy":"Нажимая на кнопку, я соглашаюсь с условиями {{- termsLinkStart}}Договора &nbsp;о&nbsp;комплексном&nbsp;обслуживании клиента ООО&nbsp;&laquo;Вайлдберриз&nbsp;Банк&raquo;{{- termsLinkEnd}}, {{- pdPolicyLinkStart}}Порядком обработки персональных данных ООО&nbsp;&laquo;Вайлдберриз&nbsp;Банк&raquo;{{- pdPolicyLinkEnd}}{{- tagStart}}, с&nbsp;привязкой Электронного кошелька WB для последующих оплат по СБП в пользу ООО&nbsp;&laquo;РВБ&raquo;. Для&nbsp;вывода денег&nbsp;на&nbsp;банковский&nbsp;счет физического лица понадобится подтвердить Ваши данные в&nbsp;ООО&nbsp;&laquo;Вайлдберриз&nbsp;Банк&raquo; через Госуслуги.{{- tagEnd}}","agreeToTermsOfOfferAndProcessingOfPD":"Я соглашаюсь с условиями {{- termsLinkStart}}Договора&nbsp;о&nbsp;комплексном&nbsp;обслуживании клиента ООО&nbsp;&laquo;Вайлдберриз&nbsp;Банк&raquo;{{- termsLinkEnd}}, {{- pdPolicyLinkStart}}Порядком обработки персональных данных ООО&nbsp;&laquo;Вайлдберриз&nbsp;Банк&raquo;{{- pdPolicyLinkEnd}}{{- tagStart}}, с&nbsp;привязкой Электронного кошелька WB для последующих оплат по СБП в пользу ООО&nbsp;&laquo;РВБ&raquo;. Для&nbsp;вывода денег&nbsp;на&nbsp;банковский&nbsp;счет физического лица понадобится подтвердить Ваши данные в&nbsp;ООО&nbsp;&laquo;Вайлдберриз&nbsp;Банк&raquo; через Госуслуги.{{- tagEnd}}"},"esia":{"waitingResponseFromEsia":"Ждём ответ от Госуслуг","confirmOnEsia":"Подтвердить на Госуслугах","switchToEsia":"Перейти на Госуслуги","switchingToEsia":"Переходим на Госуслуги..."},"certificate":{"giftCertificate":"Подарочный сертификат","enterActivationCode":"Введите код активации","activateBtn":"Активировать"},"emptyOperationList":{"noOperationsYet":"Операций пока нет","noOperationsYetDescription":"После совершения первой операции, покажем&nbsp;ее&nbsp;здесь"},"tooltip":{"cannotBuyCertsWithGiftMoney":"Купить сертификаты за подарочные деньги нельзя: даже если они у вас есть, здесь их не учитываем","transferDescription":"Деньги можно вывести только с&nbsp;кошелька"},"withdrawalOfMoney":{"comeUpWithPassword":"Придумайте пароль","passwordDescription":"С ним переводить деньги безопаснее","enterPasswordAgain":"Введите пароль<br>ещё раз","enterPassword":"Введите пароль","forgotPassword":"Не помню пароль","sentCode":"Отправили его на {{phoneNumber}} для&nbsp;подтверждения, что профиль ваш","requestCodeAgain":"$(auth.requestCodeAgainInfinitive)","transferByPhone":"Перевод по телефону","toMyself":"Себе","bankType":"В какой банк","selectFromList":"Выбрать из списка","amountLimit":"Введите сумму до 1 000 000 ₽","errorAmountLimit":"Не хватает средств. Введите сумму до {{walletBalanceRub}} ₽","invalidCharacters":"Поле содержит недопустимые символы","minAmount":"Введите сумму от 1 ₽","confirmTransfer":"Подтвердите перевод","debitAccount":"Счёт списания","recipientNumber":"Номер получателя","recipient":"Получатель","recipientBank":"Банк получателя","transferAmountTitle":"Сумма перевода","transferWithoutCommission":"без комиссии","applicationCreated":"Заявка создана","termOfEnrollment":"Срок зачисления зависит от вашего банка, в&nbsp;среднем — до&nbsp;5&nbsp;дней","byPhoneNumber":"По номеру телефона","transferBySbp":"Перевод через СБП","transferInProcessing":"Перевод обрабатывается","failedToCreateRequest":"Не удалось создать&nbsp;заявку","uploadingListOfBanks":"Загружаем список банков...","selectBank":"Выберите банк","findBank":"Найти банк","allBanks":"Все банки","bankNotFound":"Банк не найден","tryToChangeParameters":"Попробуйте изменить параметры","transferByBankDetails":"Перевод по реквизитам","bik":"БИК","bikFieldRequired":"Требуется поле БИК банка.","bikIncorrect":"Указан неверный БИК Банка","maxBikLength":"9 цифр","recipientAccount":"Счет получателя","recipientAccountFieldRequired":"Требуется поле Счет получателя.","recipientPersonalAccountIncorrect":"Указан неверный лицевой счет получателя","maximumAccountLength":"20 цифр, начинается на 408, 423","fullName":"ФИО","fullNameRequired":"Требуется поле ФИО.","fullNameIncorrect":"Некорректное ФИО","transferToCard":"Перевод на карту","deadlineForReceiptOfFunds":"Средства поступят в течение 5 дней","createRequest":"Создать заявку","transferFailed":"Перевод не удался"},"errors":{"translationNotPossibleFullText":"Невозможно зачислить перевод, есть ограничения на&nbsp;стороне банка получателя. Обратитесь в&nbsp;банк для&nbsp;снятия ограничений или&nbsp;выберите другой банк","translationNotPossible":"Невозможно зачислить перевод, обратитесь в&nbsp;банк получателя для снятия ограничений или&nbsp;выберите другой банк","restrictionsInBank":"Установлены ограничения на&nbsp;стороне банка получателя, выберите другой банк","technicalWorkInBank":"Технические работы в&nbsp;Банке получателя. Попробуйте повторить перевод через некоторое время","didntFindBankAccount":"Не нашли ваш счет<br>в {{bankName}}","checkSettings":"Проверьте в настройках банка, что&nbsp;вы&nbsp;подключили входящие переводы через СБП или выберите другой банк","problemInProcessingApplication":"Возникла проблема при обработке заявки","createRequest":"Средства списаны с&nbsp;баланса.<br>Чтобы оформить возврат, создайте обращение в&nbsp;разделе {{- communicationsLinkStart}}Обращений{{- communicationsLinkEnd}} или&nbsp;напишите в&nbsp;{{- supportLinkStart}}Чат&nbsp;поддержки{{- supportLinkEnd}}"},"ariaLabels":{"balanceDetails":"Детали баланса","backToMmethodSelection":"Назад к выбору метода"},"walletCreationModal":{"howToTopUpBtn":"Как пополнить","wbWalletIsReady":"WB Кошелёк готов","openWBWallet":"Откройте WB&nbsp;Кошелёк","loaderCreatingWBWallet":"Создаём WB Кошелёк","orderLimit":"Для любых заказов до 15 000 &#8381;","errorCreatingWallet":"Не получилось <br>создать WB&nbsp;Кошелёк","newConvenientPaymentMethod":"Новый удобный способ оплаты на&nbsp;Wildberries","youCanTopUpWallet":"Теперь его можно пополнить <br>и платить оттуда со скидкой","tryAgainOrChooseAnotherPaymentMethod":"Попробуйте ещё раз или выберите другой&nbsp;способ оплаты","discountPercentWithWallet":"Скидка {{- tagStart}}{{sale}}%{{- tagEnd}}, если платить WB&nbsp;Кошельком","agreement":"Нажимая на кнопку, я соглашаюсь с условиями {{- termsLinkStart}}Договора&nbsp;о&nbsp;комплексном&nbsp;обслуживании клиента ООО&nbsp;&laquo;Вайлдберриз&nbsp;Банк&raquo;{{- termsLinkEnd}}, {{- policyLinkStart}}Порядком обработки персональных данных ООО&nbsp;&laquo;Вайлдберриз&nbsp;Банк&raquo;{{- policyLinkEnd}}{{- tagStart}}, с&nbsp;привязкой Электронного кошелька WB для последующих оплат по СБП в пользу ООО&nbsp;&laquo;РВБ&raquo;. Для&nbsp;вывода денег&nbsp;на&nbsp;банковский&nbsp;счет физического лица понадобится подтвердить Ваши данные в&nbsp;ООО&nbsp;&laquo;Вайлдберриз&nbsp;Банк&raquo; через Госуслуги.{{- tagEnd}}"},"replenishmentInstructions":{"payBtn":"Кошелёк пополнен, оплатить","orderBtn":"Кошелёк пополнен, заказать","everythingWorkedOut":"Всё получилось","howDoTopUpWallet":"Как пополнить кошелёк?","findInBank":"Найдите в вашем банке «Перевод по&nbsp;номеру телефона» или&nbsp;«СБП»","findInLK":"Найдите в личном кабинете банка «Перевод по&nbsp;номеру телефона» или&nbsp;«СБП»","moneyIsCreditedToWallet":"Деньги зачислятся в кошелёк. Мы спишем их, когда вы&nbsp;получите заказ","enterYourNumber":"Введите свой номер {{- tagStart}}{{phoneNumber}}{{- tagEnd}}, выберите «Вайлдберриз Банк» и&nbsp;укажите сумму","enterYourPhoneNumber":"Введите свой номер телефона {{- tagStart}}{{phoneNumber}}{{- tagEnd}} и&nbsp;выберите «Вайлдберриз&nbsp;Банк»"}},"balance":{"balance":"Баланс:","balanceTransactions":"Операции по балансу","transferMoneyFromBalance":"С баланса","linkSbpAccount":"Для пополнения баланса<br>привяжите счёт {{- tagStart}}СБП{{- tagEnd}}","bindSbpBtn":"Привязать","amountTitle":"Сумма, ₽","replenishBtn":"Пополнить","amountOfDeposit":"Пополнить на {{amount, priceWithCurrencyV2}}","replenishmentType":"Пополнение через {{name}}","theDepositFailed":"Пополнить не удалось","paymentInProcessing":"Платеж в обработке","checkBalanceLater":"Проверьте {{balanceTitle}} немного позже","replenishmentBalance":"Пополнение баланса","methodOfReplenishment":"Способ пополнения","linkTheSbpAccount":"Привязать счёт СБП","qrCodeForLinkingAccount":"QR-код для привязки<br>счёта","discountForTheFirstOrder":"-{{discount}}% на первый заказ с новым счётом СБП","qrCodeDescription":"Отсканируйте QR-код из приложения банка или через камеру телефона. Для проверки счета мы спишем и сразу вернем 10 ₽","linkingSbpAccount":"Привязываем счёт СБП"},"communications":{"emptyCommunications":{"answersToQuestions":"Ответы на частые вопросы","contactTheChat":"Обратиться в чат"},"howCanHelpYou":"Чем вам помочь?","creatingRequest":"Создайте обращение","communication":"Обращение","applicationNumber":"№ обращения","applicationNumberWithID":"№ обращения {{id}}","dateOfApplication":"Обращение от {{dateOfApplication}}","wbAnswer":"Ответ Wildberries","responseHasBeenReceived":"Ответ поступил","send":"Отправить","sending":"Отправление","inProcessing":"В обработке","nextPage":"Следующая страница","previousPage":"Предыдущая страница","date":"Дата","topic":"Тема","chapter":"Раздел","ratingOrStatus":"Оценка/статус","chooseTheme":"Выберите тему","selectSection":"Выберите раздел","chooseReason":"Выберите причину","writeInDetail":"Напишите подробно","specialist":"Специалист {{employeeName}}","closedByUser":"Закрыто самостоятельно","yourAssessment":"Ваша оценка","sendRating":"Отправить оценку","cancelRecourse":"Отменить обращение","reallyWantToCancelRecourse":"Вы действительно хотите отменить обращение?","tellWhatDidntLike":"Расскажите, что вам не понравилось?","rateExpertAdvice":"Оцените, пожалуйста, консультацию&nbsp;специалиста","numberOfCharacters":"Число символов в строке должно быть от 10 до 1000","productCode":"Артикул","itemNumber":"Артикул товара","maxLengthProductCode":"до 10 цифр","articleIsOnTheProductPage":"Артикул находится на странице товара","responseTime":"Мы ответим в течение 24 часов","maximumResponseTime":"Максимальный&nbsp;срок ответа&nbsp;—&nbsp;24&nbsp;часа","maxResponseTime":"Мы уже занимаемся вашим вопросом. $t(communications.maximumResponseTime).","fieldShouldNotContainCreditCardNumber":"Поле не должно содержать номер кредитной карты!","detailedDescription":"Подробное описание поможет ответить вам как можно скорее, без уточнения других деталей","ifStillQuestions":"Если у вас остались вопросы, {{- buttonStart}}создайте&nbsp;новое&nbsp;обращение{{- buttonEnd}}"},"providers":{"esia":{"accountUnlinked":"Аккаунт Госуслуг отвязан","linkedToThisProfile":"Привязали Госуслуги к этому профилю.\\nТеперь для входа не нужен код","failedToLink":"Не смогли привязать Госуслуги","failedToUnlink":"Не смогли отвязать Госуслуги","unlinkAccount":"Отвязать&nbsp;аккаунт&nbsp;Госуслуг?","cantLogInFrom":"Не получается войти через Госуслуги"},"sberid":{"accountUnlinked":"Аккаунт Сбер ID отвязан","linkedToThisProfile":"Привязали Сбер ID к этому профилю.\\nТеперь для входа не нужен код","failedToLink":"Не смогли привязать Сбер&nbsp;ID","failedToUnlink":"Не смогли отвязать Сбер&nbsp;ID","unlinkAccount":"Отвязать&nbsp;аккаунт&nbsp;Сбер&nbspID?","cantLogInFrom":"Не получается войти через Сбер&nbsp;ID","weWillLinkToWbProfile":"Мы привяжем Сбер ID к профилю Wildberries: в следующий раз сможете войти без кода"},"oneid":{"accountUnlinked":"Аккаунт OneID отвязан","linkedToThisProfile":"Привязали OneID к этому профилю. \\nДанные заполнены автоматически. Вы можете поменять {{- linkBegin}}их в профиле{{- linkEnd}}","failedToLink":"Не смогли привязать OneID","failedToUnlink":"Не смогли отвязать OneID","unlinkAccount":"Отвязать&nbsp;аккаунт&nbsp;OneID?","cantLogInFrom":"Не получается войти через One&nbsp;ID","weWillLinkToWbProfile":"Мы привяжем OneID к профилю Wildberries: в следующий раз сможете войти без кода"}},"auth":{"logInWithANumber":"Войти под номером","logInOrCreateAProfile":"Войти или создать профиль","selectCountryCode":"Выберите код страны","select":"Выберите","countryCode":"Код страны","checkBoxToContinue":"Поставьте галочку, чтобы&nbsp;продолжить","enterCodeFromPicture":"Введите код с картинки","enterConfirmationCode":"Введите код подтверждения","enterNumberToGetCode":"Введите номер, чтобы получить код","sentToPhone":"Отправили на {{phone}}","enterLastDigits":"Введите последние 4 цифры входящего номера","callOnPhone":"Звоним на {{phone}}","openNotificationInWbApp":"Откройте уведомление в&nbsp;приложении Wildberries","openNotificationOnWbSite":"Откройте уведомление на&nbsp;сайте Wildberries","youHaveReceivedANotification":"Вам пришло уведомление","codeFormat":"Код XXX-XXX","agreeWithTerms":"Соглашаюсь {{- linkTermsOfUseBegin}}с правилами пользования торговой площадкой{{- linkTermsOfUseEnd}} и&nbsp;{{- linkReturnPolicyBegin}}возврата{{- linkReturnPolicyEnd}}","logInInDifferentWay":"Войти по-другому","esia":"Госуслуги","sberId":"Сбер ID","oneid":"OneID","onCall":"По звонку","selectNumberToLogIn":"Выберите номер для входа","deleteNumber":"Удалить номер","logInWithDifferentNumber":"Войти под другим номером","sentItToPhoneFormat":"Отправили его на {{- phone}}","requestCodeAgainTimeFormat":"Запросить код повторно через {{- time}}","logInAgain":"Повторить вход","nowEnterPhone":"Теперь введите телефон","willHaveToEnterCode":"Тогда быстро заходить в Wildberries не получится — придётся вводить код","unlinkBtn":"Отвязать","wbProfile":"Профиль Wildberries","afterLoggingIn":"После входа вам будут доступны товары с&nbsp;персональными скидками","toEnterCallNumberForFree":"Для входа позвоните бесплатно по номеру {{-phone}}","loginCall":{"enterPhone":"Введите телефон","whichProfileYouWantToLogInto":"Чтобы мы поняли, в какой профиль вы хотите войти","toAvoidTypingManually":"Чтобы не набирать вручную, отсканируйте&nbsp;QR&#8209;код","phoneForCallWillChange":"Телефон для звонка изменится, если не получится позвонить с {{phone}} в течение {{timeLeftSeconds}}","toCall":"Позвонить","timeIsOver":"Время закончилось","phoneForCallHasChanged":"Изменился телефон, по которому нужно позвонить —&nbsp;так вход безопаснее","showNewPhone":"Показать новый телефон"},"errorsByResult":{"2":"$t(common.errors.tryAgainLater)","4":"Запросить код ещё раз можно через ","6":"$t(auth.invalidCode)","99":"Произошла ошибка","5_esia":"Этот код устарел, войдите на Госуслуги ещё раз","5_sberId":"$t(auth.sberCodeExpired)","5_oneid":"$t(auth.oneidCodeExpired)","8_esia":"$t(auth.esiaTimeExpired)","8_sberId":"$t(auth.sberTimeExpired)","8_oneid":"$t(auth.oneidTimeExpired)","18_esia":"$t(auth.esiaNoMatches)","18_sberId":"Этот Сбер ID привязан к другому профилю Wildberries","18_oneid":"Этот OneID привязан к другому профилю Wildberries","19_esia":"Сначала нужно подтвердить профиль на Госуслугах","20_esia":"$t(auth.esiaNoMatches)","20_sberId":"Номера телефонов профилей Сбер ID и Wildberries не совпали","23_oneid":"У этого профиля уже есть привязка OneID","30_esia":"$t(common.errors.tryAgainLater)","30_sberId":"$t(auth.sberCodeExpired)","30_oneid":"$t(auth.oneidCodeExpired)","32_esia":"$t(auth.esiaTimeExpired)","32_sberId":"$t(auth.sberTimeExpired)","99_oneid":"$t(common.errors.tryAgainLater)"},"esiaTimeExpired":"Вы слишком долго отсутствовали, войдите на Госуслуги ещё раз","esiaNoMatches":"Номера телефонов профилей Госуслуг и Wildberries не совпали","sberTimeExpired":"Вы слишком долго отсутствовали, войдите на Сбер ID ещё раз","sberCodeExpired":"Этот код устарел, войдите на Сбер ID ещё раз","oneidTimeExpired":"Вы слишком долго отсутствовали, войдите на OneID ещё раз","oneidCodeExpired":"Этот код устарел, войдите на OneID ещё раз","unknownErrorHasOccurred":"Произошла неизвестная ошибка","incorrectNumberFormat":"Некорректный формат номера","requestCodeAgain":"Запросите код повторно","requestCodeAgainInfinitive":"Запросить код повторно","requestCodeOnPhone":"Запросить код на телефон","requestNewCodeVia":"Запросить новый код через <span>{0}</span>","requestCodeAgainVia":"Запросить код повторно через <span>{0}</span>","youHaveExhaustedAllAttempts":"Вы исчерпали все попытки. Попробуйте позже","invalidCode":"Неверный код, попробуйте еще раз","couldntLogInTryAnotherWay":"Не получилось войти, попробуйте по-другому","loginFailedContactSupport":"Не удалось войти, обратитесь в поддержку","timeHasNotPassedWithTimeLeft":"Не прошло время для повторной отправки кода. Повторите через: {{timeLeft}}","resend":{"push":{"countDown":"$t(auth.requestNewCodeVia)","message":"$t(auth.requestCodeOnPhone)"},"notify":{"countDown":"$t(auth.requestNewCodeVia)","message":"$t(auth.requestCodeOnPhone)"},"sms":{"countDown":"$t(auth.requestNewCodeVia)","message":"$t(auth.requestCodeAgain)"}},"wbId":{"logInViaWildberries":"Войдите через Wildberries","onAuthClient":"На {{authClient}}","logInUsingDifferentProfile":"Войти через другой профиль","youAllowServiceToDataFromWb":"Нажимая «Войти», вы разрешаете сервису доступ к данным из профиля Wildberries","loginFailedServiceIsNotRelated":"{{- tagBegin}}Вход не выполнить{{-tagEnd}} <br>Сервис, в который вы пытаетесь войти, не связан с Wildberries"},"quickEntry":"Быстрый вход","throughTheseAccountsCanLogIn":"Через эти аккаунты можно входить в профиль <br>Wildberries без кода подтверждения","nowEnterPhoneNumber":"Теперь введите телефон"},"delivery":{"deliveryByCourier":"Доставка курьером","deliveryToPickUpPoint":"Доставка в пункт выдачи","toReceiveOrCancelOrder":"Для получения или отмены заказа покажите QR-код сотруднику"},"userAddress":{"addressTypeIsUnknown":"Тип адреса неизвестен","whereToPickUpGoods":"Откуда забрать товар","selectPickUpPoint":"Выберите пункт выдачи","showOnMap":"Показать на карте","changeOffice":{"possibleInDeliveryArea":"Изменить пункт выдачи можно только в&nbsp;рамках района доставки","alreadyChosen":"Вы уже выбрали этот пункт выдачи при оформлении заказа","paidDelivery":"В этот пункт выдачи платная доставка","impossibleToChangeToKiosk":"Невозможно изменить пункт выдачи на киоск","impossibleToChange":"Невозможно изменить пункт выдачи на постамат"},"storagePeriod":{"plural_one":"Срок хранения {{displayCount}} день","plural_few":"Срок хранения {{displayCount}} дня","plural_many":"Срок хранения {{displayCount}} дней"},"limitCountProducts":{"plural_one":"До {{displayCount}} товар","plural_few":"До {{displayCount}} товара","plural_many":"До {{displayCount}} товаров"},"unknownAddress":"Адрес определен неточно. Выберите повторно","deliveryCoordinates":"Координаты доставки:","latitudeWithValue":"Широта: {{- latitude}}","longitudeWithValue":"Долгота: {{- longitude}}","outsideDeliveryArea":"Вне зоны доставки","deliveryIsNotAvailable":"Доставка недоступна","deliveryIsCarriedOutAtPointOnMap":"Будьте внимательны, доставка будет осуществлена по выбранной точке на карте!","houseNumber":"Номер","houseBuilding":"Дом, строение","apartmentOffice":"Квартира / офис","privateHome":"Частный дом","additionalInfoForCourier":"Доп. информация для курьера","entrance":"Подъезд","intercom":"Домофон","floor":"Этаж","chooseBtn":"Выбрать","specifyAddressWithinDeliveryArea":"Укажите адрес на карте в пределах зоны доставки","viewTermsOfDeliveryToAddress":"Чтобы посмотреть условия доставки на Ваш адрес, укажите его на карте или найдите с помощью поиска","whereToDeliverYourOrder":"Куда привезти заказ?","enterAddressOnMap":"Укажите адрес на&nbsp;карте или найдите с&nbsp;помощью поиска","list":"Списком","all":"Все","myAddresses":"Мои адреса","pickUpPoints":"Пункты выдачи","parcelTerminals":"Постаматы","post":"Почта","russianPost":"Почта РФ","scAndWarehouses":"СЦ и склады","pickUpPointIsOverloaded":"Пункт выдачи перегружен. Доставка временно недоступна","deliveryAddressMenu":"Меню адреса доставки","selected":"Выбран","reviewsOfPickUpPoint":"Отзывы о пункте выдачи","deliveryIsTemporarilyImpossible":"Доставка временно невозможна","pickUpPointIsOverloadedChooseAnother":"Пункт выдачи сильно перегружен. Выберите другой, для&nbsp;оформления заказа","atQueuePickUpPoint":"В пункте выдачи возможны очереди","atQueueKioskPoint":"В киоске возможны очереди","pickUpPointIsLoadedChooseCheaper":"Пункт выдачи сильно загружен. Вы можете выбрать другой пункт выдачи с&nbsp;доставкой дешевле","pickUpPointIsLoadedChooseFree":"Пункт выдачи сильно загружен. Вы можете выбрать другой пункт выдачи с&nbsp;бесплатной доставкой","kioskPointIsOverloadedChooseAnotherType":"Киоск сильно перегружен. Выберите другой способ доставки","kioskPointIsOverloadedDeliveryIsImpossible":"Киоск временно перегружен, доставка в&nbsp;него сейчас недоступна","kioskIsOverloaded":"Киоск перегружен","additionalInfo":"Доп. информация","howToGet":"Как добраться","reviews":"Отзывы","addressOrObject":"Адрес или объект","startSearchingInAddressBar":"Начните поиск в адресной строке или выберите адрес на карте","deliveryIsAvailableByMail":"Доставка доступна почтой.<br> Пожалуйста, введите почтовый адрес.","region":"Область","nameOfRegion":"Название области","district":"Район","nameOfArea":"Название района","locality":"Населённый пункт","nameOfLocality":"Название населённого пункта","street":"Улица","streetName":"Название улицы","selectDeliveryAddress":"Выберите адрес доставки","selectDeliveryAddressInfinitive":"Выбрать адрес доставки","errorWhenChoosingAddress":"Ошибка при выборе адреса","chooseShippingMethod":"Выберите способ доставки","selectCourierAddress":"Выберите курьерский адрес","addressIsNotValid":"Адрес не подходит","noSavedAddresses":"Нет сохраненных адресов","addNewAddress":"Добавить новый адрес","impossibleToDeliver":"Невозможно доставить","enterAddress":"Введите адрес","searchEllipsis":"поиск...","searchEllipsisCapitalize":"Поиск...","shippingMethod":"Способ доставки","withWbClubCanChangePickUpPoint":"С подпиской WB Клуб вы сможете изменить пункт выдачи после заказа","closePromo":"Закрыть промо","pickUpPoint":"Пункт выдачи","scWarehouse":"СЦ / Склад","byCourier":"Курьером","courierAddress":"Курьерский адрес","thereAreCollectionPointsNearby":"Рядом есть пункты выдачи, где Вы сможете получить свой заказ быстрее","costOfDelivery":"Стоимость доставки","phone":"Телефон","addExtPhones":"доб. {{extPhones}}","workTime":"Режим работы","fittingRooms":"Примерочные","numberOfFittingRooms":"{{fittingRooms}} шт.","workingConditions":"Особенности работы","nearestDelivery":"Ближайшая доставка","showInFull":"Показать полностью","learnMoreAboutAddress":"Подробнее об адресе","takeItAwayFromHere":"Забрать отсюда","deliveryByPrice":"Доставка {{- deliveryPrice}}","overloaded":"Перегружен","queues":"Очереди","isFree":"Бесплатно","takeItFromHere":"Заберу отсюда","deleteInactiveAddress":"Удалить неактивный адрес доставки","closed":"Закрыто","chooseWhereWantToPickUpOrder":"Выберите, где хотите забрать заказ","specifyWhereWantToBringOrder":"Укажите, куда нужно привезти заказ","addPickUpPointOrAddress":"Добавить пункт выдачи или адрес","addPickUpPoint":"Добавить пункт выдачи","addAddress":"Добавить адрес","deliverItHere":"Доставить сюда","verificationCode":"Проверочный код","notAllDateFieldsAreFilledIn":"Не все поля даты заполнены","doYouReallyWantToDeleteGroup":"Внимание! Вы действительно хотите удалить группу<br> &laquo;{{groupName}}&raquo;?","delayed":"задерживается","approximatelyToday":"ориентировочно cегодня","approximatelyWithDate":"ориентировочно {{date}}","partnerPostamate":"Партнерский постамат","couldntFindYou":"Не удалось вас найти","allowToDetermineLocation":"Разрешите определить местоположение в настройках браузера. Так мы узнаем, где вы находитесь","workTimeWithValue":"{{- tagBegin}}Режим работы: {{- tagEnd}} {{workTime}}","fittingRoomsWithValue":"{{- tagBegin}}Примерочные:{{- tagEnd}} {{fittingRooms}} шт.","deliveryWithValue":"{{- tagBegin}}Доставка:{{- tagEnd}} {{deliveryPrice}}"},"chat":{"wbSupport":"Поддержка Wildberries","rateSupport":"Оцените работу поддержки","rateOperator":"Оцените работу оператора {{operator}}","chatHeader":"Чат","searchForChats":"Поиск чатов","searchInChat":"Поиск в чате","searchForProducts":"Поиск по товарам","productImage":"Изображение товара","closeChats":"Закрыть чаты","close":"$t(common.close)","showAttachments":"Показать вложения","sellerLogo":"Логотип продавца","loading":"Загрузка","photoReceived":"Получено фото","photoSent":"Отправлено фото","fileReceived":"Получен файл","fileSent":"Отправлен файл","linkReceived":"Получена ссылка","linkSent":"Отправлена ссылка","messagesNotDownloaded":"Сообщения не загрузились","messagesEmpty":"Сообщений пока нет","messagesNotFound":"Сообщения не найдены","chatNotDownloaded":"Чат с поддержкой не загрузился","rebootPageTip":"Обновите страницу или вернитесь позже, мы всё починим","linaWelcomeMessage":"Я&nbsp;{{- tagStart}}Лина{{- tagEnd}}&nbsp;- виртуальный помощник службы поддержки. Если у&nbsp;Вас возник вопрос задайте его в&nbsp;этом чате, и&nbsp;я&nbsp;с&nbsp;удовольствием отвечу на&nbsp;него.","chatsNotFound":"Чаты не найдены","toChatList":"К списку чатов","toListOfChatMesssages":"К списку сообщений чата","media":"Медиа","mediaFiles":"Медиа файлы","noMedia":"Нет медиа","documents":"Документы","noDocuments":"Нет документов","links":"Ссылки","noLinks":"Нет ссылок","link":"Ссылка","returnToChat":"Вернуться к чату","downloadedPhoto":"Загруженное фото","downloadedImg":"Загруженное изображение","goToPrevMessage":"К предыдущему сообщению","goToNextMessage":"К следующему сообщению","cancel":"$t(common.cancel)","viewingMedia":"Просмотр медиа и документов","downloadFile":"Скачать файл","fileSendingError":"Ошибка при отправке файла","requestError":"Ошибка запроса","goToMessage":"Перейти к сообщению","closeViewing":"Закрыть просмотр","goBack":"$t(common.goBack)","goForward":"$t(common.goForward)","returnOfGood":"Возврат товара","art":"Арт: {{nmID}}","thanksForRating":"Спасибо за оценку","autoTranslate":"Автоперевод • ","originalTranslation":"Оригинал","filesTooltipBr":"Можно загрузить jpeg, jpg,<br>png, pdf размером до 10 мб","filesTooltip":"Можно загрузить jpeg, jpg, png, pdf размером до 10 мб","messageSending":"Сообщение отправляется","yourMessage":"Ваше сообщение...","sendMessage":"Отправить сообщение","serviceTemporaryUnavailable":"Чат временно отключен, производятся технические работы","messageError":"Не удалось отправить сообщение","goodSendingError":"Не удалось отправить товар","fileDownloadingError":"Не удалось загрузить файл","ratingOfAnswer":"Оценка ответа","toSend":"$t(common.toSend)","supplier":"$t(common.supplier)","seller":"$t(common.seller)","fileNotSupport":"Файл не поддерживается","fileTooBig":"Слишком большой файл","errSendingMessage":"Ошибка при отправке сообщения","rateNotSend":"Не удалось отправить оценку","sendRate":"Отправить оценку","returnCancelled":"Возврат товара отклонен","returnTip":"Чтобы вернуть товар, найдите его в Покупках, нажмите {{- dotsIcon}} и выберите Вернуть товар по&nbsp;браку","returnOnBalance":", деньги поступят на баланс","returnRequestPositiveAccepted":"Ваша заявка на возврат {{- amount}} одобрена","returnRequestNegativeAccepted":"Ваша заявка на возврат денежных средств одобрена","awaitForSellerReply":"Ожидайте ответа продавца","wbBot":"Бот Wildberries","sellerAcceptRefund":"Возврат одобрен. Принесите товар в пункт выдачи, в котором его получали.","refundAmountPositive":"{{- amount}} вернутся после того, как товар поступит на склад.","refundAmountNegative":"Денежные средства вернутся после того, как товар поступит на склад.","refundNotification":"О возврате денег проинформируем уведомлением в личном кабинете.","messageMatches":"{{index}} из {{matches}}","whatDidntLike":"Что вам не понравилось?","whatIsWrong":"Что было не так?","whatLiked":"Что особенно понравилось?","mySupportRate":"Моя оценка поддержки","myOperatorRate":"Моя оценка оператора","chooseGood":"Выберите товар","onTheWay":"В пути","toChoose":"$t(common.toChoose)","moreGoods":"Ещё товары","yourReply":"Ваш ответ","messageNotDelivered":"Сообщение не доставлено.","resend":"Повторить?","questionAboutProduct":"Вопрос о товаре","negativeRate":"Плохо","neutralRate":"Нормально","positiveRate":"Хорошо","return":"Возврат к чату","askAboutProduct":"Задать вопрос о товаре","nothingFound":"Ничего не нашлось","loadingProducts":"Загружаем товары","negativeRatingItems":{"slow":"Медленно","tooLong":"Слишком долго","lackOfInfo":"Мало информации","noHelp":"Мне не помогли","dontLikeSolution":"Не нравится решение","impolite":"Невежливо","changeOfOperator":"Смена оператора","needToRepeat":"Пришлось повторять"},"positiveRatingItems":{"fast":"Всё быстро","theyHelpedMe":"Мне помогли","friendly":"Дружелюбно"},"operatorWillConnectSoon":"Оператор скоро подключится и поможет вам","apologizeMsg":"Извините, пока что все операторы заняты. Как только кто-то освободится, сразу напишем вам"},"wbClub":{"btnBack":"На сайт WB","wbClub":"WB Клуб","active":"Активна","activeLimit":"Активна до {{stopBillingDate}}","activeSub":"Подписка активна","openMenu":"Открыть меню","renewSub":"Возобновить подписку","manageSub":"Управлять подпиской","availabilityPromo":"Попробовать месяц за 1 ₽","paymentPerMonth":"Дальше — от {{- minPriceOffer}} в месяц","joinClub":"Вступить в клуб","subNavWbCatalog":"Каталог Wildberries","subNavChat":"Чат поддержки","subNavLogout":"Выйти из профиля","subTitle":"Подписка WB Клуб","stopSubscription":"Вы отменили подписку. Все преимущества подписки будут доступны до {{stopBilling}}","errorNextPaySub":"Не смогли списать {{- sum}}. Попробуем ещё несколько раз, если не получится — отключим подписку","savingWithSub":"Вы сэкономили с подпиской","savingPeriod":{"total":"За всё время","month":"В этом месяце"},"moreBenefits":"Больше выгоды от ежедневных покупок","clubDiscounts":"Клубные скидки","allProducts":"Все товары","invitationToWbClub":"Вступайте в WB Клуб и получайте специальные скидки на тысячи товаров","privileges":"Привилегии для участников клуба","promoWalletSale":"Повышенная скидка WB Кошелька до {{promoWalletSale}}%","paymentForAnyGoods":"При оплате любых товаров на Wildberries","highlightProfile":"Выделять профиль","alsoInSub":"Что ещё в подписке","partnerTitle":"Литрес","partnerText":"Три книги в подарок из подборки и скидка 25% на одну покупку каждые 30 дней","benefitOffersTitle":"Можно дешевле","sumInMonth":"{{- sumInMonth}} в месяц","activePlug":"У вас сейчас","faqTitle":"Вопросы и ответы","faqQuestions":{"promoWalletSale":{"question":"Что значит +{{promoWalletSale}}% к скидке кошелька?","answer":"Сейчас при оплате любых заказов из WB Кошелька действует скидка. С подпиской эта скидка станет больше."}},"faqFooterSupport":"Если не нашли ответ на свой вопрос, {{- linkStart}}напишите в службу поддержки{{- linkEnd}}","faqFooterCondition":"Полные условия действия подписки","offersPopup":{"title":"Подключить подписку","promoText":"Первый месяц любой подписки будет стоить 1 ₽","renewSubFor":"Возобновить подписку за {{- sum}}","activateSubFor":"Подключить подписку за {{- sum}}","approval":"Нажимая кнопку, вы соглашаетесь с {{- linkStart}}условиями подписки{{- linkEnd}}"},"nextPay":"{{payDate}} спишем {{- sum}}","buy":"Оплатить {{- sum}}","buyText":"Подписка начнет действовать сразу после оплаты","disableSub":"Отключить подписку","successBuyPopup":{"subForMonthsPaid":{"plural_one":"Подписка на {{displayCount}} месяц оплачена","plural_few":"Подписка на {{displayCount}} месяца оплачена","plural_many":"Подписка на {{displayCount}} месяцев оплачена"},"subEnabled":"Подписка подключена","youMemberWbClub":"Теперь вы в WB Клубе!","benefit":"Дополнительные скидки на тысячи товаров, выделенная поддержка, предложения партнёров и не только","toNewOpportunities":"К новым возможностям"},"benefitPopup":{"title":"Ваша выгода с WB Клубом","benefitInfo":"Вы купили {{goods}} со скидкой клуба и сэкономили {{- sum}}","manual":"Вы покупаете товары со скидкой по подписке клуба, а мы показываем, сколько вы сэкономили"},"confirmCancelPopup":{"title":"Продолжайте экономить с подпиской","benefitSum":"Вы сэкономили {{- sum}}","benefitGoods":"За всё время подписки вы купили {{goods}} со скидкой","disableSubscriptionText":"Если отключите подписку, больше не сможете покупать товары со специальной скидкой клуба","viewAllProducts":"Смотреть все товары","continueSaving":"Продолжить экономить","disableItAnyway":"Всё равно отключить","losePrivileges":"Вы потеряете привилегии","losePrivilegesText":"Вы больше не сможете пользоваться привилегиями подписки:","benefitsList":{"promoWalletSale":{"title":"Повышенная скидка WB Кошелька до {{sale}}%","text":"Станет меньше выгода при оплате WB Кошельком"},"changePvz":{"title":"Смена пункта выдачи","text":"Нельзя будет поменять адрес пункта выдачи после заказа"},"supportPriority":{"title":"Выделенная поддержка","text":"Ваши обращения не попадут в выделенную очередь"},"commentsHighlight":{"title":"Клубный профиль","text":"Ваши отзывы и вопросы больше не будут дополнительно отмечены"}},"leavePrivileges":"Оставить привилегии","leaveSuggestions":"Оставить предложения","partnerHeader":"Станут недоступны предложения от партнёров"},"successCancelTitle":"Подписка отключена","successCancelText":"Подписка перестанет действовать с {{stopBilling}}, деньги больше не будут списываться","extended":{"plural_one":"Продлить на {{displayCount}} месяц","plural_few":"Продлить на {{displayCount}} месяца","plural_many":"Продлить на {{displayCount}} месяцев"},"extendForMonth":"Продлить на месяц","amountCharge":"Спишем {{- sum}} сейчас, а в следующий раз — {{stopBilling}}","changeTariffTitle":{"plural_one":"Вы подключаете подписку на {{- tagStart}}{{displayCount}} месяц{{- tagEnd}}","plural_few":"Вы подключаете подписку на {{- tagStart}}{{displayCount}} месяца{{- tagEnd}}","plural_many":"Вы подключаете подписку на {{- tagStart}}{{displayCount}} месяцев{{- tagEnd}}"},"changeTariffText":"Она начнёт действовать сразу после оплаты","promoLitres":{"title":"Три книги в подарок и скидка 25%","benefitSubActivated":"С подпиской WB Клуба вы получаете три книги в подарок на выбор из подборки, а также скидку 25% на одну покупку на Литрес.","info":"Литрес — это 1 000 000 электронных и аудиокниг на русском и иностранных языках. Каждый месяц в каталоге сервиса появляются новые книги, многие — одновременно с печатными версиями, а некоторые — эксклюзивно, только на Литрес","benefitSubNonActivated":"Получите три книги в подарок на выбор из подборки, а также скидку 25% на одну покупку на Литрес","howToUse":"Как воспользоваться","copyPromoCode":"Скопируйте промокод","activatePromoCode":"Перейдите на {{- linkStart}}litres.ru{{- linkEnd}} и активируйте промокод","bookSelection":"Вам откроется подборка, из которой вы сможете выбрать и скачать любые три книги бесплатно","sale":"Скидка 25% появится автоматически после активации промокода"},"bindNewCard":"Привязать новую карту","premiumUserPopup":{"discountApplied":"Применили скидку {{sale}}%","clubDiscountApplied":"Применили клубную скидку {{sale}}%","youMember":"Вы участник WB Клуба — вам скидка на этот товар","discountedGoods":"Товары по скидке WB Клуба","becomeMember":"Станьте участником WB Клуба и получите доступ к товарам по специальной скидке. Ещё больше выгоды, а ещё приоритетная поддержка, предложения партнёров и другие преимущества","detailsOnSub":"Подробнее о подписке","customerInWbClub":"Этот покупатель в WB Клубе","customerBenefitFeedbacks":"С подпиской WB Клуб его отзывы заметнее других. А ещё у него есть дополнительные скидки, приоритетная поддержка и другие привилегии","customerBenefitQuestions":"С подпиской WB Клуб его вопросы заметнее других. А ещё у него есть дополнительные скидки, приоритетная поддержка и другие привилегии"},"paymentFailed":"Оплата не прошла, попробуйте еще раз","paymentPending":"Платёж в обработке","cancelSubFail":"Отменить подписку не получилось, попробуйте позже","copyPromoCode":"Промокод скопирован","noActiveSub":"Нет активной подписки","premiumSaleClub":"-{{premiumSale}}% с клубом"},"certificates":{"certHeaderTitle":"Дарите сертификаты для&nbsp;покупок на&nbsp;Wildberries","certHeaderTextDesign":"Выберите дизайн и&nbsp;номинал сертификата","certHeaderTextWallet":"Оплатите сертификат удобным&nbsp;способом","certHeaderTextMail":"Скачайте сертификат и&nbsp;отправьте кому хотите","chooseDesign":"Выберите дизайн","chooseNominal":"Выберите номинал","total":"Итого","faqTitle":"Отвечаем на вопросы","faqQuestions":{"howItWorks":{"question":"Как работает сертификат Wildberries?","answer":{"firstParagraph":"Вы выбираете дизайн и номинал, оплачиваете его удобным способом и получаете pdf-файл с сертификатом. Его можно скачать и отправить в сообщении или распечатать, чтобы вручить лично.","secondParagraph":"Дальше — дело за получателем: он активирует сертификат в профиле Wildberries, и деньги приходят в его WB Кошелёк. Если кошелька нет, сразу же предложим его создать: это мгновенно и бесплатно."}},"whereStored":{"question":"Где хранятся сертификаты после покупки?","answer":"Профиль&nbsp;&rarr; Покупки&nbsp;&rarr; Все товары&nbsp;&rarr; {{- linkStart}}Подарочные сертификаты{{- linkEnd}}"},"whatCanBeBought":{"question":"На что можно потратить сертификат?","answer":"На любые товары на Wildberries, кроме другого сертификата. Если денег от сертификата не будет хватать, получатель сможет добавить свои и купить всё, что хочется."},"validityPeriod":{"question":"Сколько действует сертификат?","answer":"Его нужно активировать в течение 2 лет. После активации деньги хранятся без ограничений."},"withdrawal":{"question":"Можно ли вывести деньги от сертификата?","answer":"Нет, они остаются в WB Кошельке, пока их не потратить."},"returnPolicy":{"question":"Как вернуть сертификат?","answer":"Проще всего — его активировать и потратить деньги на покупки на Wildberries. Если вы хотите вернуть деньги туда, откуда они списались, почитайте {{- linkStart}}полные условия возврата{{- linkEnd}}."}},"popupSmsCode":{"subTitle":"Отправили его на {{phone}}","timerMessage":"Запросить код повторно через ","getNewCode":"Получить новый код"},"certificate":"Сертификат","certificateType":"Сертификат {{type}}","orderConfirmed":{"pending":{"title":"Проверяем оплату","text":{"single":"Скачать сертификат можно будет после проверки. Следите за статусом в покупках","plural":"Скачать сертификаты можно будет после проверки. Следите за статусом в покупках"}},"success":{"title":{"single":"Сертификат готов","plural":"Сертификаты готовы"},"text":"Можете отправить кому-то сейчас, а можете позже — через  {{- linkStart}}подарочные сертификаты{{- linkEnd}} в покупках","certName":"Электронный подарочный сертификат на {{- sum}}"}},"documentsChecked":"Документы проверены","sellerSentDocuments":"Продавец прислал документы, которые подтверждают безопасность товара","isCardBinding":"Карта успешно привязана","paymentFailed":"Оплата не прошла, попробуйте ещё — с&nbsp;этим&nbsp;же или другим способом оплаты","attemptsOver":"Попытки кончились","tryBuy":"Попробуйте купить сертификат через 24 часа","requestFailedMsg":"Сервис временно недоступен. Попробуйте позже","requestAlreadyActivated":"Этот сертификат уже активирован","requestEmpty":"Такого сертификата нет","errorSms":"Не подходит, попробуйте ещё","errorVariable":"Активация сертификатов временно <br>не работает. Попробуйте позже"}}')
        }
    }, __webpack_module_cache__ = {}, leafPrototypes, getProto, inProgress, dataWebpackPrefix;
    function __webpack_require__(e) {
        var t = __webpack_module_cache__[e];
        if (void 0 !== t)
            return t.exports;
        var r = __webpack_module_cache__[e] = {
            exports: {}
        };
        return __webpack_modules__[e](r, r.exports, __webpack_require__),
        r.exports
    }
    __webpack_require__.m = __webpack_modules__,
    __webpack_require__.n = function(e) {
        var t = e && e.__esModule ? function() {
            return e.default
        }
        : function() {
            return e
        }
        ;
        return __webpack_require__.d(t, {
            a: t
        }),
        t
    }
    ,
    getProto = Object.getPrototypeOf ? function(e) {
        return Object.getPrototypeOf(e)
    }
    : function(e) {
        return e.__proto__
    }
    ,
    __webpack_require__.t = function(e, t) {
        if (1 & t && (e = this(e)),
        8 & t)
            return e;
        if ("object" == typeof e && e) {
            if (4 & t && e.__esModule)
                return e;
            if (16 & t && "function" == typeof e.then)
                return e
        }
        var r = Object.create(null);
        __webpack_require__.r(r);
        var s = {};
        leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
        for (var n = 2 & t && e; "object" == typeof n && !~leafPrototypes.indexOf(n); n = getProto(n))
            Object.getOwnPropertyNames(n).forEach((function(t) {
                s[t] = function() {
                    return e[t]
                }
            }
            ));
        return s.default = function() {
            return e
        }
        ,
        __webpack_require__.d(r, s),
        r
    }
    ,
    __webpack_require__.d = function(e, t) {
        for (var r in t)
            __webpack_require__.o(t, r) && !__webpack_require__.o(e, r) && Object.defineProperty(e, r, {
                enumerable: !0,
                get: t[r]
            })
    }
    ,
    __webpack_require__.f = {},
    __webpack_require__.e = function(e) {
        return Promise.all(Object.keys(__webpack_require__.f).reduce((function(t, r) {
            return __webpack_require__.f[r](e, t),
            t
        }
        ), []))
    }
    ,
    __webpack_require__.u = function(e) {
        return "site/app/" + ({
            4267: "personalCabinet-components-Delivery",
            5064: "personalCabinet-components-Installment",
            7466: "personalCabinet-components-UserInfo",
            8149: "personalCabinet-components-Balance",
            13376: "personalCabinet-components-Orders",
            36708: "customerReceipt-viewModel",
            38200: "personalCabinet-viewModel",
            43204: "customerReceipt-viewModel-CustomerReceiptsViewModel",
            48829: "generalPreloader",
            51119: "customerReceipt-CustomerReceiptPage",
            53214: "helpers",
            54386: "personalCabinet-components-Favorites",
            55361: "personalCabinet-components-Recommendations",
            59855: "personalCabinet-components-Payment",
            62919: "personalCabinet-viewModel-PersonalCabinetViewModel",
            64210: "react-app",
            69397: "loadingError",
            75387: "personalCabinet-PersonalCabinetPage",
            76590: "personalCabinet-components-Advertisement",
            76979: "swiper",
            81013: "customerReceipt",
            86210: "personalCabinet-components-Evaluate",
            89362: "react-vendors",
            90126: "personalCabinet-components-Sale",
            98209: "personalCabinet-components-FavoriteBrands",
            98241: "personalCabinet"
        }[e] || e) + "." + {
            4267: "b4411f89631991ac373e",
            5064: "0420d911f753f4f184a7",
            7466: "709ccad6ee1edfb56079",
            8149: "226efb6dcbc3193cdf37",
            13376: "c4aa6033fde508169eb6",
            20939: "428d0db92551b50b0fba",
            36708: "34eec233c518aba1f509",
            38200: "7d3028add18ac3165ebb",
            43204: "63b60af4e3ad3fef1909",
            48829: "b79b00ef399ac8e99da2",
            51119: "37a450177de3a244e6b0",
            53214: "989086ee01b4d181eca0",
            54386: "b0f49beb7e90fc6318e8",
            55361: "e45aabed07261cc85561",
            59855: "154973bf7a536bfe3eab",
            62919: "b9594a2050e76adae55e",
            64210: "4c48d648d4dd94d22e33",
            69043: "130406765b6347c451f1",
            69397: "4e78c34e9abfab05d7df",
            73526: "4876961c8ad4b91f3ca7",
            75387: "dbd0796667054f6fb2bb",
            76590: "0150eeea39a32c252dc8",
            76979: "ab07bafdb38dcc4f293a",
            81013: "06015fb2f52eeedd7e1c",
            86210: "2f3950770f1da817e579",
            89362: "9eb77fb49b103b278192",
            90126: "edcb9dfe3491fab14383",
            90861: "cbb6ef9fd986e1cea903",
            98209: "b6955a1955bb6f7aba29",
            98241: "92bf2a7123e75883e7b0"
        }[e] + ".js"
    }
    ,
    __webpack_require__.miniCssF = function(e) {
        return "site/app/" + {
            48829: "generalPreloader",
            69397: "loadingError",
            76979: "swiper"
        }[e] + "." + {
            48829: "afe2ccfd4a81a33f9c85",
            69397: "78148e150cc9a669eaa4",
            76979: "97ff20a59f7bf7d94fbf"
        }[e] + ".css"
    }
    ,
    __webpack_require__.g = function() {
        if ("object" == typeof globalThis)
            return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" == typeof window)
                return window
        }
    }(),
    __webpack_require__.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
    ,
    inProgress = {},
    dataWebpackPrefix = "wildberries:",
    __webpack_require__.l = function(e, t, r, s) {
        if (inProgress[e])
            inProgress[e].push(t);
        else {
            var n, a;
            if (void 0 !== r)
                for (var o = document.getElementsByTagName("script"), i = 0; i < o.length; i++) {
                    var l = o[i];
                    if (l.getAttribute("src") == e || l.getAttribute("data-webpack") == dataWebpackPrefix + r) {
                        n = l;
                        break
                    }
                }
            n || (a = !0,
            (n = document.createElement("script")).charset = "utf-8",
            n.timeout = 120,
            __webpack_require__.nc && n.setAttribute("nonce", __webpack_require__.nc),
            n.setAttribute("data-webpack", dataWebpackPrefix + r),
            n.src = e),
            inProgress[e] = [t];
            var c = function(t, r) {
                n.onerror = n.onload = null,
                clearTimeout(u);
                var s = inProgress[e];
                if (delete inProgress[e],
                n.parentNode && n.parentNode.removeChild(n),
                s && s.forEach((function(e) {
                    return e(r)
                }
                )),
                t)
                    return t(r)
            }
              , u = setTimeout(c.bind(null, void 0, {
                type: "timeout",
                target: n
            }), 12e4);
            n.onerror = c.bind(null, n.onerror),
            n.onload = c.bind(null, n.onload),
            a && document.head.appendChild(n)
        }
    }
    ,
    __webpack_require__.r = function(e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }
    ,
    function() {
        var e;
        __webpack_require__.g.importScripts && (e = __webpack_require__.g.location + "");
        var t = __webpack_require__.g.document;
        if (!e && t && (t.currentScript && "SCRIPT" === t.currentScript.tagName.toUpperCase() && (e = t.currentScript.src),
        !e)) {
            var r = t.getElementsByTagName("script");
            if (r.length)
                for (var s = r.length - 1; s > -1 && (!e || !/^http(s?):/.test(e)); )
                    e = r[s--].src
        }
        if (!e)
            throw new Error("Automatic publicPath is not supported in this browser");
        e = e.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/"),
        __webpack_require__.p = e + "../../../"
    }(),
    function() {
        if ("undefined" != typeof document) {
            var e = function(e) {
                return new Promise((function(t, r) {
                    var s = __webpack_require__.miniCssF(e)
                      , n = __webpack_require__.p + s;
                    if (function(e, t) {
                        for (var r = document.getElementsByTagName("link"), s = 0; s < r.length; s++) {
                            var n = (o = r[s]).getAttribute("data-href") || o.getAttribute("href");
                            if ("stylesheet" === o.rel && (n === e || n === t))
                                return o
                        }
                        var a = document.getElementsByTagName("style");
                        for (s = 0; s < a.length; s++) {
                            var o;
                            if ((n = (o = a[s]).getAttribute("data-href")) === e || n === t)
                                return o
                        }
                    }(s, n))
                        return t();
                    !function(e, t, r, s, n) {
                        var a = document.createElement("link");
                        a.rel = "stylesheet",
                        a.type = "text/css",
                        __webpack_require__.nc && (a.nonce = __webpack_require__.nc),
                        a.onerror = a.onload = function(r) {
                            if (a.onerror = a.onload = null,
                            "load" === r.type)
                                s();
                            else {
                                var o = r && r.type
                                  , i = r && r.target && r.target.href || t
                                  , l = new Error("Loading CSS chunk " + e + " failed.\n(" + o + ": " + i + ")");
                                l.name = "ChunkLoadError",
                                l.code = "CSS_CHUNK_LOAD_FAILED",
                                l.type = o,
                                l.request = i,
                                a.parentNode && a.parentNode.removeChild(a),
                                n(l)
                            }
                        }
                        ,
                        a.href = t,
                        r ? r.parentNode.insertBefore(a, r.nextSibling) : document.head.appendChild(a)
                    }(e, n, null, t, r)
                }
                ))
            }
              , t = {
                10122: 0,
                49864: 0,
                69869: 0,
                25307: 0,
                55278: 0
            };
            __webpack_require__.f.miniCss = function(r, s) {
                t[r] ? s.push(t[r]) : 0 !== t[r] && {
                    48829: 1,
                    69397: 1,
                    76979: 1
                }[r] && s.push(t[r] = e(r).then((function() {
                    t[r] = 0
                }
                ), (function(e) {
                    throw delete t[r],
                    e
                }
                )))
            }
        }
    }(),
    function() {
        var e = {
            10122: 0,
            49864: 0,
            69869: 0,
            25307: 0,
            55278: 0
        };
        __webpack_require__.f.j = function(t, r) {
            var s = __webpack_require__.o(e, t) ? e[t] : void 0;
            if (0 !== s)
                if (s)
                    r.push(s[2]);
                else if (/^(48829|69397|76979)$/.test(t))
                    e[t] = 0;
                else {
                    var n = new Promise((function(r, n) {
                        s = e[t] = [r, n]
                    }
                    ));
                    r.push(s[2] = n);
                    var a = __webpack_require__.p + __webpack_require__.u(t)
                      , o = new Error;
                    __webpack_require__.l(a, (function(r) {
                        if (__webpack_require__.o(e, t) && (0 !== (s = e[t]) && (e[t] = void 0),
                        s)) {
                            var n = r && ("load" === r.type ? "missing" : r.type)
                              , a = r && r.target && r.target.src;
                            o.message = "Loading chunk " + t + " failed.\n(" + n + ": " + a + ")",
                            o.name = "ChunkLoadError",
                            o.type = n,
                            o.request = a,
                            s[1](o)
                        }
                    }
                    ), "chunk-" + t, t)
                }
        }
        ;
        var t = function(t, r) {
            var s, n, a = r[0], o = r[1], i = r[2], l = 0;
            if (a.some((function(t) {
                return 0 !== e[t]
            }
            ))) {
                for (s in o)
                    __webpack_require__.o(o, s) && (__webpack_require__.m[s] = o[s]);
                if (i)
                    i(__webpack_require__)
            }
            for (t && t(r); l < a.length; l++)
                n = a[l],
                __webpack_require__.o(e, n) && e[n] && e[n][0](),
                e[n] = 0
        }
          , r = self.webpackChunkwildberries = self.webpackChunkwildberries || [];
        r.forEach(t.bind(null, 0)),
        r.push = t.bind(null, r.push.bind(r))
    }(),
    __webpack_require__(30311),
    __webpack_require__(25314);
    var __webpack_exports__ = __webpack_require__(81868)
}
)();
